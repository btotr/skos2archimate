# baseURI: http://archimate.politie.nl/skos2archimate/service/export.temp

@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix composite: <http://www.topbraid.org/2007/05/composite.owl#> .
@prefix converter: <http://archimate.politie.nl/skos2archimate/converter#> .
@prefix daml: <http://www.daml.org/2001/03/daml+oil#> .
@prefix dash: <http://datashapes.org/dash#> .
@prefix dbp: <http://dbpedia.org/property/> .
@prefix dbpo: <http://dbpedia.org/ontology/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix default: <http://uispin.org/default#> .
@prefix email: <http://topbraid.org/email#> .
@prefix endpoint: <http://archimate.politie.nl/skos2archimate/service#> .
@prefix export: <http://archimate.politie.nl/skos2archimate/service/export#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix graphql: <http://datashapes.org/graphql#> .
@prefix json: <http://topbraid.org/json#> .
@prefix let: <http://uispin.org/let#> .
@prefix letrs: <http://uispin.org/letrs#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix search: <http://topbraid.org/search#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix sm: <http://topbraid.org/sparqlmotion#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sml: <http://topbraid.org/sparqlmotionlib#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix spr: <http://spinrdf.org/spr#> .
@prefix spra: <http://spinrdf.org/spra#> .
@prefix swa: <http://topbraid.org/swa#> .
@prefix sxml: <http://topbraid.org/sxml#> .
@prefix tosh: <http://topbraid.org/tosh#> .
@prefix ui: <http://uispin.org/ui#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

rdf:type
  a rdf:Property ;
  rdfs:comment "The subject is an instance of a class." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "type" ;
  rdfs:range rdfs:Class ;
.
<http://archimate.politie.nl/skos2archimate/service/export>
  a owl:Ontology ;
  owl:imports <http://topbraid.org/sparqlmotionlib> ;
  owl:versionInfo "simple example for sparqlMotion" ;
.
export:ApplyTopSPIN
  a sml:ApplyTopSPIN ;
  sm:next export:ImportCurrentRDF_1 ;
  sm:nodeX 484 ;
  sm:nodeY 598 ;
  sml:flatten false ;
  sml:predicate spin:rule ;
  sml:replace true ;
  sml:singlePass true ;
  rdfs:label "Apply Inferencing" ;
.
export:ConvertRDFToXML
  a sml:ConvertRDFToXML ;
  sm:next export:Response ;
  sm:nodeX 298 ;
  sm:nodeY 712 ;
  sm:outputVariable "archimatexml" ;
  sml:document converter:model ;
  rdfs:label "Convert RDF To XML" ;
.
export:ExportToRDFFile_1
  a sml:ExportToRDFFile ;
  sm:next export:ImportRDFFromWorkspace_1 ;
  sm:nodeX 84 ;
  sm:nodeY 325 ;
  sml:baseURI "http://skos2archimate.politie.nl/export/" ;
  sml:targetFilePath "output/skos2archimate.rdf" ;
  rdfs:label "Export to RDFFile 1" ;
.
export:ImportConverter
  a sml:ImportRDFFromWorkspace ;
  sm:next export:ApplyTopSPIN ;
  sm:nodeX 463 ;
  sm:nodeY 121 ;
  sml:baseURI "http://archimate.politie.nl/skos2archimate/converter" ;
  sml:ignoreImports false ;
  sml:sourceFilePath "converter.ttl" ;
  rdfs:label "Import converter" ;
.
export:ImportCurrentRDF_1
  a sml:ImportCurrentRDF ;
  rdfs:label "Import current RDF 1" ;
.
export:ImportRDFFromWorkspace_1
  a sml:ImportRDFFromWorkspace ;
  sm:nodeX 28 ;
  sm:nodeY 615 ;
  sml:baseURI "http://skos2archimate.politie.nl/export/" ;
  sml:ignoreImports false ;
  sml:sourceFilePath "output/skos2archimate.rdf" ;
  rdfs:label "Import RDFFrom workspace 1" ;
.
export:ImportRDFFromWorkspace_2
  a sml:ImportRDFFromWorkspace ;
  sm:next export:ApplyTopSPIN ;
  sm:next export:ImportCurrentRDF_1 ;
  sm:nodeX 727 ;
  sm:nodeY 135 ;
  sml:baseURI "http://www.opengroup.org/xsd/archimate/3.0/" ;
  sml:ignoreImports true ;
  sml:sourceFilePath "proxies/archimate_3.ttl" ;
  rdfs:label "Import RDFFrom workspace 2" ;
.
export:ImportRDFFromWorkspace_3
  a sml:ImportRDFFromWorkspace ;
  sm:next export:ConvertRDFToXML ;
  sm:nodeX 139 ;
  sm:nodeY 504 ;
  sml:baseURI "http://skos2archimate.politie.nl/export/" ;
  sml:ignoreImports false ;
  sml:sourceFilePath "output/skos2archimate.rdf" ;
  rdfs:label "Import RDFFrom workspace 3" ;
.
export:Response
  a sml:ReturnXML ;
  sm:nodeX 530 ;
  sm:nodeY 920 ;
  sml:mimeType "text/xml" ;
  sml:xml "{?archimatexml}"^^rdf:XMLLiteral ;
  rdfs:label "response" ;
.
<http://datashapes.org/dash>
  a owl:Ontology ;
  rdfs:comment """DASH defines SPARQL-based validators for many SHACL Core constraint components. These are (among others) utilized by TopBraid and its API. Note that constraint components that require validation of nested shapes (such as sh:node) are not implementable without a function such as tosh:hasShape.

DASH is also a SHACL library for frequently needed features and design patterns. All features in this library are 100% standards compliant and will work on any engine that fully supports SHACL.""" ;
  rdfs:label "DASH Data Shapes Library" ;
  owl:imports <http://topbraid.org/tosh> ;
  owl:imports sh: ;
  sh:declare [
      sh:namespace "http://datashapes.org/dash#"^^xsd:anyURI ;
      sh:prefix "dash" ;
    ] ;
  sh:declare [
      sh:namespace "http://purl.org/dc/terms/"^^xsd:anyURI ;
      sh:prefix "dcterms" ;
    ] ;
  sh:declare [
      sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI ;
      sh:prefix "rdf" ;
    ] ;
  sh:declare [
      sh:namespace "http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI ;
      sh:prefix "rdfs" ;
    ] ;
  sh:declare [
      sh:namespace "http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI ;
      sh:prefix "xsd" ;
    ] ;
  sh:declare [
      sh:namespace "http://www.w3.org/2002/07/owl#"^^xsd:anyURI ;
      sh:prefix "owl" ;
    ] ;
  sh:declare [
      sh:namespace "http://www.w3.org/2004/02/skos/core#"^^xsd:anyURI ;
      sh:prefix "skos" ;
    ] ;
.
dash:
  tosh:systemNamespace true ;
.
dash:AllObjects
  a dash:AllObjectsTarget ;
  rdfs:comment "A reusable instance of dash:AllObjectsTarget." ;
  rdfs:label "All objects" ;
.
dash:AllObjectsTarget
  a sh:JSTargetType ;
  a sh:SPARQLTargetType ;
  rdfs:comment "A target containing all objects in the data graph as focus nodes." ;
  rdfs:label "All objects target" ;
  rdfs:subClassOf sh:Target ;
  sh:jsFunctionName "dash_allObjects" ;
  sh:jsLibrary dash:DASHJSLibrary ;
  sh:labelTemplate "All objects" ;
  sh:prefixes <http://datashapes.org/dash> ;
  sh:select """SELECT DISTINCT ?this
WHERE {
    ?anyS ?anyP ?this .
}""" ;
.
dash:AllSubjects
  a dash:AllSubjectsTarget ;
  rdfs:comment "A reusable instance of dash:AllSubjectsTarget." ;
  rdfs:label "All subjects" ;
.
dash:AllSubjectsTarget
  a sh:JSTargetType ;
  a sh:SPARQLTargetType ;
  rdfs:comment "A target containing all subjects in the data graph as focus nodes." ;
  rdfs:label "All subjects target" ;
  rdfs:subClassOf sh:Target ;
  sh:jsFunctionName "dash_allSubjects" ;
  sh:jsLibrary dash:DASHJSLibrary ;
  sh:labelTemplate "All subjects" ;
  sh:prefixes <http://datashapes.org/dash> ;
  sh:select """SELECT DISTINCT ?this
WHERE {
    ?this ?anyP ?anyO .
}""" ;
.
dash:ClosedByTypesConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to declare that focus nodes are \"closed\" based on their rdf:types, meaning that focus nodes may only have values for the properties that are explicitly enumerated via sh:property/sh:path in property constraints at their rdf:types and the superclasses of those. This assumes that the type classes are also shapes." ;
  rdfs:label "Closed by types constraint component" ;
  sh:nodeValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateClosedByTypesNode" ;
      sh:jsLibrary dash:DASHJSLibrary ;
      sh:message "Property is not among those permitted for any of the types" ;
    ] ;
  sh:nodeValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Property {?path} is not among those permitted for any of the types" ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """SELECT $this (?predicate AS ?path) ?value
WHERE {
	FILTER ($closedByTypes) .
    $this ?predicate ?value .
	FILTER (?predicate != rdf:type) .
	FILTER NOT EXISTS {
		$this rdf:type ?type .
		?type rdfs:subClassOf* ?class .
		GRAPH $shapesGraph {
			?class sh:property/sh:path ?predicate .
		}
	}
}""" ;
    ] ;
  sh:parameter dash:ClosedByTypesConstraintComponent-closedByTypes ;
  sh:targetClass sh:NodeShape ;
.
dash:ClosedByTypesConstraintComponent-closedByTypes
  a sh:Parameter ;
  sh:path dash:closedByTypes ;
  sh:datatype xsd:boolean ;
  sh:description "True to indicate that the focus nodes are closed by their types. A constraint violation is reported for each property value of the focus node where the property is not among those that are explicitly declared via sh:property/sh:path in any of the rdf:types of the focus node (and their superclasses). The property rdf:type is always permitted." ;
  sh:group tosh:OtherConstraintPropertyGroup ;
.
dash:CoExistsWithConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to express a constraint on property shapes so that if the property path has any value then the given property must also have a value, and vice versa." ;
  rdfs:label "Co-exists-with constraint component" ;
  sh:message "Values must co-exist with values of {$coExistsWith}" ;
  sh:parameter dash:CoExistsWithConstraintComponent-coExistsWith ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateCoExistsWith" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """SELECT $this
WHERE {
	{
    	FILTER (EXISTS { $this $PATH ?any } && NOT EXISTS { $this $coExistsWith ?any })
	}
	UNION
	{
    	FILTER (NOT EXISTS { $this $PATH ?any } && EXISTS { $this $coExistsWith ?any })
	}
}""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
dash:CoExistsWithConstraintComponent-coExistsWith
  a sh:Parameter ;
  sh:path dash:coExistsWith ;
  sh:class rdf:Property ;
  sh:group tosh:PropertyPairConstraintPropertyGroup ;
  sh:nodeKind sh:IRI ;
  sh:order "10"^^xsd:decimal ;
.
dash:DASHJSLibrary
  a sh:JSLibrary ;
  rdfs:label "DASH JavaScript library" ;
  sh:jsLibrary dash:RDFQueryJSLibrary ;
  sh:jsLibraryURL "http://datashapes.org/js/dash.js"^^xsd:anyURI ;
.
dash:DateOrDateTime
  a rdf:List ;
  rdf:first [
      sh:datatype xsd:date ;
    ] ;
  rdf:rest (
      [
        sh:datatype xsd:dateTime ;
      ]
    ) ;
  rdfs:comment "An rdf:List that can be used in property constraints as value for sh:or to indicate that all values of a property must be either xsd:date or xsd:dateTime." ;
  rdfs:label "Date or date time" ;
.
dash:DefaultValueTypeRule
  a sh:SPARQLConstructExecutable ;
  rdfs:comment """
		A resource encapsulating a query that can be used to construct rdf:type triples for certain untyped nodes
		that are an object in a triple where the predicate has a sh:defaultValueType.
		This can be used as a pre-processor for shape graphs before they are validated.
		"""^^rdf:HTML ;
  rdfs:label "default value type inference rule" ;
  sh:construct """
		CONSTRUCT {
			?node a ?defaultValueType .
		}
		WHERE {
			?predicate sh:defaultValueType ?defaultValueType .
			?anySubject ?predicate ?node .
			FILTER (NOT EXISTS { ?node a ?anyType }) .
		}
		""" ;
.
dash:ExecutionPlatform
  a rdfs:Class ;
  rdfs:comment "An platform (such as TopBraid) that may have features needed to execute, for example, SPARQL queries." ;
  rdfs:label "Execution platform" ;
  rdfs:subClassOf rdfs:Resource ;
.
dash:FailureResult
  a rdfs:Class ;
  rdfs:comment "A result representing a validation failure such as an unsupported recursion." ;
  rdfs:label "Failure result" ;
  rdfs:subClassOf sh:AbstractResult ;
.
dash:FailureTestCaseResult
  a rdfs:Class ;
  rdfs:comment "Represents a failure of a test case." ;
  rdfs:label "Failure test case result" ;
  rdfs:subClassOf dash:TestCaseResult ;
.
dash:FunctionTestCase
  a rdfs:Class ;
  rdfs:comment "A test case that verifies that a given SPARQL expression produces a given, expected result." ;
  rdfs:label "Function test case" ;
  rdfs:subClassOf dash:TestCase ;
  sh:property [
      sh:path dash:expectedResult ;
      sh:description "The expected result of a function call." ;
      sh:maxCount 1 ;
      sh:name "expected result" ;
    ] ;
  sh:property [
      sh:path dash:expression ;
      sh:description "A valid SPARQL expression calling the function to test." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "expression" ;
    ] ;
.
dash:GraphStoreTestCase
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "A test case that can be used to verify that an RDF file could be loaded (from a file) and that the resulting RDF graph is equivalent to a given TTL file." ;
  rdfs:label "Graph store test case" ;
  rdfs:subClassOf dash:TestCase ;
  sh:property [
      a sh:PropertyShape ;
      sh:path dash:expectedResult ;
      sh:datatype xsd:string ;
      sh:description "The expected RDF graph, as a Turtle string." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path dash:uri ;
      sh:datatype xsd:anyURI ;
      sh:description "The URI of the graph to load." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "uri" ;
    ] ;
.
dash:GraphUpdate
  a rdfs:Class ;
  rdfs:comment "A suggestion consisting of added and/or deleted triples, represented as rdf:Statements via dash:addedTriple and dash:deletedTriple." ;
  rdfs:label "Graph update" ;
  rdfs:subClassOf dash:Suggestion ;
.
dash:GraphValidationTestCase
  a rdfs:Class ;
  rdfs:comment "A test case that performs SHACL constraint validation on the whole graph and compares the results with the expected validation results stored with the test case. By default this excludes meta-validation (i.e. the validation of the shape definitions themselves). If that's desired, set dash:validateShapes to true." ;
  rdfs:label "Graph validation test case" ;
  rdfs:subClassOf dash:ValidationTestCase ;
.
dash:HTMLOrStringOrLangString
  a rdf:List ;
  rdf:first [
      sh:datatype rdf:HTML ;
    ] ;
  rdf:rest (
      [
        sh:datatype xsd:string ;
      ]
      [
        sh:datatype rdf:langString ;
      ]
    ) ;
  rdfs:comment "An rdf:List that can be used in property constraints as value for sh:or to indicate that all values of a property must be either rdf:HTML, xsd:string or rdf:langString." ;
  rdfs:label "HTML or string or langString" ;
.
dash:HasValueWithClassConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to express a constraint on property shapes so that one of the values of the property path must be an instance of a given class." ;
  rdfs:label "Has value with class constraint component" ;
  sh:message "At least one of the values must be an instance of class {$hasValueWithClass}" ;
  sh:parameter dash:HasValueWithClassConstraintComponent-hasValueWithClass ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateHasValueWithClass" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """SELECT $this
WHERE {
	FILTER NOT EXISTS {
    	$this $PATH ?value .
		?value a ?type .
		?type rdfs:subClassOf* ?hasValueWithClass .
	}
}""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
dash:HasValueWithClassConstraintComponent-hasValueWithClass
  a sh:Parameter ;
  sh:path dash:hasValueWithClass ;
  sh:class rdfs:Class ;
  sh:group tosh:OtherConstraintPropertyGroup ;
  sh:nodeKind sh:IRI ;
.
dash:InferencingTestCase
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "A test case to verify whether an inferencing engine is producing identical results to those stored as expected results." ;
  rdfs:label "Inferencing test case" ;
  rdfs:subClassOf dash:TestCase ;
  sh:property [
      sh:path dash:expectedResult ;
      sh:description "The expected inferred triples, represented by instances of rdfs:Statement." ;
      sh:name "expected result" ;
    ] ;
.
dash:JSTestCase
  a rdfs:Class ;
  rdfs:comment "A test case that calls a given JavaScript function like a sh:JSFunction and compares its result with the dash:expectedResult." ;
  rdfs:label "JavaScript test case" ;
  rdfs:subClassOf dash:TestCase ;
  rdfs:subClassOf sh:JSFunction ;
  sh:property [
      sh:path dash:expectedResult ;
      sh:description "The expected result of the JavaScript function call, as an RDF node." ;
      sh:maxCount 1 ;
      sh:name "expected result" ;
    ] ;
.
dash:ListNodeShape
  a sh:NodeShape ;
  rdfs:comment "Defines constraints on what it means for a node to be a node within a well-formed RDF list. Note that this does not check whether the rdf:rest items are also well-formed lists as this would lead to unsupported recursion." ;
  rdfs:label "List node shape" ;
  sh:or (
      [
        sh:hasValue () ;
        sh:property [
            sh:path rdf:first ;
            sh:maxCount 0 ;
          ] ;
        sh:property [
            sh:path rdf:rest ;
            sh:maxCount 0 ;
          ] ;
      ]
      [
        sh:not [
            sh:hasValue () ;
          ] ;
        sh:property [
            sh:path rdf:first ;
            sh:maxCount 1 ;
            sh:minCount 1 ;
          ] ;
        sh:property [
            sh:path rdf:rest ;
            sh:maxCount 1 ;
            sh:minCount 1 ;
          ] ;
      ]
    ) ;
.
dash:ListShape
  a sh:NodeShape ;
  rdfs:comment """Defines constraints on what it means for a node to be a well-formed RDF list.

The focus node must either be rdf:nil or not recursive. Furthermore, this shape uses dash:ListNodeShape as a \"helper\" to walk through all members of the whole list (including itself).""" ;
  rdfs:label "List shape" ;
  sh:or (
      [
        sh:hasValue () ;
      ]
      [
        sh:not [
            sh:hasValue () ;
          ] ;
        sh:property [
            sh:path [
                sh:oneOrMorePath rdf:rest ;
              ] ;
            dash:nonRecursive true ;
          ] ;
      ]
    ) ;
  sh:property [
      sh:path [
          sh:zeroOrMorePath rdf:rest ;
        ] ;
      rdfs:comment "Each list member (including this node) must be have the shape dash:ListNodeShape." ;
      sh:node dash:ListNodeShape ;
    ] ;
.
dash:NonRecursiveConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  rdfs:comment """Used to state that a property or path must not point back to itself.

For example, \"a person cannot have itself as parent\" can be expressed by setting dash:nonRecursive=true for a given sh:path.

To express that a person cannot have itself among any of its (recursive) parents, use a sh:path with the + operator such as ex:parent+.""" ;
  rdfs:label "Non-recursive constraint component" ;
  sh:message "Points back at itself (recursively)" ;
  sh:parameter dash:NonRecursiveConstraintComponent-nonRecursive ;
  sh:property [
      sh:path dash:nonRecursive ;
      sh:group tosh:RelationshipPropertyGroup ;
    ] ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateNonRecursiveProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """SELECT DISTINCT $this ($this AS ?value)
WHERE {
	{
		FILTER (?nonRecursive)
	}
    $this $PATH $this .
}""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
dash:NonRecursiveConstraintComponent-nonRecursive
  a sh:Parameter ;
  sh:path dash:nonRecursive ;
  sh:datatype xsd:boolean ;
  sh:maxCount 1 ;
  sh:name "non-recursive" ;
.
dash:None
  a sh:NodeShape ;
  rdfs:comment "A Shape that is no node can conform to." ;
  rdfs:label "None" ;
  sh:in () ;
.
dash:ParameterConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to verify that all value nodes conform to the given Parameter."@en ;
  rdfs:label "Parameter constraint component"@en ;
  sh:parameter dash:ParameterConstraintComponent-parameter ;
.
dash:ParameterConstraintComponent-parameter
  a sh:Parameter ;
  sh:path sh:parameter ;
.
dash:PrimaryKeyConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "Enforces a constraint that the given property (sh:path) serves as primary key for all resources in the target of the shape. If a property has been declared to be the primary key then each resource must have exactly one value for that property. Furthermore, the URIs of those resources must start with a given string (dash:uriStart), followed by the URL-encoded primary key value. For example if dash:uriStart is \"http://example.org/country-\" and the primary key for an instance is \"de\" then the URI must be \"http://example.org/country-de\". Finally, as a result of the URI policy, there can not be any other resource with the same value under the same primary key policy." ;
  rdfs:label "Primary key constraint component" ;
  sh:labelTemplate "The property {?predicate} is the primary key and URIs start with {?uriStart}" ;
  sh:message "Violation of primary key constraint" ;
  sh:parameter dash:PrimaryKeyConstraintComponent-uriStart ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validatePrimaryKeyProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """SELECT DISTINCT $this
WHERE {
        FILTER (
			# Must have a value for the primary key
			NOT EXISTS { ?this $PATH ?any }
			||
			# Must have no more than one value for the primary key
			EXISTS {
				?this $PATH ?value1 .
				?this $PATH ?value2 .
				FILTER (?value1 != ?value2) .
			}
			||
			# The value of the primary key must align with the derived URI
			EXISTS {
				{
        			?this $PATH ?value .
					FILTER NOT EXISTS { ?this $PATH ?value2 . FILTER (?value != ?value2) }
				}
        		BIND (CONCAT($uriStart, ENCODE_FOR_URI(str(?value))) AS ?uri) .
        		FILTER (str(?this) != ?uri) .
    		}
		)
}""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
dash:PrimaryKeyConstraintComponent-uriStart
  a sh:Parameter ;
  sh:path dash:uriStart ;
  tosh:editWidget swa:PlainTextFieldEditor ;
  sh:datatype xsd:string ;
  sh:description "The start of the URIs of well-formed resources. If specified then the associated property/path serves as \"primary key\" for all target nodes (instances). All such target nodes need to have a URI that starts with the given string, followed by the URI-encoded value of the primary key property." ;
  sh:group tosh:PrimaryKeyPropertyGroup ;
  sh:name "URI start" ;
.
dash:QueryTestCase
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "A test case running a given SPARQL SELECT query and comparing its results with those stored as JSON Result Set in the expected result property." ;
  rdfs:label "Query test case" ;
  rdfs:subClassOf dash:TestCase ;
  rdfs:subClassOf sh:SPARQLSelectExecutable ;
  sh:property [
      sh:path dash:expectedResult ;
      sh:datatype xsd:string ;
      sh:description "The expected result set, as a JSON string." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "expected result" ;
    ] ;
  sh:property [
      sh:path sh:select ;
      sh:datatype xsd:string ;
      sh:description "The SPARQL SELECT query to execute." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "SPARQL query" ;
    ] ;
.
dash:RDFQueryJSLibrary
  a sh:JSLibrary ;
  rdfs:label "rdfQuery JavaScript Library" ;
  sh:jsLibraryURL "http://datashapes.org/js/rdfquery.js"^^xsd:anyURI ;
.
dash:RootClassConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  rdfs:comment "A constraint component defining the parameter dash:rootClass, which restricts the values to be either the root class itself or one of its subclasses. This is typically used in conjunction with properties that have rdfs:Class as their type." ;
  rdfs:label "Root class constraint component" ;
  sh:labelTemplate "Root class {$rootClass}" ;
  sh:message "Value must be subclass of {$rootClass}" ;
  sh:parameter dash:RootClassConstraintComponent-rootClass ;
  sh:targetClass sh:PropertyShape ;
  sh:validator dash:hasRootClass ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateRootClass" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
dash:RootClassConstraintComponent-rootClass
  a sh:Parameter ;
  sh:path dash:rootClass ;
  sh:class rdfs:Class ;
  sh:description "The root class." ;
  sh:name "root class" ;
  sh:nodeKind sh:IRI ;
.
dash:SPARQLUpdateSuggestionGenerator
  a rdfs:Class ;
  rdfs:comment """A SuggestionGenerator based on a SPARQL UPDATE query (sh:update), producing an instance of dash:GraphUpdate. The INSERTs become dash:addedTriple and the DELETEs become dash:deletedTriple. The WHERE clause operates on the data graph with the pre-bound variables $subject, $predicate and $object, as well as the other pre-bound variables for the parameters of the constraint.

In many cases, there may be multiple possible suggestions to fix a problem. For example, with sh:maxLength there are many ways to slice a string. In those cases, the system will first iterate through the result variables from a SELECT query (sh:select) and apply these results as pre-bound variables into the UPDATE query.""" ;
  rdfs:label "SPARQL UPDATE suggestion generator" ;
  rdfs:subClassOf dash:SuggestionGenerator ;
  rdfs:subClassOf sh:SPARQLSelectExecutable ;
  rdfs:subClassOf sh:SPARQLUpdateExecutable ;
.
dash:StemConstraintComponent
  a sh:ConstraintComponent ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to verify that every value node is an IRI and the IRI starts with a given string value."@en ;
  rdfs:label "Stem constraint component"@en ;
  sh:labelTemplate "Value needs to have stem {$stem}" ;
  sh:message "Value does not have stem {$stem}" ;
  sh:parameter dash:StemConstraintComponent-stem ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasStem ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateStem" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
dash:StemConstraintComponent-stem
  a sh:Parameter ;
  sh:path dash:stem ;
  sh:datatype xsd:string ;
  sh:group tosh:StringBasedConstraintPropertyGroup ;
.
dash:StringOrLangString
  a rdf:List ;
  rdf:first [
      sh:datatype xsd:string ;
    ] ;
  rdf:rest (
      [
        sh:datatype rdf:langString ;
      ]
    ) ;
  rdfs:comment "An rdf:List that can be used in property constraints as value for sh:or to indicate that all values of a property must be either xsd:string or rdf:langString." ;
  rdfs:label "String or langString" ;
.
dash:SubSetOfConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to state that the set of value nodes must be a subset of the value of a given property." ;
  rdfs:label "Sub set of constraint component" ;
  sh:message "Must be one of the values of {$subSetOf}" ;
  sh:parameter dash:SubSetOfConstraintComponent-subSetOf ;
  sh:propertyValidator [
      a sh:SPARQLAskValidator ;
      sh:ask """ASK {
    $this $subSetOf $value .
}""" ;
      sh:prefixes <http://datashapes.org/dash> ;
    ] ;
  sh:targetClass sh:PropertyShape ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateSubSetOf" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
dash:SubSetOfConstraintComponent-subSetOf
  a sh:Parameter ;
  sh:path dash:subSetOf ;
  sh:class rdf:Property ;
  sh:description "A property (of the focus node) that must (at least) have all values from the set of value nodes." ;
.
dash:SuccessResult
  a rdfs:Class ;
  rdfs:comment "A result representing a successfully validated constraint." ;
  rdfs:label "Success result" ;
  rdfs:subClassOf sh:AbstractResult ;
.
dash:SuccessTestCaseResult
  a rdfs:Class ;
  rdfs:comment "Represents a successful run of a test case." ;
  rdfs:label "Success test case result" ;
  rdfs:subClassOf dash:TestCaseResult ;
.
dash:Suggestion
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "Base class of suggestions that modify a graph to \"fix\" the source of a validation result." ;
  rdfs:label "Suggestion" ;
  rdfs:subClassOf rdfs:Resource ;
.
dash:SuggestionGenerator
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "Base class of objects that can generate suggestions (added or deleted triples) for a validation result of a given constraint component." ;
  rdfs:label "Suggestion generator" ;
  rdfs:subClassOf rdfs:Resource ;
.
dash:SuggestionResult
  a rdfs:Class ;
  rdfs:comment "Class of results that have been produced as suggestions, not through SHACL validation. How the actual results are produced is up to implementers. Each instance of this class should have values for sh:focusNode, sh:resultMessage, sh:resultSeverity (suggested default: sh:Info), and dash:suggestion to point at one or more suggestions." ;
  rdfs:label "Suggestion result" ;
  rdfs:subClassOf sh:AbstractResult ;
.
dash:SymmetricConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Add symmetric value." ;
      sh:order "0"^^xsd:decimal ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:update """INSERT {
    $value $predicate $focusNode .
}
WHERE {
}""" ;
    ] ;
  rdfs:comment "A contraint component for property shapes to validate that a property is symmetric. For symmetric properties, if A relates to B then B must relate to A." ;
  rdfs:label "Symmetric constraint component" ;
  sh:message "Symmetric value expected" ;
  sh:parameter dash:SymmetricConstraintComponent-symmetric ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateSymmetric" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """SELECT $this ?value {
	FILTER ($symmetric) .
	$this $PATH ?value .
	FILTER NOT EXISTS {
    	$value $PATH $this .
	}
}""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
dash:SymmetricConstraintComponent-symmetric
  a sh:Parameter ;
  sh:path dash:symmetric ;
  sh:datatype xsd:boolean ;
  sh:group tosh:RelationshipPropertyGroup ;
.
dash:TestCase
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "A test case to verify that a (SHACL-based) feature works as expected." ;
  rdfs:label "Test case" ;
  rdfs:subClassOf rdfs:Resource ;
.
dash:TestCaseResult
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "Base class for results produced by running test cases." ;
  rdfs:label "Test case result" ;
  rdfs:subClassOf sh:AbstractResult ;
  sh:property [
      sh:path dash:testCase ;
      sh:class dash:TestCase ;
      sh:description "The dash:TestCase that was executed." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "test case" ;
    ] ;
  sh:property [
      sh:path dash:testGraph ;
      sh:class rdfs:Resource ;
      sh:description "The graph containing the test case." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "test graph" ;
      sh:nodeKind sh:IRI ;
    ] ;
.
dash:TestEnvironment
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "Abstract base class for test environments, holding information on how to set up a test case." ;
  rdfs:label "Test environment" ;
  rdfs:subClassOf rdfs:Resource ;
.
dash:UniqueValueForClassConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  rdfs:comment "A constraint component that can be used to state that the values of a property must be unique for all instances of a given class (and its subclasses)." ;
  rdfs:label "Unique value for class constraint component" ;
  sh:labelTemplate "Values must be unique among all instances of {?uniqueValueForClass}" ;
  sh:parameter dash:UniqueValueForClassConstraintComponent-uniqueValueForClass ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateUniqueValueForClass" ;
      sh:jsLibrary dash:DASHJSLibrary ;
      sh:message "Value {?value} must be unique but is also used by {?other}" ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Value {?value} must be unique but is also used by {?other}" ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """SELECT DISTINCT $this ?value ?other
WHERE {
	{
    	$this $PATH ?value .
		?other $PATH ?value .
		FILTER (?other != $this) .
	}
	?other a ?type .
	?type rdfs:subClassOf* $uniqueValueForClass .
}""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
dash:UniqueValueForClassConstraintComponent-uniqueValueForClass
  a sh:Parameter ;
  sh:path dash:uniqueValueForClass ;
  sh:class rdfs:Class ;
  sh:nodeKind sh:IRI ;
.
dash:ValidationTestCase
  a rdfs:Class ;
  a sh:NodeShape ;
  dash:abstract true ;
  rdfs:comment "Abstract superclass for test cases concerning SHACL constraint validation. Future versions may add new kinds of validatin test cases, e.g. to validate a single resource only." ;
  rdfs:label "Validation test case" ;
  rdfs:subClassOf dash:TestCase ;
  sh:property [
      sh:path dash:expectedResult ;
      sh:class sh:ValidationReport ;
      sh:description "The expected validation report." ;
      sh:name "expected result" ;
    ] ;
.
dash:abstract
  a rdf:Property ;
  rdfs:comment "Indicates that a class is \"abstract\" and cannot be used in asserted rdf:type triples. Only non-abstract subclasses of abstract classes should be instantiated directly." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "abstract" ;
  rdfs:range xsd:boolean ;
.
dash:addedTriple
  a rdf:Property ;
  rdfs:comment "May link a dash:GraphUpdate with one or more triples (represented as instances of rdf:Statement) that should be added to fix the source of the result." ;
  rdfs:domain dash:GraphUpdate ;
  rdfs:label "added triple" ;
  rdfs:range rdf:Statement ;
.
dash:all
  rdfs:comment "Represents all users/roles, for example as a possible value of the default view for role property." ;
.
dash:applicableToClass
  a rdf:Property ;
  rdfs:comment "Can be used to state that a shape is applicable to instances of a given class. This is a softer statement than \"target class\": a target means that all instances of the class must conform to the shape. Being applicable to simply means that the shape may apply to (some) instances of the class. This information can be used by algorithms or humans." ;
  rdfs:domain sh:Shape ;
  rdfs:label "applicable to class" ;
  rdfs:range rdfs:Class ;
.
dash:arg
  a rdf:Property ;
.
dash:arg1
  a rdf:Property ;
.
dash:arg2
  a rdf:Property ;
.
dash:arg3
  a rdf:Property ;
.
dash:cachable
  a rdf:Property ;
  rdfs:comment "If set to true then the results of the SHACL function can be cached in between invocations with the same arguments. In other words, they are stateless and do not depend on triples in any graph, or the current time stamp etc." ;
  rdfs:domain sh:Function ;
  rdfs:label "cachable" ;
  rdfs:range xsd:boolean ;
.
dash:closedByTypes
  a rdf:Property ;
  rdfs:label "closed by types" ;
.
dash:coExistsWith
  a rdf:Property ;
  rdfs:comment "Specifies a property that must have a value whenever the property path has a value, and must have no value whenever the property path has no value." ;
  rdfs:label "co-exists with" ;
  rdfs:range rdf:Property ;
.
dash:composite
  a rdf:Property ;
  rdfs:comment "Can be used to indicate that a property/path represented by a property constraint represents a composite relationship. In a composite relationship, the life cycle of a \"child\" object (value of the property/path) depends on the \"parent\" object (focus node). If the parent gets deleted, then the child objects should be deleted, too. Tools may use dash:composite (if set to true) to implement cascading delete operations." ;
  rdfs:domain sh:PropertyShape ;
  rdfs:label "composite" ;
  rdfs:range xsd:boolean ;
.
dash:constraintOrShape
  a rdf:Property ;
.
dash:defaultValueType
  a rdf:Property ;
  rdfs:comment """
		Links a property with a default value type.
		The default value type is assumed to be the <code>rdf:type</code> of values of the property
		that declare no type on their own.
		An example use of <code>sh:defaultValueType</code> is <code>sh:property</code>,
		the values of which are assumed to be instances of <code>sh:PropertyShape</code>
		even if they are untyped (blank) nodes.
		"""^^rdf:HTML ;
  rdfs:label "default value type" ;
  rdfs:range rdfs:Class ;
  owl:versionInfo "Note this property may get removed in future versions. It is a left-over from a previous design in SHACL." ;
.
dash:defaultViewForRole
  a rdf:Property ;
  rdfs:comment "Links a node shape with the roles for which it shall be used as default view. User interfaces can use these values to select how to present a given RDF resource. The values of this property are URIs representing a group of users or agents. There is a dedicated URI dash:all representing all users." ;
  rdfs:domain sh:NodeShape ;
  rdfs:label "default view for role" ;
.
dash:deletedTriple
  a rdf:Property ;
  rdfs:comment "May link a dash:GraphUpdate result with one or more triples (represented as instances of rdf:Statement) that should be deleted to fix the source of the result." ;
  rdfs:domain dash:GraphUpdate ;
  rdfs:label "deleted triple" ;
  rdfs:range rdf:Statement ;
.
dash:expectedResult
  a rdf:Property ;
  rdfs:comment "The expected result(s) of a test case. The value range of this property is different for each kind of test cases." ;
  rdfs:domain dash:TestCase ;
  rdfs:label "expected result" ;
.
dash:expectedResultIsJSON
  a rdf:Property ;
  rdfs:comment "A flag to indicate that the expected result represents a JSON string. If set to true, then tests would compare JSON structures (regardless of whitespaces) instead of actual syntax." ;
  rdfs:label "expected result is JSON" ;
  rdfs:range xsd:boolean ;
.
dash:expectedResultIsTTL
  a rdf:Property ;
  rdfs:comment "A flag to indicate that the expected result represents an RDF graph encoded as a Turtle file. If set to true, then tests would compare graphs instead of actual syntax." ;
  rdfs:domain dash:TestCase ;
  rdfs:label "expected result is Turtle" ;
  rdfs:range xsd:boolean ;
.
dash:expression
  a rdf:Property ;
.
dash:fixed
  a rdf:Property ;
  rdfs:comment "Can be used to mark that certain validation results have already been fixed." ;
  rdfs:domain sh:ValidationResult ;
  rdfs:label "fixed" ;
  rdfs:range xsd:boolean ;
.
dash:hasClass
  a sh:SPARQLAskValidator ;
  rdfs:label "has class" ;
  sh:ask """
		ASK {
			$value rdf:type/rdfs:subClassOf* $class .
		}
		""" ;
  sh:message "Value does not have class {$class}" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasMaxExclusive
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given node (?value) has a value less than (<) the provided ?maxExclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types." ;
  rdfs:label "has max exclusive" ;
  sh:ask "ASK { FILTER ($value < $maxExclusive) }" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasMaxInclusive
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given node (?value) has a value less than or equal to (<=) the provided ?maxInclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types." ;
  rdfs:label "has max inclusive" ;
  sh:ask "ASK { FILTER ($value <= $maxInclusive) }" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasMaxLength
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given string (?value) has a length within a given maximum string length." ;
  rdfs:label "has max length" ;
  sh:ask """
		ASK {
			FILTER (STRLEN(str($value)) <= $maxLength) .
		}
		""" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasMinExclusive
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given node (?value) has value greater than (>) the provided ?minExclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types." ;
  rdfs:label "has min exclusive" ;
  sh:ask "ASK { FILTER ($value > $minExclusive) }" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasMinInclusive
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given node (?value) has value greater than or equal to (>=) the provided ?minInclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types." ;
  rdfs:label "has min inclusive" ;
  sh:ask "ASK { FILTER ($value >= $minInclusive) }" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasMinLength
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given string (?value) has a length within a given minimum string length." ;
  rdfs:label "has min length" ;
  sh:ask """
		ASK {
			FILTER (STRLEN(str($value)) >= $minLength) .
		}
		""" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasNodeKind
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given node (?value) has a given sh:NodeKind (?nodeKind). For example, sh:hasNodeKind(42, sh:Literal) = true." ;
  rdfs:label "has node kind" ;
  sh:ask """
		ASK {
			FILTER ((isIRI($value) && $nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
				(isLiteral($value) && $nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
				(isBlank($value)   && $nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )) .
		}
		""" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasPattern
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether the string representation of a given node (?value) matches a given regular expression (?pattern). Returns false if the value is a blank node." ;
  rdfs:label "has pattern" ;
  sh:ask "ASK { FILTER (!isBlank($value) && IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern))) }" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasRootClass
  a sh:SPARQLAskValidator ;
  rdfs:label "has root class" ;
  sh:ask """ASK {
    $value rdfs:subClassOf* $rootClass .
}""" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasStem
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given node is an IRI starting with a given stem." ;
  rdfs:label "has stem" ;
  sh:ask "ASK { FILTER (isIRI($value) && STRSTARTS(str($value), $stem)) }" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:hasValueWithClass
  a rdf:Property ;
  rdfs:comment "Specifies a constraint that at least one of the value nodes must be an instance of a given class." ;
  rdfs:label "has value with class" ;
  rdfs:range rdfs:Class ;
.
dash:height
  a rdf:Property ;
  rdfs:comment "The height." ;
  rdfs:label "height" ;
  rdfs:range xsd:integer ;
.
dash:includedExecutionPlatform
  a rdf:Property ;
  rdfs:comment "Can be used to state that one (subject) execution platform includes all features of another platform (object)." ;
  rdfs:domain dash:ExecutionPlatform ;
  rdfs:label "included execution platform" ;
  rdfs:range dash:ExecutionPlatform ;
.
dash:isDeactivated
  a sh:SPARQLFunction ;
  rdfs:comment "Checks whether a given shape or constraint has been marked as \"deactivated\" using sh:deactivated." ;
  rdfs:label "is deactivated" ;
  sh:ask """ASK {
    ?constraintOrShape sh:deactivated true .
}""" ;
  sh:parameter [
      sh:path dash:constraintOrShape ;
      sh:description "The sh:Constraint or sh:Shape to test." ;
      sh:name "constraint or shape" ;
    ] ;
  sh:prefixes <http://datashapes.org/dash> ;
  sh:returnType xsd:boolean ;
.
dash:isIn
  a sh:SPARQLAskValidator ;
  rdfs:label "is in" ;
  sh:ask """
		ASK {
			GRAPH $shapesGraph {
				$in (rdf:rest*)/rdf:first $value .
			}
		}
		""" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:isLanguageIn
  a sh:SPARQLAskValidator ;
  rdfs:label "is language in" ;
  sh:ask """
		ASK {
			BIND (lang($value) AS ?valueLang) .
			FILTER EXISTS {
				GRAPH $shapesGraph {
					$languageIn (rdf:rest*)/rdf:first ?lang .
				    FILTER (langMatches(?valueLang, ?lang))
				} }
		}
		""" ;
  sh:prefixes <http://datashapes.org/dash> ;
.
dash:isNodeKindBlankNode
  a sh:SPARQLFunction ;
  dash:cachable true ;
  rdfs:comment "Checks if a given sh:NodeKind is one that includes BlankNodes." ;
  rdfs:label "is NodeKind BlankNode" ;
  sh:ask """ASK {
	FILTER ($nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ))
}""" ;
  sh:parameter [
      sh:path dash:nodeKind ;
      sh:class sh:NodeKind ;
      sh:description "The sh:NodeKind to check." ;
      sh:name "node kind" ;
      sh:nodeKind sh:IRI ;
    ] ;
  sh:prefixes <http://datashapes.org/dash> ;
  sh:returnType xsd:boolean ;
.
dash:isNodeKindIRI
  a sh:SPARQLFunction ;
  dash:cachable true ;
  rdfs:comment "Checks if a given sh:NodeKind is one that includes IRIs." ;
  rdfs:label "is NodeKind IRI" ;
  sh:ask """ASK {
	FILTER ($nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ))
}""" ;
  sh:parameter [
      sh:path dash:nodeKind ;
      sh:class sh:NodeKind ;
      sh:description "The sh:NodeKind to check." ;
      sh:name "node kind" ;
      sh:nodeKind sh:IRI ;
    ] ;
  sh:prefixes <http://datashapes.org/dash> ;
  sh:returnType xsd:boolean ;
.
dash:isNodeKindLiteral
  a sh:SPARQLFunction ;
  dash:cachable true ;
  rdfs:comment "Checks if a given sh:NodeKind is one that includes Literals." ;
  rdfs:label "is NodeKind Literal" ;
  sh:ask """ASK {
	FILTER ($nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ))
}""" ;
  sh:parameter [
      sh:path dash:nodeKind ;
      sh:class sh:NodeKind ;
      sh:description "The sh:NodeKind to check." ;
      sh:name "node kind" ;
      sh:nodeKind sh:IRI ;
    ] ;
  sh:prefixes <http://datashapes.org/dash> ;
  sh:returnType xsd:boolean ;
.
dash:localConstraint
  a rdf:Property ;
  rdfs:comment """Can be set to true for those constraint components where the validation does not require to visit any other triples than the shape definitions and the direct property values of the focus node mentioned in the property constraints. Examples of this include sh:minCount and sh:hasValue.

Constraint components that are marked as such can be optimized by engines, e.g. they can be evaluated client-side at form submission time, without having to make a round-trip to a server, assuming the client has downloaded a complete snapshot of the resource.

Any component marked with dash:staticConstraint is also a dash:localConstraint.""" ;
  rdfs:domain sh:ConstraintComponent ;
  rdfs:label "local constraint" ;
  rdfs:range xsd:boolean ;
.
dash:nodeKind
  a rdf:Property ;
.
dash:nonRecursive
  a rdf:Property ;
.
dash:predicate
  a rdf:Property ;
.
dash:propertySuggestionGenerator
  a rdf:Property ;
  rdfs:comment "Links the constraint component with instances of dash:SuggestionGenerator that may be used to produce suggestions for a given validation result that was produced by a property constraint." ;
  rdfs:domain sh:ConstraintComponent ;
  rdfs:label "property suggestion generator" ;
  rdfs:range dash:SuggestionGenerator ;
.
dash:requiredExecutionPlatform
  a rdf:Property ;
  rdfs:comment "Links a SPARQL executable with the platforms that it can be executed on. This can be used by a SHACL implementation to determine whether a constraint validator or rule shall be ignored based on the current platform. For example, if a SPARQL query uses a function or magic property that is only available in TopBraid then a non-TopBraid platform can ignore the constraint (or simply always return no validation results). If this property has no value then the assumption is that the execution will succeed. As soon as one value exists, the assumption is that the engine supports at least one of the given platforms." ;
  rdfs:domain sh:SPARQLExecutable ;
  rdfs:label "required execution platform" ;
  rdfs:range dash:ExecutionPlatform ;
.
dash:rootClass
  a rdf:Property ;
  rdfs:label "root class" ;
.
dash:shape
  a rdf:Property ;
  rdfs:comment "States that a subject resource has a given shape. This property can, for example, be used to capture results of SHACL validation on static data." ;
  rdfs:label "shape" ;
  rdfs:range sh:Shape ;
.
dash:staticConstraint
  a rdf:Property ;
  rdfs:comment """Can be set to true for those constraint components where the validation does not require to visit any other triples than the parameters. Examples of this include sh:datatype or sh:nodeKind, where no further triples need to be queried to determine the result.

Constraint components that are marked as such can be optimized by engines, e.g. they can be evaluated client-side at form submission time, without having to make a round-trip to a server.""" ;
  rdfs:domain sh:ConstraintComponent ;
  rdfs:label "static constraint" ;
  rdfs:range xsd:boolean ;
.
dash:stem
  a rdf:Property ;
  rdfs:comment "Specifies a string value that the IRI of the value nodes must start with."@en ;
  rdfs:label "stem"@en ;
  rdfs:range xsd:string ;
.
dash:subSetOf
  a rdf:Property ;
  rdfs:label "sub set of" ;
.
dash:subject
  a rdf:Property ;
.
dash:suggestion
  a rdf:Property ;
  rdfs:comment "Can be used to link a result with one or more suggestions on how to address or improve the underlying issue." ;
  rdfs:domain sh:AbstractResult ;
  rdfs:label "suggestion" ;
  rdfs:range dash:Suggestion ;
.
dash:suggestionConfidence
  a rdf:Property ;
  rdfs:comment "An optional confidence between 0% and 100%. Suggestions with 100% confidence are strongly recommended. Can be used to sort recommended updates." ;
  rdfs:domain dash:Suggestion ;
  rdfs:label "suggestion confidence" ;
  rdfs:range xsd:decimal ;
.
dash:suggestionGenerator
  a rdf:Property ;
  rdfs:comment "Links a sh:SPARQLConstraint or sh:JSConstraint with instances of dash:SuggestionGenerator that may be used to produce suggestions for a given validation result that was produced by the constraint." ;
  rdfs:label "suggestion generator" ;
  rdfs:range dash:SuggestionGenerator ;
.
dash:suggestionGroup
  a rdf:Property ;
  rdfs:comment "Can be used to link a suggestion with the group identifier to which it belongs. By default this is a link to the dash:SuggestionGenerator, but in principle this could be any value." ;
  rdfs:domain dash:Suggestion ;
  rdfs:label "suggestion" ;
.
dash:symmetric
  a rdf:Property ;
  rdfs:comment "True to declare that the associated property path is symmetric." ;
  rdfs:label "symmetric" ;
.
dash:testCase
  a rdf:Property ;
.
dash:testEnvironment
  a rdf:Property ;
  rdfs:comment "Can be used by TestCases to point at a resource with information on how to set up the execution environment prior to execution." ;
  rdfs:domain dash:TestCase ;
  rdfs:label "test environment" ;
  rdfs:range dash:TestEnvironment ;
.
dash:testGraph
  a rdf:Property ;
.
dash:testModifiesEnvironment
  a rdf:Property ;
  rdfs:comment "Indicates whether this test modifies the specified dash:testEnvironment. If set to true then a test runner can make sure to wipe out the previous environment, while leaving it false (or undefined) means that the test runner can reuse the environment from the previous test case. As setting up and tearing down tests is sometimes slow, this flag can significantly accelerate test execution." ;
  rdfs:domain dash:TestCase ;
  rdfs:label "test modifies environment" ;
  rdfs:range xsd:boolean ;
.
dash:toString
  a sh:JSFunction ;
  a sh:SPARQLFunction ;
  dash:cachable true ;
  rdfs:comment "Returns a literal with datatype xsd:string that has the input value as its string. If the input value is an (URI) resource then its URI will be used." ;
  rdfs:label "to string" ;
  sh:jsFunctionName "dash_toString" ;
  sh:jsLibrary dash:DASHJSLibrary ;
  sh:labelTemplate "Convert {$arg} to xsd:string" ;
  sh:parameter [
      sh:path dash:arg ;
      sh:description "The input value." ;
      sh:name "arg" ;
      sh:nodeKind sh:IRIOrLiteral ;
    ] ;
  sh:prefixes <http://datashapes.org/dash> ;
  sh:returnType xsd:string ;
  sh:select """SELECT (xsd:string($arg) AS ?result)
WHERE {
}""" ;
.
dash:uniqueValueForClass
  a rdf:Property ;
  rdfs:label "unique value for class" ;
.
dash:uri
  a rdf:Property ;
.
dash:uriStart
  a rdf:Property ;
.
dash:validateShapes
  a rdf:Property ;
  rdfs:comment "True to also validate the shapes itself (i.e. parameter declarations)." ;
  rdfs:domain dash:GraphValidationTestCase ;
  rdfs:label "validate shapes" ;
  rdfs:range xsd:boolean ;
.
dash:valueCount
  a sh:SPARQLFunction ;
  rdfs:comment "Computes the number of objects for a given subject/predicate combination." ;
  rdfs:label "value count" ;
  sh:parameter [
      sh:path dash:predicate ;
      sh:class rdfs:Resource ;
      sh:description "The predicate to get the number of objects of." ;
      sh:name "predicate" ;
      sh:order 1 ;
    ] ;
  sh:parameter [
      sh:path dash:subject ;
      sh:class rdfs:Resource ;
      sh:description "The subject to get the number of objects of." ;
      sh:name "subject" ;
      sh:order 0 ;
    ] ;
  sh:prefixes <http://datashapes.org/dash> ;
  sh:returnType xsd:integer ;
  sh:select """
		SELECT (COUNT(?object) AS ?result)
		WHERE {
    		$subject $predicate ?object .
		}
""" ;
.
dash:width
  a rdf:Property ;
  rdfs:comment "The width." ;
  rdfs:label "width" ;
  rdfs:range xsd:integer ;
.
dash:x
  a rdf:Property ;
  rdfs:comment "The x position." ;
  rdfs:label "x" ;
  rdfs:range xsd:integer ;
.
dash:y
  a rdf:Property ;
  rdfs:comment "The y position." ;
  rdfs:label "y" ;
  rdfs:range xsd:integer ;
.
<http://datashapes.org/graphql>
  a owl:Ontology ;
  rdfs:comment "A vocabulary to annotate RDF schemas (in particular SHACL shapes) with metadata to define mappings to GraphQL." ;
  rdfs:label "GraphQL Vocabulary" ;
  owl:imports <http://datashapes.org/dash> ;
.
graphql:ClassShape
  a sh:NodeShape ;
  rdfs:label "GraphQL class shape" ;
  sh:property [
      a sh:PropertyShape ;
      sh:path [
          sh:inversePath graphql:protectedClass ;
        ] ;
      sh:class graphql:Schema ;
      sh:description "Protected classes (including subclasses) can only be queried if reached through a field from another shape." ;
      sh:group graphql:SchemaPropertyGroup ;
      sh:name "protected class of" ;
      sh:nodeKind sh:IRI ;
      sh:order 2.0 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path [
          sh:inversePath graphql:publicClass ;
        ] ;
      sh:class graphql:Schema ;
      sh:description "Public classes (including subclasses) can be queried without restrictions, unless marked as protected or private. This also includes shapes linked to these classes via sh:targetClass or dash:applicableToClass." ;
      sh:group graphql:SchemaPropertyGroup ;
      sh:name "public class of" ;
      sh:nodeKind sh:IRI ;
      sh:order 0.0 ;
    ] ;
  sh:targetClass rdfs:Class ;
.
graphql:InputObjectType
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "Represents an input object type in a GraphQL schema." ;
  rdfs:label "Input object type" ;
  rdfs:subClassOf rdfs:Resource ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:inputValue ;
      sh:class graphql:InputValue ;
      sh:description "The input value(s) of the input object type." ;
      sh:name "input value" ;
    ] ;
.
graphql:InputType
  a rdfs:Class ;
  a sh:NodeShape ;
  dash:abstract true ;
  rdfs:label "Input type" ;
  rdfs:subClassOf rdfs:Resource ;
.
graphql:InputValue
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "The definition of an input value, consisting of a name, type and an optional default value." ;
  rdfs:label "Input value" ;
  rdfs:subClassOf rdfs:Resource ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:defaultValue ;
      sh:description "The default value (if any), as an RDF node." ;
      sh:maxCount 1 ;
      sh:name "default value" ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:name ;
      sh:datatype xsd:string ;
      sh:description "The GraphQL name of the input type." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:type ;
      sh:class graphql:InputType ;
      sh:description "The allowed type of the input value." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "type" ;
    ] ;
.
graphql:JSON2RDFTestCase
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "A test case that can be used to verify that a given JSON object is translated into RDF triples using shape definitions from a given graphql:Service. The service must be in the test case graph." ;
  rdfs:label "JSON-to-RDF test case" ;
  rdfs:subClassOf dash:TestCase ;
  sh:property [
      a sh:PropertyShape ;
      sh:path dash:expectedResult ;
      sh:datatype xsd:string ;
      sh:description "The TTL of the resulting RDF." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:json ;
      sh:datatype xsd:string ;
      sh:description "The JSON text." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "json" ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:schema ;
      sh:class graphql:Schema ;
      sh:description "The GraphQL service." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "service" ;
      sh:nodeKind sh:IRI ;
    ] ;
.
graphql:ListType
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:label "List type" ;
  rdfs:subClassOf graphql:InputType ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:memberType ;
      sh:class graphql:InputType ;
      sh:description "The type of members." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "member type" ;
      sh:nodeKind sh:BlankNode ;
    ] ;
.
graphql:MutationTestCase
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "A test case that runs a given GraphQL mutation (graphql:query) and compares its output JSON with an expected JSON string. Formatting of the strings is ignored. The mutation is executed over a given \"before\" graph which must be isomorphic to a given \"after\" graph. The TestCase is also a graphql:Schema defining which shapes to publish." ;
  rdfs:label "GraphQL mutation test case" ;
  rdfs:subClassOf dash:TestCase ;
  rdfs:subClassOf graphql:Query ;
  rdfs:subClassOf graphql:Schema ;
  sh:property [
      a sh:PropertyShape ;
      sh:path dash:expectedResult ;
      sh:datatype xsd:string ;
      sh:description "The expected JSON response object as a string." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:dataGraph ;
      sh:datatype xsd:string ;
      sh:description "The TTL source code of the graph \"before\" the mutation. Uses the same namespace prefixes as the test case." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "before graph" ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:expectedGraph ;
      sh:datatype xsd:string ;
      sh:description "The TTL source code of the expected graph \"after\" the mutation. Uses the same namespace prefixes as the test case." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "after graph" ;
    ] ;
.
graphql:NameShape
  a sh:NodeShape ;
  rdfs:comment "Defines syntax restrictions on the use of the graphql:name property." ;
  rdfs:label "Name shape" ;
  owl:versionInfo "TODO: Add checks against duplicate names within the same shape (including superclasses and sh:node references)." ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:name ;
      sh:datatype xsd:string ;
      sh:maxCount 1 ;
      sh:pattern "^[_A-Za-z][_0-9A-Za-z]*$" ;
    ] ;
  sh:targetSubjectsOf graphql:name ;
.
graphql:NamedType
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:label "Named type" ;
  rdfs:subClassOf graphql:InputType ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:name ;
      sh:datatype xsd:string ;
      sh:description "The type name." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
    ] ;
.
graphql:NodeShapeShape
  a sh:NodeShape ;
  rdfs:label "GraphQL node shape shape" ;
  sh:property [
      a sh:PropertyShape ;
      sh:path [
          sh:inversePath graphql:privateShape ;
        ] ;
      sh:class graphql:Schema ;
      sh:description "Private shapes cannot be queried." ;
      sh:group graphql:SchemaPropertyGroup ;
      sh:name "private shape of" ;
      sh:nodeKind sh:IRI ;
      sh:order 4.0 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path [
          sh:inversePath graphql:protectedShape ;
        ] ;
      sh:class graphql:Schema ;
      sh:description "Protected shapes can only be queried if reached through a field from another shape." ;
      sh:group graphql:SchemaPropertyGroup ;
      sh:name "protected shape of" ;
      sh:nodeKind sh:IRI ;
      sh:order 3.0 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path [
          sh:inversePath graphql:publicShape ;
        ] ;
      sh:class graphql:Schema ;
      sh:description "Public shapes can be queried without restrictions." ;
      sh:group graphql:SchemaPropertyGroup ;
      sh:name "public shape of" ;
      sh:nodeKind sh:IRI ;
      sh:order 1.0 ;
    ] ;
  sh:targetClass sh:NodeShape ;
.
graphql:NonNullType
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:label "Non null type" ;
  rdfs:subClassOf graphql:InputType ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:type ;
      sh:class graphql:InputType ;
      sh:description "The type that is not-nulled." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "type" ;
      sh:nodeKind sh:BlankNode ;
    ] ;
.
graphql:Query
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "Represents specific GraphQL queries, stored by their query string and possibly other properties with metadata." ;
  rdfs:label "GraphQL query" ;
  rdfs:subClassOf rdfs:Resource ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:queryString ;
      sh:datatype xsd:string ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:variables ;
      sh:datatype xsd:string ;
      sh:maxCount 1 ;
    ] ;
.
graphql:QueryTestCase
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "A test case that runs a given GraphQL query (graphql:query) and compares its output JSON with an expected JSON string. Formatting of the strings is ignored. The TestCase is also a graphql:Schema defining which shapes to publish." ;
  rdfs:label "GraphQL query test case" ;
  rdfs:subClassOf dash:TestCase ;
  rdfs:subClassOf graphql:Query ;
  rdfs:subClassOf graphql:Schema ;
  sh:property [
      a sh:PropertyShape ;
      sh:path dash:expectedResult ;
      sh:datatype xsd:string ;
      sh:description "The expected JSON response object as a string." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
    ] ;
.
graphql:ScalarType
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment """Represents a scalar type as defined by a GraphQL schema. The primary purpose of these types is for round-tripping, otherwise they are basically the same as node shapes. The instances must be URIs, and the GraphQL name is derived from them.

This is currently not marked as a subClassOf sh:NodeShape, although this may happen in the future. The idea is that we don't want all constraint parameters to apply here, only selected ones such as sh:datatype. In the SHACL spec, anything that has constraints counts as a node shape, even if it doesn't have a matching rdf:type triple.""" ;
  rdfs:label "Scalar type" ;
  rdfs:subClassOf rdfs:Resource ;
  sh:property [
      a sh:PropertyShape ;
      sh:path sh:datatype ;
      sh:description "The (RDF/XSD) datatype that this scalar type refers to." ;
      sh:maxCount 1 ;
      sh:nodeKind sh:IRI ;
    ] ;
.
graphql:Schema
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment """A collection of shapes that are part of a GraphQL schema. Includes declarations about which shapes shall be exposed/published by a GraphQL service. The set of public node shapes consists of all values of graphql:publicShape, all values of graphql:publicClass and their subclasses, all node shapes from any namespace graphql:publicNamespace, minus any explicitly excluded shapes via graphql:privateShape.

An RDF graph may contain multiple GraphQL schemas, each providing a different API or view on the underlying data. GraphQL services can include each other using owl:imports. To simplify common usage patterns, owl:Ontology has been marked as a subclass, so that all Ontologies are also graphql:Schemas once this graphql namespace is imported.""" ;
  rdfs:label "GraphQL Schema" ;
  rdfs:subClassOf rdfs:Resource ;
  sh:nodeKind sh:IRI ;
  sh:property graphql:Schema-privateShape ;
  sh:property graphql:Schema-protectedClass ;
  sh:property graphql:Schema-protectedShape ;
  sh:property graphql:Schema-publicClass ;
  sh:property graphql:Schema-publicNamespace ;
  sh:property graphql:Schema-publicShape ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:defaultPrefix ;
      sh:class sh:PrefixDeclaration ;
      sh:maxCount 1 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:name ;
      sh:datatype xsd:string ;
      sh:description "A system name that can be used in URLs to identify this schema." ;
      sh:maxCount 1 ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:queryShape ;
      sh:class sh:NodeShape ;
      sh:description "The declared root shape of a GraphQL schema, specified using schema { query: ... } in GraphQL schema syntax. Can be used to round-trip GraphQL files." ;
      sh:maxCount 1 ;
      sh:name "query shape" ;
      sh:nodeKind sh:IRI ;
    ] ;
.
graphql:Schema-privateShape
  a sh:PropertyShape ;
  sh:path graphql:privateShape ;
  sh:class sh:NodeShape ;
  sh:description "Defines the shapes that shall not be published, overriding what has been specified to be public (e.g. via graphql:publicShape)." ;
  sh:group graphql:ShapesPropertyGroup ;
  sh:name "private shape" ;
  sh:nodeKind sh:IRI ;
  sh:order "20"^^xsd:decimal ;
.
graphql:Schema-protectedClass
  a sh:PropertyShape ;
  sh:path graphql:protectedClass ;
  sh:class rdfs:Class ;
  sh:description "Links to classes so that the class and all its subclasses are published, assuming they are also node shapes. Protected classes can however not be queried from the generated root query object." ;
  sh:group graphql:ShapesPropertyGroup ;
  sh:name "protected class" ;
  sh:nodeKind sh:IRI ;
  sh:order "11"^^xsd:decimal ;
.
graphql:Schema-protectedShape
  a sh:PropertyShape ;
  sh:path graphql:protectedShape ;
  sh:class sh:NodeShape ;
  sh:description "Specifies the shape(s) that the GraphQL schema is publishing but not accessible from the generated root query object." ;
  sh:group graphql:ShapesPropertyGroup ;
  sh:name "protected shape" ;
  sh:nodeKind sh:IRI ;
  sh:order "10"^^xsd:decimal ;
.
graphql:Schema-publicClass
  a sh:PropertyShape ;
  sh:path graphql:publicClass ;
  sh:class rdfs:Class ;
  sh:description "Links to classes so that the class and all its subclasses are published, assuming they are also node shapes. Also publishes any shapes linked to the class and its subclasses via sh:targetClass or dash:applicableToClass." ;
  sh:group graphql:ShapesPropertyGroup ;
  sh:name "public class" ;
  sh:nodeKind sh:IRI ;
  sh:order "2"^^xsd:decimal ;
.
graphql:Schema-publicNamespace
  a sh:PropertyShape ;
  sh:path graphql:publicNamespace ;
  sh:class sh:PrefixDeclaration ;
  sh:description "The namespace(s) of node shapes that shall be published by the GraphQL schema. Will use the values of sh:namespace of the linked prefix declarations." ;
  sh:group graphql:ShapesPropertyGroup ;
  sh:name "public namespace" ;
  sh:order "0"^^xsd:decimal ;
.
graphql:Schema-publicShape
  a sh:PropertyShape ;
  sh:path graphql:publicShape ;
  sh:class sh:NodeShape ;
  sh:description "Specifies the shape(s) that the GraphQL schema is publishing." ;
  sh:group graphql:ShapesPropertyGroup ;
  sh:name "public shape" ;
  sh:nodeKind sh:IRI ;
  sh:order "1"^^xsd:decimal ;
.
graphql:SchemaPropertyGroup
  a sh:PropertyGroup ;
  tosh:editGroupDescription "The properties in this group define how the current shape/class is made available to GraphQL services." ;
  tosh:openable true ;
  rdfs:label "GraphQL Schema" ;
  sh:order 1.5 ;
.
graphql:ShapesPropertyGroup
  a sh:PropertyGroup ;
  rdfs:label "Shapes" ;
  sh:order "5"^^xsd:decimal ;
.
graphql:WriterTestCase
  a rdfs:Class ;
  a sh:NodeShape ;
  rdfs:comment "A test case that can be used to verify that a RDF/SHACL to GraphQL writer works correctly. The expected result must be the complete GraphQL schema string." ;
  rdfs:label "Writer test case" ;
  rdfs:subClassOf dash:TestCase ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:canRoundTrip ;
      sh:datatype xsd:boolean ;
      sh:description "True to include a test comparing that reloading the generated string yields the same graph." ;
      sh:maxCount 1 ;
      sh:name "can round trip" ;
    ] ;
  sh:property [
      a sh:PropertyShape ;
      sh:path graphql:rdfGraph ;
      sh:datatype xsd:anyURI ;
      sh:description "The URI of the RDF graph to load." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "RDF graph" ;
    ] ;
.
graphql:canRoundTrip
  a rdf:Property ;
.
graphql:dataGraph
  a rdf:Property ;
.
graphql:defaultPrefix
  a rdf:Property ;
  rdfs:comment "Points at a prefix declaration of the default namespace for the shapes derived by GraphQL types. This property can be used to round-trip .graphql files." ;
  rdfs:label "default prefix" ;
.
graphql:defaultValue
  a rdf:Property ;
.
graphql:expectedGraph
  a rdf:Property ;
.
graphql:fieldName
  a sh:Function ;
  rdfs:comment "Gets the GraphQL field name for a property path at a given node shape." ;
  rdfs:label "field name" ;
  sh:parameter [
      a sh:Parameter ;
      sh:path graphql:nodeShape ;
      sh:class sh:NodeShape ;
      sh:name "node shape" ;
      sh:nodeKind sh:IRI ;
      sh:order "0"^^xsd:decimal ;
    ] ;
  sh:parameter [
      a sh:Parameter ;
      sh:path graphql:path ;
      sh:description "The property path expression (value of sh:path)." ;
      sh:name "path" ;
      sh:nodeKind sh:BlankNodeOrIRI ;
      sh:order 1 ;
    ] ;
  sh:returnType xsd:string ;
.
graphql:inputValue
  a rdf:Property ;
.
graphql:isIDField
  a rdf:Property ;
  rdfs:comment "Can be attached to property shapes to indicate they should be round-tripped as GraphQL type ID." ;
  rdfs:label "is ID field" ;
  rdfs:range xsd:boolean ;
.
graphql:isInterface
  a rdf:Property ;
  rdfs:comment "If set to true for a node shape, then it should become a GraphQL interface." ;
  rdfs:label "is GraphQL interface" ;
  rdfs:range xsd:boolean ;
.
graphql:json
  a rdf:Property ;
.
graphql:memberType
  a rdf:Property ;
.
graphql:name
  a rdf:Property ;
  rdfs:comment "Defines a GraphQL name for a given subject. The values need to match the regular expression specified in http://facebook.github.io/graphql/October2016/#Name." ;
  rdfs:label "name" ;
  rdfs:range xsd:string ;
.
graphql:nodeShape
  a rdf:Property ;
.
graphql:path
  a rdf:Property ;
.
graphql:privateShape
  a rdf:Property ;
.
graphql:protectedClass
  a rdf:Property ;
.
graphql:protectedShape
  a rdf:Property ;
.
graphql:publicClass
  a rdf:Property ;
.
graphql:publicNamespace
  a rdf:Property ;
.
graphql:publicShape
  a rdf:Property ;
.
graphql:query
  a rdf:Property ;
  rdfs:comment "The GraphQL query string." ;
  rdfs:label "query" ;
.
graphql:queryShape
  a rdf:Property ;
  rdfs:label "query shape" ;
  rdfs:range sh:NodeShape ;
.
graphql:queryString
  a rdf:Property ;
  rdfs:comment "The text of the actual query in GraphQL syntax." ;
  rdfs:label "query string" ;
.
graphql:rdfGraph
  a rdf:Property ;
.
graphql:schema
  a rdf:Property ;
.
graphql:type
  a rdf:Property ;
.
graphql:uriTemplate
  a rdf:Property ;
  rdfs:comment """Can be used to attach a URI template to node shapes, meaning that JSON objects that are processed with the given node shape will become URI resources with a URI derived from the given template. Example: \"ex:Person-{$id}\".

URI templates can include {...} blocks that contain a variable reference such as $id if the corresponding GraphQL type has a field named \"id\". Fields are mandatory by default, meaning that if a JSON converter attempts to produce a URI that lacks a mandatory field then the conversion fails with an exception.""" ;
  rdfs:domain sh:NodeShape ;
  rdfs:label "GraphQL URI template" ;
  rdfs:range xsd:string ;
.
graphql:variables
  a rdf:Property ;
  rdfs:comment "An optional JSON object with variables that shall be passed into the query for execution." ;
  rdfs:label "variables" ;
.
afn:e
  a spin:Function ;
  spin:returnType xsd:double ;
  rdfs:comment "Returns the value of e, as xsd:double." ;
  rdfs:label "e" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
afn:localname
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the URI resource to get the local name of" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns the local name of a URI resource. Based on splitting the IRI, not on any prefixes in the query or dataset. For example, the local name of http://test.com/my#Example is Example." ;
  rdfs:label "localname" ;
  rdfs:subClassOf spl:StringFunctions ;
.
afn:max
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first value to compare" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second value to compare" ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Gets the max value of two numeric arguments." ;
  rdfs:label "max" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
afn:min
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first value to compare" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second value to compare" ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Gets the min value of two numeric arguments." ;
  rdfs:label "min" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
afn:namespace
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the URI resource to get the namespace of" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns the namespace of a URI resource. Based on splitting the IRI, not on any prefixes in the query or dataset. For example, the namespace of http://test.com/my#Example is http://test.com/my#." ;
  rdfs:label "namespace" ;
  rdfs:subClassOf spl:StringFunctions ;
.
afn:now
  a spin:Function ;
  spin:returnType xsd:dateTime ;
  rdfs:comment "Gets the current time as xsd:dateTime.  Actually, the time the query started. Constant throughout a query execution." ;
  rdfs:label "now" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
afn:pi
  a spin:Function ;
  spin:returnType xsd:double ;
  rdfs:comment "Returns the value of pi, as an xsd:double." ;
  rdfs:label "pi" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
afn:sha1sum
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the value to get the sha1sum of" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Computes the sha1sum of a given input value (?arg1)." ;
  rdfs:label "sha1sum" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
afn:substr
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "the index of the last character to include in the result" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the text to get a sub string of" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "the index of the first character (text starts with index 0)" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Extracts a substring, Java style using startIndex and endIndex." ;
  rdfs:label "substr" ;
  rdfs:subClassOf spl:StringFunctions ;
.
arg:attributeName
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:baseGraph
  a rdf:Property ;
  rdfs:label "base graph" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:class
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:condition
  a rdf:Property ;
  rdfs:label "condition" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:data
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:dataProvider
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:datatype
  a rdf:Property ;
  rdfs:label "datatype" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:date
  a rdf:Property ;
  rdfs:label "date" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:divider
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:endIndex
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:fromIndex
  a rdf:Property ;
  rdfs:label "from index" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:graph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:graphURI
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:html
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:instance
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:language
  a rdf:Property ;
  rdfs:label "language" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:max
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxCount
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:maxLength
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:millis
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:min
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minCount
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:minLength
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:name
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:node
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:number
  a rdf:Property ;
  rdfs:label "number" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:otherProperty
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:param
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:password
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:pattern
  a rdf:Property ;
  rdfs:label "pattern" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:property
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:regex
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resource
  a rdf:Property ;
  rdfs:label "resource" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:resultSet
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:rule
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sessionGraph
  a rdf:Property ;
  rdfs:label "session graph" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:sourceFilePath
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:startIndex
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:this
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:thisValue
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:toIndex
  a rdf:Property ;
  rdfs:label "to index" ;
  rdfs:subPropertyOf sp:arg ;
.
arg:treatAnyLiteral
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:type
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:unionGraph
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:uriStart
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:url
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:user
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:userName
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:value
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
arg:xml
  a rdf:Property ;
  rdfs:subPropertyOf sp:arg ;
.
<http://spinrdf.org/sp>
  a owl:Ontology ;
  rdfs:comment "An RDF schema to syntactically represent SPARQL queries and update commands as RDF triples." ;
  rdfs:label "SPIN SPARQL Syntax" ;
  owl:versionInfo "1.5.1" ;
.
sp:
  tosh:systemNamespace true ;
.
sp:Add
  a rdfs:Class ;
  rdfs:comment "A SPARQL UPDATE ADD operation. Uses sp:source and sp:target to represent \"from\" and \"to\" graphs, respectively. Also sp:silent may be true." ;
  rdfs:label "Add" ;
  rdfs:seeAlso <https://www.w3.org/TR/sparql11-update/#add> ;
  rdfs:subClassOf sp:Update ;
.
sp:Aggregation
  a rdfs:Class ;
  rdfs:comment "Base class of aggregation types (not part of the SPARQL 1.0 standard but supported by ARQ and other engines)." ;
  rdfs:label "Aggregation" ;
  rdfs:subClassOf sp:SystemClass ;
.
sp:AltPath
  a rdfs:Class ;
  rdfs:comment "An alternative path with the union of sp:path1 and sp:path2." ;
  rdfs:label "Alt path" ;
  rdfs:subClassOf sp:Path ;
.
sp:Asc
  a rdfs:Class ;
  rdfs:comment "Marker to indicate ascending order." ;
  rdfs:label "Asc" ;
  rdfs:subClassOf sp:OrderByCondition ;
.
sp:Ask
  a rdfs:Class ;
  rdfs:comment "An ASK query that returns true if the condition in the body is met by at least one result set." ;
  rdfs:label "Ask" ;
  rdfs:subClassOf sp:Query ;
.
sp:Avg
  a rdfs:Class ;
  rdfs:comment "Represents AVG aggregations." ;
  rdfs:label "AVG" ;
  rdfs:subClassOf sp:Aggregation ;
.
sp:Bind
  a rdfs:Class ;
  rdfs:comment "A BIND element." ;
  rdfs:label "Bind" ;
  rdfs:subClassOf sp:Element ;
.
sp:Clear
  a rdfs:Class ;
  rdfs:comment "An Update operation that removes all triples from a specified graph. Must specify the graph using sp:graphIRI, or sp:default, sp:named or sp:all. May have the SILENT flag, encoded using sp:silent." ;
  rdfs:label "Clear" ;
  rdfs:subClassOf sp:Update ;
.
sp:Command
  a rdfs:Class ;
  rdfs:comment "A shared superclass for sp:Query and sp:Update that can be used to specify that the range of property can be either one." ;
  rdfs:label "Command" ;
  rdfs:subClassOf sp:SystemClass ;
.
sp:Construct
  a rdfs:Class ;
  rdfs:comment "A CONSTRUCT-type query that can be used to construct new triples from template triples (head) that use variable bindings from the match patterns (body)." ;
  rdfs:label "Construct" ;
  rdfs:subClassOf sp:Query ;
  rdfs:subClassOf spin:Rule ;
.
sp:Count
  a rdfs:Class ;
  rdfs:comment "Counts the number of times a variable is used. The variable is stored in the variable property. This might be left blank to indicate COUNT(*)." ;
  rdfs:label "COUNT" ;
  rdfs:subClassOf sp:Aggregation ;
.
sp:Create
  a rdfs:Class ;
  rdfs:comment "An Update operation that creates a new empty graph with a name specified by sp:graphIRI. May have sp:silent set to true." ;
  rdfs:label "Create" ;
  rdfs:subClassOf sp:Update ;
.
sp:Delete
  a rdfs:Class ;
  a owl:DeprecatedClass ;
  rdfs:comment """Deprecated - use sp:Modify instead.

Represents a DELETE FROM (part of SPARQL UPDATE language). The graph IRIs are stored in sp:graphIRI. The template patterns to delete are stored in sp:deletePattern. The WHERE clause is represented using sp:where.""" ;
  rdfs:label "Delete" ;
  rdfs:subClassOf sp:Modify ;
.
sp:DeleteData
  a rdfs:Class ;
  rdfs:comment "An Update operation to delete specific triples. The graph triples are represented using sp:data, which points to an rdf:List of sp:Triples or sp:NamedGraphs." ;
  rdfs:label "Delete data" ;
  rdfs:subClassOf sp:Update ;
.
sp:DeleteWhere
  a rdfs:Class ;
  rdfs:comment "An Update operation where the triples matched by the WHERE clause (sp:where) will be the triples deleted." ;
  rdfs:label "Delete where" ;
  rdfs:subClassOf sp:Update ;
  rdfs:subClassOf spin:Rule ;
.
sp:Desc
  a rdfs:Class ;
  rdfs:comment "Marker to indicate descending order." ;
  rdfs:label "Desc" ;
  rdfs:subClassOf sp:OrderByCondition ;
.
sp:Describe
  a rdfs:Class ;
  rdfs:comment "A DESCRIBE-type Query." ;
  rdfs:label "Describe" ;
  rdfs:subClassOf sp:Query ;
.
sp:Drop
  a rdfs:Class ;
  rdfs:comment "An Update operation that removes a specified graph from the Graph Store. Must specify the graph using sp:graphIRI, or sp:default, sp:named or sp:all. May have the SILENT flag, encoded using sp:silent." ;
  rdfs:label "Drop" ;
  rdfs:subClassOf sp:Update ;
.
sp:Element
  a rdfs:Class ;
  rdfs:comment "An abstract base class for all pattern elements." ;
  rdfs:label "Element" ;
  rdfs:subClassOf sp:SystemClass ;
.
sp:ElementGroup
  a rdfs:Class ;
  rdfs:comment "Abstract base class of group patterns." ;
  rdfs:label "Element group" ;
  rdfs:subClassOf sp:Element ;
.
sp:ElementList
  a rdfs:Class ;
  rdfs:comment "A list of Elements. This class is never instantiated directly as SPIN will use plain rdf:Lists to store element lists." ;
  rdfs:label "Element list" ;
  rdfs:subClassOf sp:ElementGroup ;
  rdfs:subClassOf rdf:List ;
.
sp:Exists
  a rdfs:Class ;
  rdfs:comment "An EXISTS element group." ;
  rdfs:label "Exists" ;
  rdfs:subClassOf sp:ElementGroup ;
.
sp:Filter
  a rdfs:Class ;
  rdfs:comment "A constraint element that evaluates a given expression to true or false." ;
  rdfs:label "Filter" ;
  rdfs:subClassOf sp:Element ;
.
sp:GroupConcat
  a rdfs:Class ;
  rdfs:comment "Represents GROUP_CONCAT aggregations." ;
  rdfs:label "GROUP_CONCAT" ;
  rdfs:subClassOf sp:Aggregation ;
.
sp:Insert
  a rdfs:Class ;
  a owl:DeprecatedClass ;
  rdfs:comment """Deprecated - use sp:Modify instead.

Represents a INSERT INTO (part of SPARQL UPDATE language). The graph IRIs are stored in sp:graphIRI. The template patterns to delete are stored in sp:insertPattern. The WHERE clause is represented using sp:where.""" ;
  rdfs:label "Insert" ;
  rdfs:subClassOf sp:Modify ;
.
sp:InsertData
  a rdfs:Class ;
  rdfs:comment "An Update operation to insert specific triples. The graph triples are represented using sp:data, which points to an rdf:List of sp:Triples or sp:NamedGraphs." ;
  rdfs:label "Insert data" ;
  rdfs:subClassOf sp:Update ;
.
sp:Let
  a rdfs:Class ;
  a owl:DeprecatedClass ;
  rdfs:comment """Deprecated: use sp:Bind instead.

A variable assignment (LET (?<varName> := <expression>)). Not part of the SPARQL 1.0 standard, but (for example) ARQ.""" ;
  rdfs:label "Let" ;
  rdfs:subClassOf sp:Bind ;
.
sp:Load
  a rdfs:Class ;
  rdfs:comment "A LOAD Update operation. The document to load is specified using sp:document, and the (optional) target graph using sp:into." ;
  rdfs:label "Load" ;
  rdfs:subClassOf sp:Update ;
.
sp:Max
  a rdfs:Class ;
  rdfs:comment "Represents MAX aggregations." ;
  rdfs:label "MAX" ;
  rdfs:subClassOf sp:Aggregation ;
.
sp:Min
  a rdfs:Class ;
  rdfs:comment "Represents MIN aggregations." ;
  rdfs:label "MIN" ;
  rdfs:subClassOf sp:Aggregation ;
.
sp:Minus
  a rdfs:Class ;
  rdfs:comment "A MINUS element group." ;
  rdfs:label "Minus" ;
  rdfs:subClassOf sp:ElementGroup ;
.
sp:ModPath
  a rdfs:Class ;
  rdfs:comment "A modified path such as rdfs:subClassOf*." ;
  rdfs:label "Mod path" ;
  rdfs:subClassOf sp:Path ;
.
sp:Modify
  a rdfs:Class ;
  rdfs:comment "Represents a MODIFY (part of SPARQL UPDATE language). The graph IRIs are stored in sp:graphIRI. The template patterns are stored in sp:deletePattern and sp:insertPattern. The WHERE clause is represented using sp:where." ;
  rdfs:label "Modify" ;
  rdfs:subClassOf sp:Update ;
  rdfs:subClassOf spin:Rule ;
.
sp:NamedGraph
  a rdfs:Class ;
  rdfs:comment "A named Graph element such as GRAPH <uri> {...}." ;
  rdfs:label "Named graph" ;
  rdfs:subClassOf sp:ElementGroup ;
.
sp:NotExists
  a rdfs:Class ;
  rdfs:comment "A NOT EXISTS element group." ;
  rdfs:label "Not exists" ;
  rdfs:subClassOf sp:ElementGroup ;
.
sp:Optional
  a rdfs:Class ;
  rdfs:comment "An optional element in a query." ;
  rdfs:label "Optional" ;
  rdfs:subClassOf sp:ElementGroup ;
.
sp:OrderByCondition
  a rdfs:Class ;
  rdfs:comment "An abstract base class for ascending or descending order conditions. Instances of this class (typically bnodes) must have a value for expression to point to the actual values." ;
  rdfs:label "Order by condition" ;
  rdfs:subClassOf sp:SystemClass ;
.
sp:Path
  a rdfs:Class ;
  rdfs:comment "The base class of SPARQL property path expressions. Paths are used by sp:TriplePath triple paths." ;
  rdfs:label "Path" ;
  rdfs:subClassOf sp:SystemClass ;
.
sp:Query
  a rdfs:Class ;
  rdfs:comment "Abstract base class of the various types of supported queries. Common to all types of queries is that they can have a body (\"WHERE clause\")." ;
  rdfs:label "Query" ;
  rdfs:subClassOf sp:Command ;
.
sp:ReverseLinkPath
  a rdfs:Class ;
  rdfs:label "Reverse link path" ;
  rdfs:subClassOf sp:Path ;
.
sp:ReversePath
  a rdfs:Class ;
  rdfs:comment "A path with reversed direction." ;
  rdfs:label "Reverse path" ;
  rdfs:subClassOf sp:Path ;
.
sp:Sample
  a rdfs:Class ;
  rdfs:comment "Represents SAMPLE aggregations" ;
  rdfs:label "SAMPLE" ;
  rdfs:subClassOf sp:Aggregation ;
.
sp:Select
  a rdfs:Class ;
  rdfs:comment "A SELECT-type query that returns variable bindings as its result." ;
  rdfs:label "Select query" ;
  rdfs:subClassOf sp:Query ;
.
sp:SeqPath
  a rdfs:Class ;
  rdfs:comment "A sequence of multiple paths." ;
  rdfs:label "Seq path" ;
  rdfs:subClassOf sp:Path ;
.
sp:Service
  a rdfs:Class ;
  rdfs:comment "A SERVICE call that matches a nested sub-pattern against a SPARQL end point specified by a URI." ;
  rdfs:label "Service" ;
  rdfs:subClassOf sp:ElementGroup ;
.
sp:SubQuery
  a rdfs:Class ;
  rdfs:comment "A nested SELECT query inside of an element list. The query is stored in sp:query." ;
  rdfs:label "Sub query" ;
  rdfs:subClassOf sp:Element ;
.
sp:Sum
  a rdfs:Class ;
  rdfs:comment "Represents sum aggregations, e.g. SELECT SUM(?varName)..." ;
  rdfs:label "SUM" ;
  rdfs:subClassOf sp:Aggregation ;
.
sp:SystemClass
  a rdfs:Class ;
  rdfs:comment "An \"artificial\" root class that groups all SP classes. This makes them look much less overwhelming in UI tools. Typical end users don't need to see those classes anyway." ;
  rdfs:label "SP System class" ;
  rdfs:subClassOf rdfs:Resource ;
.
sp:Triple
  a rdfs:Class ;
  rdfs:comment "A base class for TriplePattern and TripleTemplate. This basically specifies that subject, predicate and object must be present." ;
  rdfs:label "Triple" ;
  rdfs:subClassOf sp:Tuple ;
.
sp:TriplePath
  a rdfs:Class ;
  rdfs:comment "Similar to a TriplePattern, but with a path expression as its predicate. For example, this can be used to express transitive sub-class relationships (?subClass rdfs:subClassOf* ?superClass)." ;
  rdfs:label "Triple path" ;
  rdfs:subClassOf sp:Element ;
  rdfs:subClassOf sp:Tuple ;
.
sp:TriplePattern
  a rdfs:Class ;
  rdfs:comment "A triple pattern used in the body of a query." ;
  rdfs:label "Triple pattern" ;
  rdfs:subClassOf sp:Element ;
  rdfs:subClassOf sp:Triple ;
.
sp:TripleTemplate
  a rdfs:Class ;
  rdfs:comment "A prototypical triple used as template in the head of a Construct query. May contain variables." ;
  rdfs:label "Triple template" ;
  rdfs:subClassOf sp:Triple ;
.
sp:Tuple
  a rdfs:Class ;
  rdfs:comment "Abstract base class for things that have subject and object." ;
  rdfs:label "Tuple" ;
  rdfs:subClassOf sp:SystemClass ;
.
sp:UUID
  a spin:Function ;
  spin:returnType rdfs:Resource ;
  spin:symbol "UUID" ;
  rdfs:comment "Returns a fresh IRI from the UUID URN scheme. Each call of UUID() returns a different UUID. It must not be the \"nil\" UUID (all zeroes). The variant and version of the UUID is implementation dependent." ;
  rdfs:label "UUID" ;
  rdfs:subClassOf spl:URIFunctions ;
.
sp:Union
  a rdfs:Class ;
  rdfs:comment "A UNION group." ;
  rdfs:label "Union" ;
  rdfs:subClassOf sp:ElementGroup ;
.
sp:Update
  a rdfs:Class ;
  rdfs:comment "Abstract base class to group the various SPARQL UPDATE commands." ;
  rdfs:label "Update" ;
  rdfs:subClassOf sp:Command ;
.
sp:Values
  a rdfs:Class ;
  rdfs:comment "A VALUES element. sp:varNames points to an rdf:List of strings for the variables, sp:values to an rdf:List of rdf:Lists with nodes for each variable, in the order defined by the variables list." ;
  rdfs:label "Values" ;
  rdfs:subClassOf sp:Element ;
.
sp:Variable
  a rdfs:Class ;
  rdfs:comment "A variable mentioned in a Triple or expression. Variables are often blank nodes with the variable name stored in ts:name. Variables can also be supplied with a URI in which case the system will attempt to reuse the same variable instance across multiple query definitions." ;
  rdfs:label "Variable" ;
  rdfs:subClassOf sp:SystemClass ;
.
sp:_defaultValue
  a sp:Variable ;
  sp:varName "defaultValue" ;
.
sp:_predicate
  a sp:Variable ;
  sp:varName "predicate" ;
.
sp:_restriction
  a sp:Variable ;
  sp:varName "restriction" ;
.
sp:_type
  a sp:Variable ;
  sp:varName "type" ;
.
sp:_uri
  a sp:Variable ;
  sp:varName "uri" ;
.
sp:abs
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value." ;
    ] ;
  spin:symbol "abs" ;
  rdfs:comment "Returns the absolute value of arg. An error is raised if arg is not a numeric value." ;
  rdfs:label "abs" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-abs> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:add
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the first number" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the second number" ;
    ] ;
  spin:symbol "+" ;
  rdfs:comment "Returns the arithmetic sum of its operands." ;
  rdfs:label "add" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:all
  a rdf:Property ;
  rdfs:comment "Used in DROP and CLEAR." ;
  rdfs:label "all" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:and
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the first operand of the intersection" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the second operand of the intersection" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "&&" ;
  rdfs:comment "Return the logical AND between two (boolean) operands." ;
  rdfs:label "and" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:arg
  a rdf:Property ;
  rdfs:comment "Abstract superproperty for the enumerated arg1, arg2 etc." ;
  rdfs:label "arg" ;
.
sp:arg1
  a rdf:Property ;
  rdfs:comment "The first argument of a function call." ;
  rdfs:label "arg1" ;
  rdfs:subPropertyOf sp:arg ;
.
sp:arg2
  a rdf:Property ;
  rdfs:comment "The second argument of a function call." ;
  rdfs:label "arg2" ;
  rdfs:subPropertyOf sp:arg ;
.
sp:arg3
  a rdf:Property ;
  rdfs:comment "The third argument of a function call." ;
  rdfs:label "arg3" ;
  rdfs:subPropertyOf sp:arg ;
.
sp:arg4
  a rdf:Property ;
  rdfs:comment "The forth argument of a function call." ;
  rdfs:label "arg4" ;
  rdfs:subPropertyOf sp:arg ;
.
sp:arg5
  a rdf:Property ;
  rdfs:comment "The fifth argument of a function call. Further arguments are not common in SPARQL, therefore no sp:arg6, etc are defined here. However, they can be created if needed." ;
  rdfs:label "arg5" ;
  rdfs:subPropertyOf sp:arg ;
.
sp:arg6
  a rdf:Property ;
  rdfs:comment "The sixth argument of a function call." ;
  rdfs:label "arg6" ;
  rdfs:subPropertyOf sp:arg ;
.
sp:as
  a rdf:Property ;
  rdfs:comment "Points to a Variable used in an AS statement such as COUNT aggregates." ;
  rdfs:label "as" ;
  rdfs:range sp:Variable ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:bindings
  a rdf:Property ;
  rdfs:comment "The actual bindings of a sp:Values element." ;
  rdfs:domain sp:Values ;
  rdfs:label "bindings" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:bnode
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg1 ;
      rdfs:comment "A literal input node." ;
    ] ;
  spin:symbol "BNODE" ;
  rdfs:comment "Constructs a blank node that is distinct from all blank nodes in the dataset being queried and distinct from all blank nodes created by calls to this constructor for other query solutions. If the no argument form is used, every call results in a distinct blank node. If the form with a simple literal is used, every call results in distinct blank nodes for different simple literals, and the same blank node for calls with the same simple literal within expressions for one solution mapping. This functionality is compatible with the treatment of blank nodes in SPARQL CONSTRUCT templates." ;
  rdfs:label "bnode" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-bnode> ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:bound
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the variable or expression that is checked" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "bound" ;
  rdfs:comment "Returns true if ?arg1 is bound to a value. Returns false otherwise. Variables with the value NaN or INF are considered bound." ;
  rdfs:label "bound" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:ceil
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The number to get the ceiling of." ;
    ] ;
  spin:symbol "ceil" ;
  rdfs:comment "Returns the smallest (closest to negative infinity) number with no fractional part that is not less than the value of arg. An error is raised if ?arg1 is not a numeric value." ;
  rdfs:label "ceil" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-ceil> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:coalesce
  a spin:Function ;
  spin:symbol "COALESCE" ;
  rdfs:comment "Takes any number of arguments, and returns the first bound argument, starting at the left." ;
  rdfs:label "COALESCE" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:concat
  a spin:Function ;
  spin:returnType xsd:string ;
  spin:symbol "CONCAT" ;
  rdfs:comment "The CONCAT built-in function. Creates a single string by concatenating all arguments from left to right. Note that if any one of the arguments is unbound (null) then the whole result string will be unbound." ;
  rdfs:label "concat" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:contains
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The sub-string to search for in the input string." ;
    ] ;
  spin:symbol "CONTAINS" ;
  rdfs:comment "Returns an xsd:boolean indicating whether or not the value of ?arg1 contains (at the beginning, at the end, or anywhere within) at least one sequence of collation units that provides a minimal match to the collation units in the value of ?arg2, according to the collation that is used." ;
  rdfs:label "contains" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-contains> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:datatype
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the literal to get the datatype of" ;
    ] ;
  spin:returnType rdfs:Class ;
  spin:symbol "datatype" ;
  rdfs:comment "Returns the datatype IRI of argument ?arg1; returns xsd:string if the parameter is a simple literal." ;
  rdfs:label "datatype" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:day
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The date or dateTime argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "day" ;
  rdfs:comment "Extracts the day from a date/time literal." ;
  rdfs:label "day" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:default
  a rdf:Property ;
  rdfs:comment "Used in DROP and CLEAR." ;
  rdfs:label "default" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:deletePattern
  a rdf:Property ;
  rdfs:comment "Points to a list of sp:TripleTemplates and sp:NamedGraphs in a modify operation." ;
  rdfs:domain sp:Update ;
  rdfs:label "delete pattern" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:distinct
  a rdf:Property ;
  rdfs:comment "A marker property to indicate that a Select query is of type SELECT DISTINCT." ;
  rdfs:domain sp:Select ;
  rdfs:label "distinct" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:divide
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType rdfs:Literal ;
  spin:symbol "/" ;
  rdfs:comment "Returns the arithmetic quotient of its operands." ;
  rdfs:label "divide" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:document
  a rdf:Property ;
  rdfs:comment "The URI of the document to load using a LOAD Update operation." ;
  rdfs:domain sp:Load ;
  rdfs:label "document" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:elements
  a rdf:Property ;
  rdfs:comment "Points to an ElementList, for example in an Optional element." ;
  rdfs:label "elements" ;
  rdfs:range sp:ElementList ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:encode_for_uri
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to convert." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "ENCODE_FOR_URI" ;
  rdfs:label "encode_for_uri" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:eq
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the first value to compare" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the second value to compare" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "=" ;
  rdfs:comment "Returns true if both arguments are equal." ;
  rdfs:label "eq" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:exists
  a spin:Function ;
  spin:returnType xsd:boolean ;
  spin:symbol "EXISTS" ;
  rdfs:comment "The filter function EXISTS. The graph pattern is stored in sp:elements." ;
  rdfs:label "EXISTS" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:expression
  a rdf:Property ;
  rdfs:comment "Points to an expression, for example in a Filter or Assignment." ;
  rdfs:label "expression" ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:floor
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The value to get the floor of." ;
    ] ;
  spin:symbol "floor" ;
  rdfs:comment "Returns the largest (closest to positive infinity) number with no fractional part that is not greater than the value of ?arg1. An error is raised if ?arg1 is not a numeric value." ;
  rdfs:label "floor" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-floor> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:from
  a rdf:Property ;
  rdfs:comment "Specifies an RDF Dataset used by a Query (FROM syntax in SPARQL). Values of this property must be URI resources." ;
  rdfs:domain sp:Query ;
  rdfs:label "from" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:fromNamed
  a rdf:Property ;
  rdfs:comment "Specifies a named RDF Dataset used by a Query (FROM NAMED syntax in SPARQL). Values of this property must be URI resources." ;
  rdfs:domain sp:Query ;
  rdfs:label "from named" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:ge
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol ">=" ;
  rdfs:comment "Returns true if ?arg1 >= ?arg2." ;
  rdfs:label "ge" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:graphIRI
  a rdf:Property ;
  rdfs:comment "Points to graph names (IRIs) in various sp:Update operations." ;
  rdfs:label "graph IRI" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:graphNameNode
  a rdf:Property ;
  rdfs:comment "The name (URI or Variable) of a NamedGraph." ;
  rdfs:domain sp:NamedGraph ;
  rdfs:label "graph name node" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:groupBy
  a rdf:Property ;
  rdfs:comment "Points from a Query to the list of GROUP BY expressions." ;
  rdfs:domain sp:Select ;
  rdfs:label "group by" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:gt
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol ">" ;
  rdfs:comment "Returns true if ?arg1 > arg2." ;
  rdfs:label "gt" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:having
  a rdf:Property ;
  rdfs:comment "Points from a SELECT query to a list of HAVING expressions." ;
  rdfs:domain sp:Select ;
  rdfs:label "having" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:hours
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The dateTime or time argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "hours" ;
  rdfs:comment "Extracts the hours from a date/time literal." ;
  rdfs:label "hours" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:if
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "A condition to evaluate - if true then the ?arg2 will be returned, otherwise ?arg3." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The function result if ?arg1 is true." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The function result if ?arg1 is false." ;
    ] ;
  spin:symbol "IF" ;
  rdfs:comment "The SPARQL 1.1 built-in function IF." ;
  rdfs:label "IF" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:in
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The value to find." ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "IN" ;
  rdfs:comment "Checks whether the value on the left (?arg1) is one of the values on the right (?arg2, ?arg3 ...)." ;
  rdfs:label "IN" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:insertPattern
  a rdf:Property ;
  rdfs:comment "Points to a list of sp:TripleTemplates or sp:NamedGraphs in a modify command." ;
  rdfs:domain sp:Modify ;
  rdfs:label "insert pattern" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:into
  a rdf:Property ;
  rdfs:comment "The (optional) target of a LOAD Update operation." ;
  rdfs:domain sp:Load ;
  rdfs:label "into" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:iri
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The IRI string to convert to a resource." ;
    ] ;
  spin:returnType rdfs:Resource ;
  spin:symbol "IRI" ;
  rdfs:comment "Creates a IRI resource (node) from a given IRI string (?arg1)." ;
  rdfs:label "IRI" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:isBlank
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node being checked" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "isBlank" ;
  rdfs:comment "Checks whether a given node is a blank node." ;
  rdfs:label "isBlank" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:isIRI
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node being tested" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "isIRI" ;
  rdfs:comment "Checks whether a given node is a IRI node." ;
  rdfs:label "isIRI" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:isLiteral
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node being tested" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "isLiteral" ;
  rdfs:comment "Checks whether a given node is a literal." ;
  rdfs:label "isLiteral" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:isNumeric
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment """The node to check whether it's numeric.
""" ;
    ] ;
  spin:symbol "isNumeric" ;
  rdfs:comment "Returns true if arg1 is a numeric value. Returns false otherwise. term is numeric if it has an appropriate datatype (see the section Operand Data Types) and has a valid lexical form, making it a valid argument to functions and operators taking numeric arguments." ;
  rdfs:label "is numeric" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-isNumeric> ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:isURI
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node to check" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "isURI" ;
  rdfs:comment "Checks whether a node is a URI." ;
  rdfs:label "isURI" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:lang
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the literal to get the language of" ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "lang" ;
  rdfs:comment "Returns the language tag of ?arg1, if it has one. It returns \"\" if the literal has no language tag. Node that the RDF data model does not include literals with an empty language tag." ;
  rdfs:label "lang" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:langMatches
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the literal that is expected to have ?arg2 as language tag" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the language tag that ?arg1 must have" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "langMatches" ;
  rdfs:comment "Returns true if language-tag (first argument) matches language-range (second argument) per the basic filtering scheme defined in [RFC4647] section 3.3.1." ;
  rdfs:label "langMatches" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:lcase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "LCASE" ;
  rdfs:comment "Converts a string to lower case characters." ;
  rdfs:label "LCASE" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-lcase> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:le
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "<=" ;
  rdfs:comment "Returns true if ?arg1 <= ?arg2." ;
  rdfs:label "le" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:limit
  a rdf:Property ;
  rdfs:comment "The LIMIT solution modifier of a Query." ;
  rdfs:domain sp:Query ;
  rdfs:label "limit" ;
  rdfs:range xsd:long ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:lt
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "<" ;
  rdfs:comment "Returns true if ?arg1 < ?arg2." ;
  rdfs:label "lt" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:md5
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "MD5" ;
  rdfs:comment "Returns the MD5 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "md5" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-md5> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:minutes
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The dateTime or time argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "minutes" ;
  rdfs:comment "Extracts the minutes from a date/time literal." ;
  rdfs:label "minutes" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:modMax
  a rdf:Property ;
  rdfs:domain sp:ModPath ;
  rdfs:label "mod max" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:modMin
  a rdf:Property ;
  rdfs:domain sp:ModPath ;
  rdfs:label "mod min" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:month
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The date or dateTime argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "month" ;
  rdfs:comment "Extracts the month from a date/time literal." ;
  rdfs:label "month" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:mul
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:symbol "*" ;
  rdfs:comment "Returns the arithmetic product of its operands." ;
  rdfs:label "mul" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:named
  a rdf:Property ;
  rdfs:comment "Used in DROP and CLEAR." ;
  rdfs:label "named" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:ne
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "!=" ;
  rdfs:comment "Returns true if ?arg1 != ?arg2." ;
  rdfs:label "ne" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:node
  a rdf:Property ;
  rdfs:domain sp:ReverseLinkPath ;
  rdfs:label "node" ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:not
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the operand to negate" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "!" ;
  rdfs:comment "Returns the boolean negation of the argument." ;
  rdfs:label "not" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:notExists
  a spin:Function ;
  spin:returnType xsd:boolean ;
  spin:symbol "NOT EXISTS" ;
  rdfs:comment "The filter function NOT EXISTS. The graph pattern is stored in sp:elements." ;
  rdfs:label "NOT EXISTS" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:notIn
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The value to find." ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "NOT IN" ;
  rdfs:comment "Checks whether the value on the left (?arg1) is none of the values on the right (?arg2, ?arg3 ...)." ;
  rdfs:label "NOT IN" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:now
  a spin:Function ;
  spin:returnType xsd:dateTime ;
  spin:symbol "now" ;
  rdfs:comment "Gets the current date and time as an xsd:dateTime literal." ;
  rdfs:label "now" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:object
  a rdf:Property ;
  rdfs:comment "An RDF Node or Variable describing the object of a triple." ;
  rdfs:domain sp:Tuple ;
  rdfs:label "object" ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:offset
  a rdf:Property ;
  rdfs:comment "The OFFSET solution modifier of a Query." ;
  rdfs:domain sp:Query ;
  rdfs:label "offset" ;
  rdfs:range xsd:long ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:or
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "||" ;
  rdfs:comment "Returns the logical OR between two (boolean) operands." ;
  rdfs:label "or" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:orderBy
  a rdf:Property ;
  rdfs:comment "Links a query with an ORDER BY clause where the values are rdf:List containing OrderByConditions or expressions. While the domain of this property is sp:Query, only Describe and Select queries can have values of it." ;
  rdfs:domain sp:Query ;
  rdfs:label "order by" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:path
  a rdf:Property ;
  rdfs:comment "Points from a TriplePath to its path." ;
  rdfs:domain sp:TriplePath ;
  rdfs:label "path" ;
  rdfs:range sp:Path ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:path1
  a rdf:Property ;
  rdfs:comment "The first child path of a property path. Used by sp:AltPath and sp:SeqPath." ;
  rdfs:label "path1" ;
  rdfs:range sp:Path ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:path2
  a rdf:Property ;
  rdfs:comment "The second child path of a property path. Used by sp:AltPath and sp:SeqPath." ;
  rdfs:label "path2" ;
  rdfs:range sp:Path ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:predicate
  a rdf:Property ;
  rdfs:comment "A resource or Variable describing the predicate of a triple." ;
  rdfs:domain sp:Triple ;
  rdfs:label "predicate" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:query
  a rdf:Property ;
  rdfs:comment "Links a SubQuery resource with the nested Query." ;
  rdfs:domain sp:SubQuery ;
  rdfs:label "query" ;
  rdfs:range sp:Query ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:rand
  a spin:Function ;
  spin:returnType xsd:double ;
  spin:symbol "RAND" ;
  rdfs:comment "Returns a number between 0 (inclusive) and 1.0e0 (exclusive). Different numbers can be produced every time this function is invoked. Numbers should be produced with approximately equal probability." ;
  rdfs:label "rand" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#idp3722352> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:reduced
  a rdf:Property ;
  rdfs:comment "A property with true to indicate that a Select query has a REDUCED flag." ;
  rdfs:domain sp:Select ;
  rdfs:label "reduced" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:regex
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "the flags" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the match pattern" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "regex" ;
  rdfs:comment "Returns true if a string (?arg1) matches the regular expression supplied as a pattern (?arg2) as influenced by the value of flags (?arg3), otherwise returns false." ;
  rdfs:label "regex" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-regex> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:replace
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:string ;
      rdfs:comment "Additional flags for the replacement." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment """The pattern to replace.
""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "The replacement string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "REPLACE" ;
  rdfs:comment "Replaces each non-overlapping occurrence of a regular expression pattern with a replacement string. Regular expession matching may involve modifier flags." ;
  rdfs:label "replace" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-replace> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:resultNodes
  a rdf:Property ;
  rdfs:comment "Contains the result nodes (URI resources or Variables) of a Describe query." ;
  rdfs:domain sp:Describe ;
  rdfs:label "result nodes" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:resultVariables
  a rdf:Property ;
  rdfs:comment "An rdf:List of variables that are returned by a Select query." ;
  rdfs:domain sp:Select ;
  rdfs:label "result variables" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:round
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The number to round." ;
    ] ;
  spin:symbol "round" ;
  rdfs:comment "Returns the number with no fractional part that is closest to the argument. If there are two such numbers, then the one that is closest to positive infinity is returned. An error is raised if ?arg1 is not a numeric value." ;
  rdfs:label "round" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-round> ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:sameTerm
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the first argument" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "the second argument" ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "sameTerm" ;
  rdfs:comment "Returns TRUE if ?arg1 and ?arg2 are the same RDF term as defined in Resource Description Framework (RDF): Concepts and Abstract Syntax; returns FALSE otherwise." ;
  rdfs:label "same term" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sameTerm> ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
sp:seconds
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The dateTime or time argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "seconds" ;
  rdfs:comment "Extracts the seconds from a date/time literal." ;
  rdfs:label "seconds" ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:separator
  a rdf:Property ;
  rdfs:comment "Stores the separator=\"...\" value of a GROUP_CONCAT (sp:GroupConcat) aggregation." ;
  rdfs:domain sp:GroupConcat ;
  rdfs:label "separator" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:serviceURI
  a rdf:Property ;
  rdfs:comment "Used by sp:Service to specify the URI of the SPARQL end point to invoke. Must point to a URI node." ;
  rdfs:domain sp:Service ;
  rdfs:label "service URI" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:sha1
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SHA1" ;
  rdfs:comment "Returns the SHA1 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "sha1" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sha1> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:sha256
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SHA256" ;
  rdfs:comment "Returns the SHA256 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "sha256" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sha256> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:sha384
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SHA384" ;
  rdfs:comment "Returns the SHA384 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "sha384" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sha384> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:sha512
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input literal." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SHA512" ;
  rdfs:comment "Returns the SHA512 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the xsd:string. Hex digits SHOULD be in lower case." ;
  rdfs:label "sha512" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-sha512> ;
  rdfs:subClassOf spl:MiscFunctions ;
.
sp:silent
  a rdf:Property ;
  rdfs:label "silent" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:source
  a rdf:Property ;
  rdfs:label "source" ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:str
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node to convert to string" ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "str" ;
  rdfs:comment "Returns the lexical form of ?arg1 (a literal); returns the codepoint representation of ?arg1 (an IRI). This is useful for examining parts of an IRI, for instance, the host-name." ;
  rdfs:label "str" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strafter
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The pattern to find within the input string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "STRAFTER" ;
  rdfs:comment "Returns a literal of the same kind (simple literal, plain literal same language tag, xsd:string) as the first argument arg1. The lexical form of the result is the substring of the value of arg1 that proceeds in arg1 the first occurrence of the lexical form of arg2; otherwise the lexical form of the result is the empty string. If the lexical form of arg2 is the empty string, the lexical form of the result is the emprty string." ;
  rdfs:label "strafter" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strafter> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strbefore
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The pattern to find within the input string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "STRBEFORE" ;
  rdfs:comment "Returns a literal of the same kind (simple literal, plain literal same language tag, xsd:string) as the first argument arg1. The lexical form of the result is the substring of the value of arg1 that precedes in arg1 the first occurrence of the lexical form of arg2; otherwise the lexical form of the result is the empty string. If the lexical form of arg2 is the empty string, the lexical form of the result is the emprty string." ;
  rdfs:label "strbefore" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strbefore> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strdt
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The lexical form of the new literal." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The datatype of the new literal." ;
    ] ;
  spin:symbol "STRDT" ;
  rdfs:comment "Constructs a literal with lexical form and type as specified by the arguments." ;
  rdfs:label "strdt" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strdt> ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:strends
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The sub-string that the input string is supposed to end with." ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "STRENDS" ;
  rdfs:comment "Returns true if the lexical form of ?arg1 ends with the lexical form of ?arg2, otherwise it returns false." ;
  rdfs:label "strends" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-ends> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strlang
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The language tag, e.g. \"en-AU\"." ;
    ] ;
  spin:returnType rdf:langString ;
  spin:symbol "STRLANG" ;
  rdfs:comment "Takes a string (?arg1) and a language (?arg2) and constructs a literal with a corresponding language tag." ;
  rdfs:label "strlang" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strlang> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strlen
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "STRLEN" ;
  rdfs:comment "Computes the length of a given input string." ;
  rdfs:label "strlen" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-strlen> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:strstarts
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The sub-string that the input string is supposed to begin with." ;
    ] ;
  spin:returnType xsd:boolean ;
  spin:symbol "STRSTARTS" ;
  rdfs:comment "Returns true if the lexical form of ?arg1 begins with the lexical form of ?arg2, otherwise it returns false." ;
  rdfs:label "strstarts" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-starts> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:struuid
  a spin:Function ;
  spin:returnType xsd:string ;
  spin:symbol "STRUUID" ;
  rdfs:comment "Returns a string that is the scheme specific part of UUID. That is, as a simple literal, the result of generating a UUID, converting to a simple literal and removing the initial urn:uuid:." ;
  rdfs:label "struuid" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:sub
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the first operand" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the second operand" ;
    ] ;
  spin:symbol "-" ;
  rdfs:comment "Returns the arithmetic difference of its operands." ;
  rdfs:label "sub" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:subPath
  a rdf:Property ;
  rdfs:comment "The child path of a property path expression. This is used by ReversePath and ModPath." ;
  rdfs:label "sub path" ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:subject
  a rdf:Property ;
  rdfs:comment "A resource or Variable describing the subject of a triple." ;
  rdfs:domain sp:Tuple ;
  rdfs:label "subject" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:substr
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The end index." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The start index." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "SUBSTR" ;
  rdfs:comment "Gets the sub-string of a given string. The index of the first character is 1." ;
  rdfs:label "substr" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-substr> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:systemProperty
  a rdf:Property ;
  rdfs:comment "An abstract base proprerty that groups together the SP system properties. Users typically don't need to see them anyway." ;
  rdfs:label "SP system property" ;
.
sp:target
  a rdf:Property ;
  rdfs:label "target" ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:templates
  a rdf:Property ;
  rdfs:comment "Points to a list of TripleTemplates that form the head of a Construct query." ;
  rdfs:domain sp:Construct ;
  rdfs:label "templates" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:text
  a rdf:Property ;
  rdfs:comment "Can be attached to sp:Queries to store a textual representation of the query. This can be useful for tools that do not have a complete SPIN Syntax parser available." ;
  rdfs:label "text" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:timezone
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:dateTime ;
      rdfs:comment "The input time." ;
    ] ;
  spin:returnType xsd:duration ;
  spin:symbol "TIMEZONE" ;
  rdfs:comment "Returns the timezone part of ?arg1 as an xsd:dayTimeDuration. Raises an error if there is no timezone." ;
  rdfs:label "timezone" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-timezone> ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:tz
  a spin:Function ;
  spin:symbol "TZ" ;
  rdfs:comment "Returns the timezone part of ?arg1 as a simple literal. Returns the empty string if there is no timezone." ;
  rdfs:label "tz" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-tz> ;
  rdfs:subClassOf spl:DateFunctions ;
.
sp:ucase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:returnType xsd:string ;
  spin:symbol "UCASE" ;
  rdfs:comment "Converts a string to upper case characters." ;
  rdfs:label "UCASE" ;
  rdfs:seeAlso <http://www.w3.org/TR/sparql11-query/#func-ucase> ;
  rdfs:subClassOf spl:StringFunctions ;
.
sp:unaryMinus
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the operand" ;
    ] ;
  spin:symbol "-" ;
  rdfs:comment "Returns the operand ?arg1 with the sign reversed. If ?arg1 is positive, its negative is returned; if it is negative, its positive is returned." ;
  rdfs:label "unary minus" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:unaryPlus
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the operand" ;
    ] ;
  spin:symbol "+" ;
  rdfs:comment "Returns the operand ?arg1 with the sign unchanged. Semantically, this operation performs no operation." ;
  rdfs:label "unary plus" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
sp:uri
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The IRI string to convert to a resource." ;
    ] ;
  spin:returnType rdfs:Resource ;
  spin:symbol "URI" ;
  rdfs:comment "Equivalent to IRI." ;
  rdfs:label "URI" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
sp:using
  a rdf:Property ;
  rdfs:domain sp:Modify ;
  rdfs:label "using" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:usingNamed
  a rdf:Property ;
  rdfs:domain sp:Modify ;
  rdfs:label "using named" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:values
  a rdf:Property ;
  rdfs:comment "The VALUES block at the end of a query. The object may just be an untyped blank node, i.e. the sp:Values type triple is optional." ;
  rdfs:domain sp:Query ;
  rdfs:label "values" ;
  rdfs:range sp:Values ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:varName
  a rdf:Property ;
  rdfs:comment "The name of a Variable." ;
  rdfs:domain sp:Variable ;
  rdfs:label "varName" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:varNames
  a rdf:Property ;
  rdfs:comment "The names of the variables (xsd:strings) of the variables declared for a VALUES element." ;
  rdfs:domain sp:Values ;
  rdfs:label "var names" ;
  rdfs:range rdf:List ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:variable
  a rdf:Property ;
  rdfs:comment "The variable of a Bind element." ;
  rdfs:domain sp:Bind ;
  rdfs:label "variable" ;
  rdfs:range sp:Variable ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:where
  a rdf:Property ;
  rdfs:comment "The WHERE clause of a Query." ;
  rdfs:label "where" ;
  rdfs:range sp:ElementList ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:with
  a rdf:Property ;
  rdfs:domain sp:Modify ;
  rdfs:label "with" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf sp:systemProperty ;
.
sp:year
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The date or dateTime argument." ;
    ] ;
  spin:returnType xsd:integer ;
  spin:symbol "year" ;
  rdfs:comment "Extracts the year from a date/time literal." ;
  rdfs:label "year" ;
  rdfs:subClassOf spl:DateFunctions ;
.
<http://spinrdf.org/spif>
  a spin:LibraryOntology ;
  a owl:Ontology ;
  rdfs:comment "A library of \"generally useful\" SPARQL functions defined using SPIN. This library consists of functions that are impossible or difficult to express in terms of other functions, but rather will require a native implementation in languages like Java. In contrast, the SPL (http://spinrdf.org/spl#) namespace is reserved for functions that can be expressed entirely in terms of other SPARQL expressions and standard built-ins." ;
  owl:imports <http://spinrdf.org/spin> ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:versionInfo "0.5.0" ;
.
spif:Test-dateFormat-1
  a spl:TestCase ;
  spl:testExpression [
      a spif:dateFormat ;
      arg:date "2008-02-13"^^xsd:date ;
      arg:pattern "MMMMMMMMM dd, yyyy" ;
    ] ;
  spl:testResult "February 13, 2008" ;
  rdfs:label "Test-date format" ;
.
spif:Test-dateFormat-2
  a spl:TestCase ;
  spl:testExpression [
      a spif:dateFormat ;
      arg:date "01:02:03"^^xsd:time ;
      arg:pattern "hh::mm" ;
    ] ;
  spl:testResult "01::02" ;
  rdfs:label "Test-date format-2" ;
.
spif:Test-decimalFormat-1
  a spl:TestCase ;
  spl:testExpression [
      a spif:decimalFormat ;
      arg:number 12.3456 ;
      arg:pattern "#.##" ;
    ] ;
  spl:testResult "12.35" ;
  rdfs:label "Test-decimal format-1" ;
.
spif:Test-generateLabel-1
  a spl:TestCase ;
  spl:testExpression [
      a spif:generateLabel ;
      sp:arg1 <http://example.org/test#LocalName> ;
    ] ;
  spl:testResult "Local name" ;
  rdfs:label "Test-generate label-1" ;
.
spif:Test-generateLabel-2
  a spl:TestCase ;
  spl:testExpression [
      a spif:generateLabel ;
      sp:arg1 <http://example.org/test/123> ;
    ] ;
  spl:testResult "123" ;
  rdfs:label "Test-generate label-2" ;
.
spif:Test-localName-1
  a spl:TestCase ;
  spl:testExpression [
      a spif:localName ;
      sp:arg1 <http://example.org/test#Aldi> ;
    ] ;
  spl:testResult "Aldi" ;
  rdfs:label "Test-local name-1" ;
.
spif:Test-localName-2
  a spl:TestCase ;
  spl:testExpression [
      a spif:localName ;
      sp:arg1 <http://example.org/test/.123> ;
    ] ;
  spl:testResult ".123" ;
  rdfs:label "Test-local name-2" ;
.
spif:Test-mod-1
  a spl:TestCase ;
  spl:testExpression [
      a spif:mod ;
      sp:arg1 3 ;
      sp:arg2 2 ;
    ] ;
  spl:testResult 1 ;
  rdfs:label "Test-mod-1" ;
.
spif:Test-parseDate-MMMMMMMMM_dd__yyyy
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "MMMMMMMMM dd, yyyy" ;
      sp:arg1 "February 13, 2008" ;
    ] ;
  spl:testResult "2008-02-13"^^xsd:date ;
.
spif:Test-parseDate-MMMMMMMMM_dd_yyyy
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "MMMMMMMMM dd yyyy" ;
      sp:arg1 "February 13 2008" ;
    ] ;
  spl:testResult "2008-02-13"^^xsd:date ;
.
spif:Test-parseDate-MM_dd_yyyy
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "MM/dd/yyyy" ;
      sp:arg1 "2/13/2008" ;
    ] ;
  spl:testResult "2008-02-13"^^xsd:date ;
.
<http://spinrdf.org/spif#Test-parseDate-dd.MM.yyyy>
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "dd.MM.yyyy" ;
      sp:arg1 "13.02.2008" ;
    ] ;
  spl:testResult "2008-02-13"^^xsd:date ;
.
spif:Test-parseDate-dd_MMMMMMMM__yyyy
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "dd MMMMMMMMM, yyyy" ;
      sp:arg1 "13 February, 2008" ;
    ] ;
  spl:testResult "2008-02-13"^^xsd:date ;
  rdfs:label "Test-parse date-dd MMMMMMMM  yyyy" ;
.
spif:Test-parseDate-dd_MMMMMMMM_yyyy
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "dd MMMMMMMMM yyyy" ;
      sp:arg1 "13 February 2008" ;
    ] ;
  spl:testResult "2008-02-13"^^xsd:date ;
  rdfs:label "Test-parse date-dd MMMMMMMM yyyy" ;
.
spif:Test-parseDate-dd_MM_yyyy
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "dd/MM/yyyy" ;
      sp:arg1 "13/2/2008" ;
    ] ;
  spl:testResult "2008-02-13"^^xsd:date ;
.
spif:Test-parseDate-hhmm
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "hhmm" ;
      sp:arg1 "1830" ;
    ] ;
  spl:testResult "18:30:00"^^xsd:time ;
.
spif:Test-parseDate-yyyyMMdd
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "yyyyMMdd" ;
      sp:arg1 "20080213" ;
    ] ;
  spl:testResult "2008-02-13"^^xsd:date ;
.
spif:Test-parseDate-yyyyMMddhhmm
  a spl:TestCase ;
  spl:testExpression [
      a spif:parseDate ;
      arg:pattern "yyyyMMddhhmm" ;
      sp:arg1 "200802131830" ;
    ] ;
  spl:testResult "2008-02-13T18:30:00"^^xsd:dateTime ;
.
spif:Test-unCamelCase-1
  a spl:TestCase ;
  spl:testExpression [
      a spif:unCamelCase ;
      sp:arg1 "SemanticWeb" ;
    ] ;
  spl:testResult "Semantic web" ;
.
spif:Test-unCamelCase-2
  a spl:TestCase ;
  spl:testExpression [
      a spif:unCamelCase ;
      sp:arg1 "semanTic_Web23" ;
    ] ;
  spl:testResult "seman tic Web23" ;
.
spif:buildString
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the template string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Constructs a new string by inserting the existing variable bindings into a template. The template can mention variable names in curly braces, such as \"Hello {?index}\" would create \"Hello 42\" is ?index has the value 42. As an alternative to variable names, the function can take additional arguments after the template, the variables of which can be accessed using {?1}, {?2} etc. For example: smf:buildString(\"Hello-{?1}-{?2}\", ?day, ?month) would insert day and month at places {?1} and {?2}." ;
  rdfs:label "build string" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:buildStringFromRDFList
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "the separator to insert between each string" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:List ;
      rdfs:comment "the head of the rdf:List to convert to string" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the template string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Builds a string from the members of a given rdf:List (?arg1). The function iterates over all members of the list (which must be well-formed according to the RDF syntax rules). For each member, a string template (?arg2) is applied where the expression {?member} will be substituted with the current member. Optionally, a separator (?arg3) can be inserted between the list members in the result string, e.g. to insert a comma." ;
  rdfs:label "build string from RDF list" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:buildURI
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI template such as \"<http://my.com/Instance-{?index}>\". If the template contains a full URI, then it must be wrapped by <...>, otherwise the system will treat it as a qname." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Constructs a new URI resource by inserting the existing variable bindings into a template. The template can mention variable names in curly braces, such as \"my:Instance-{?index}\" would create \"my:Instance-42\" is ?index has the value 42. As an alternative to variable names, the function can take additional arguments after the template, the variables of which can be accessed using {?1}, {?2} etc. For example: smf:buildURI(\"my:Instance-{?1}-{?2}\", ?day, ?month) would insert day and month at places {?1} and {?2}." ;
  rdfs:label "build URI" ;
  rdfs:subClassOf spl:URIFunctions ;
.
spif:buildUniqueURI
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI template such as \"<http://my.com/Instance-{?index}>\". If the template contains a full URI, then it must be wrapped by <...>, otherwise the system will treat it as a qname." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "A variation of smf:buildURI that also makes sure that the created URI is unique in the current graph (that is, no triple contains the URI as either subject, predicate or object). This function is particularly useful for ontology mapping from a legacy data source into an RDF model." ;
  rdfs:label "build unique URI" ;
  rdfs:subClassOf spl:URIFunctions ;
.
spif:camelCase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into camel case. 
For example, \"semantic web\" becomes \"SemanticWeb\".
An optional matching expression can be given to only convert the matched characters.""" ;
  rdfs:label "camel case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:canInvoke
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The first argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The second argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      rdfs:comment "The third argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg5 ;
      rdfs:comment "The forth argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spin:Function ;
      rdfs:comment "The function to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given SPIN function (?arg1) can be invoked with a given list of argument (?arg2, ?arg3, ...) without violating any of its declared SPIN constraints. In addition to the usual argument declarations, the SPIN function may declare ASK and CONSTRUCT queries to check additional pre-conditions." ;
  rdfs:label "can invoke" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:cast
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The target datatype, e.g. xsd:integer. Leave blank for untyped literals." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the \"old\" literal that shall be converted" ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Creates a new literal from an existing literal, but with a different datatype. This can, for example, be used to convert between floating point values and int values." ;
  rdfs:label "cast" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:checkRegexSyntax
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:regex ;
      spl:valueType xsd:string ;
      rdfs:comment "The potential regular expression to check." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a string and checks whether it would be a valid regular expression. Returns unbound if OK, or a string with an error message otherwise." ;
  rdfs:label "check regex syntax" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:convertSPINRDFToString
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "true to embed HTML markup into the output" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType sp:Query ;
      rdfs:comment "the root of the SPIN RDF query" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts a SPARQL query encoded in SPIN RDF format to a SPARQL string in textual form. The SPIN query must be well-formed in the context graph at execution time, and the provided argument must be the root of the expression (e.g., an instance of sp:Select).

This function is available as part of the TopBraid SPIN Libraries.""" ;
  rdfs:label "convert SPIN RDF to string" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:countMatches
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the subject in the match triple, or an unbound variable for a wildcard" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the predicate in the match triple, or an unbound variable for a wildcard" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "the object in the match triple, or an unbound variable for a wildcard" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment """Counts all occurrences of a triple pattern based on subject (?arg1), predicate (?arg2) and object (?arg3) input. Any of those can be unbound variables.

This function is available as part of the TopBraid SPIN Libraries.""" ;
  rdfs:label "count matches" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:countTransitiveSubjects
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to walk." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to start traversal at." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment """Given a predicate and an object, this function computes the number of matches using

SELECT (COUNT(DISTINCT ?subject) AS ?result)
WHERE {
	?subject ?predicate* ?object .
}

The main purpose of this function is to optimize performance - this direction of * traversal is currently very slow in Jena. The function can be used to compute the number of subclasses of a given class.""" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:currentTimeMillis
  a spin:Function ;
  spin:returnType xsd:long ;
  rdfs:comment "Returns the current time in milliseconds. See System.currentTimeMillis() in Java." ;
  rdfs:label "current time millis" ;
  rdfs:subClassOf spl:DateFunctions ;
.
spif:dateFormat
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:date ;
      rdfs:comment "An xsd:date, xsd:dateTime or xsd:time literal containing the date and time to render." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:pattern ;
      spl:valueType xsd:string ;
      rdfs:comment "The output pattern." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a date/time literal and a pattern and renders the date according to the pattern. This is a reverse of spif:parseDate and uses the same format." ;
  rdfs:label "date format" ;
  rdfs:subClassOf spl:DateFunctions ;
.
spif:decimalFormat
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:number ;
      spl:valueType xsd:decimal ;
      rdfs:comment "The number to format." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:pattern ;
      spl:valueType xsd:string ;
      rdfs:comment "The pattern, following the syntax defined for the Java DecimalFormat class (see: http://download.oracle.com/javase/6/docs/api/java/text/DecimalFormat.html)." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a number as its first argument and applies a given formatting string to it, for example, to convert a floating point into a number that has exactly two decimal places after the dot. For example, spif:decimalFormat(12.3456, \"#.##\") returns \"12.35\". The resulting string can then by cast back to a number, e.g. using xsd:double(?str)." ;
  rdfs:label "decimal format" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:decodeURL
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "UTF-8" ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) encoding. Defaults to UTF-8." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to decode." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Decodes a URL string - this is the inverse operation of spif:encodeURL." ;
  rdfs:label "decode URL" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:encodeURL
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "UTF-8" ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) encoding. Defaults to UTF-8." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to encode." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Encodes a URL string, for example so that it can be passed as an argument to REST services." ;
  rdfs:label "encode URL" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:evalPath
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The start node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The path expression, as a parsable string, or a IRI resource for a simple path consisting of a single property only." ;
    ] ;
  rdfs:comment "Takes a starting node (?arg1) and a SPARQL path expression (?arg2) and binds all matching results of the path evaluation. Also supports cases where the starting node is unbound, even both unbound." ;
  rdfs:label "eval path" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spif:for
  a spin:MagicProperty ;
  rdfs:comment """Can be used to iterate over a range of (integer) numbers similar to a for loop in iterative programming languages. An unbound variable must be placed on the left side of this magic property. On the right side, a list of two numbers needs to be placed.

For example, ?index spif:for (1 10) binds ?index to all xsd:integers >= 1 and <= 10.

By default it will add +1 to each step. It is possible to walk different steps and direction by specifying a third argument on the right, e.g. ?index spif:for (10 1 -1) will walk from 10 to 1 backwards.""" ;
  rdfs:label "for" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spif:foreach
  a spin:MagicProperty ;
  rdfs:comment """Can be used to \"iterate\" over a list of RDF nodes given as members of a list on the right. An unbound variable must be on the left side of the magic property. On the right side, a list of nodes with arbitrary length can be placed.

For example, ?subject spif:foreach (owl:Thing owl:Nothing) will bind ?subject to owl:Thing and then owl:Nothing.""" ;
  rdfs:label "for each" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spif:generateLabel
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "label" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spif:localName ;
                sp:arg1 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "localName" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:unCamelCase ;
                sp:arg1 [
                    sp:varName "localName" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to generate a label for." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Constructs a human-readable label for a URI resource by taking everything after the last '/' or the last '#' as starting point." ;
  rdfs:label "generate label" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:generateUUID
  a spin:Function ;
  spin:returnType xsd:string ;
  rdfs:comment "Generates a new unique ID as a string literal. This is often useful for creating \"random\" URIs and other identifiers." ;
  rdfs:label "generate UUID" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:graphExists
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph (IRI) to test." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given graph URI is known to the dataset. This also returns true for graphs that are empty." ;
  rdfs:label "graph exists" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:graphIsomorphicWith
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to compare the current query graph with." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the current query graph is isomorphic with a given named graph. This compares all triples in the graphs, matching equivalent blank node structures even if they have different internal identities." ;
  rdfs:label "graph isomorphic with" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:graphSize
  a spin:Function ;
  spin:returnType xsd:integer ;
  rdfs:comment "Counts the number of triples in the current query graph and returns that sum as an xsd:integer." ;
  rdfs:label "graph size" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:hasAllObjects
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the match subject" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the match predicate" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdf:List ;
      rdfs:comment "an rdf:List containing the match objects" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject/predicate combination has all values enumerated from a given rdf:List. In other words, for each member ?object of the rdf:List, the triple (?arg1, ?arg2, ?object) must be in the model to return true. If the list is empty, true will also be returned." ;
  rdfs:label "has all objects" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spif:indexOf
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The optional index to start with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the string to search in" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the sub string to search for" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the index of the first occurrence of a certain substring in a given search string. Returns an error if the substring is not found." ;
  rdfs:label "index of" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:invoke
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The first argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The second argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      rdfs:comment "The third argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg5 ;
      rdfs:comment "The forth argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spin:Function ;
      rdfs:comment "The URI resource defining the function to call." ;
    ] ;
  rdfs:comment """Calls another SPARQL function specified by a URI resource (?arg1), with any number of additional arguments to be passed into the function (?arg2, ?arg3, ...). The result of the function call will be returned as result of the invoke call. This can be used to dynamically call functions when their URI is not known statically.

The function can also be a binary built-in SPARQL function using the SPIN function identifiers from the SPL ontology. For example, sp:gt will be executed as ?left > ?right.""" ;
  rdfs:label "invoke" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:isReadOnlyTriple
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject of the triple to delete." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the triple to delete." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The object of the triple to delete." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given triple is read-only, that is, cannot be deleted. Triples that are in the system ontology are generally not deletable. TopBraid also enforces that on union graphs, all triples that are not from the base graph of the union are read-only. Other platforms may have different privilege rules for this function." ;
  rdfs:label "is read only triple" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spif:isValidForDatatype
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:data ;
      rdfs:comment "The data node." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The XSD datatype to test against." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the lexical form of a given data literal would be a valid value for a given datatype." ;
  rdfs:label "is valid for datatype" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:isValidLangTag
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given string is a valid language tag." ;
  rdfs:label "is valid lang tag" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:isValidURI
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to validate." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given input string is a well-formed absolute URI. This can be used to validate user input before it is turned into a URI resource." ;
  rdfs:label "is valid URI" ;
  rdfs:subClassOf spl:URIFunctions ;
.
spif:labelTemplateSegment
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spin:Template ;
      rdfs:comment "The template to get the label segments of." ;
    ] ;
  rdfs:comment "Takes a Template and splits its spin:labelTemplate into an iteration over string constants or properties. The properties align with the spl:predicates of the declared spl:Arguments of the template. Among others, this magic property can be used to render template calls into user interface components." ;
  rdfs:label "label template segment" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spif:lastIndexOf
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The optional index to start with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the string to search in" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the sub string to search for" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the index of the last occurrence of a certain substring in a given search string. Returns an error if the substring is not found." ;
  rdfs:label "last index of" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:localName
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "localName" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a xsd:string ;
                sp:arg1 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "uri" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:lastIndexOf ;
                sp:arg1 [
                    sp:varName "uri" ;
                  ] ;
                sp:arg2 "/" ;
              ] ;
            sp:variable [
                sp:varName "slash" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:lastIndexOf ;
                sp:arg1 [
                    sp:varName "uri" ;
                  ] ;
                sp:arg2 "#" ;
              ] ;
            sp:variable [
                sp:varName "hash" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:or ;
                    sp:arg1 [
                        a sp:not ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "hash" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:and ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "slash" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:gt ;
                            sp:arg1 [
                                sp:varName "slash" ;
                              ] ;
                            sp:arg2 [
                                sp:varName "hash" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    sp:varName "slash" ;
                  ] ;
                sp:arg3 [
                    sp:varName "hash" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "sep" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a fn:substring ;
                sp:arg1 [
                    sp:varName "uri" ;
                  ] ;
                sp:arg2 [
                    a sp:add ;
                    sp:arg1 [
                        sp:varName "sep" ;
                      ] ;
                    sp:arg2 2 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "localName" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI resource to get the local name of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets a \"local name\" from a URI resource. This takes everything after the last '/' or '#' character of the URI. This function is a more intuitive alternative to afn:localname, which strictly follows the W3C namespace splitting algorithm that often leads to surprising results." ;
  rdfs:label "local name" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:lowerCamelCase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into lower camel case.
For example, \"semantic web\" becomes \"semanticWeb\".
An optional matching expression can be given to only convert the matched characters.""" ;
  rdfs:label "lower camel case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:lowerCase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into lower case. 
For example, \"SEMANTIC Web\" becomes \"semantic web\".
An optional matching expression can be given to only convert the matched characters.""" ;
  rdfs:label "lower case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:lowerTitleCase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into lower title case. 
For example, \"semantic web\" becomes \"semantic Web\".
An optional matching expression can be given to only convert the matched characters.""" ;
  rdfs:label "lower title case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:mod
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The first operand." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The second argument." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "The mathematical modulo operator, aka % in Java." ;
  rdfs:label "mod" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
spif:name
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node (literal or resource) that shall be rendered into a string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets a human-readable string representation from an RDF node. If it's a literal, the function will return the literal's lexical text. If it's a resource the system will use the rdfs:label (if exists) or otherwise use the qname. For an unbound input, the function will return no value." ;
  rdfs:label "name" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:parseDate
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:patternLanguage ;
      spl:valueType xsd:string ;
      rdfs:comment "The code of the language (e.g. \"de\" for German) to use for parsing." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:pattern ;
      spl:valueType xsd:string ;
      rdfs:comment "The template of the input string. This must conform to the pattern language implemented by the Java SimpleDateFormat class (http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input text" ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Converts a string in a semi-structured format into a xsd:date, xsd:dateTime or xsd:time literal. The input string must be in a given template format, e.g. \"yyyy.MM.dd G 'at' HH:mm:ss z\" for strings such as 2001.07.04 AD at 12:08:56 PDT." ;
  rdfs:label "parse date" ;
  rdfs:subClassOf spl:DateFunctions ;
.
spif:prefix
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The namespace (string) or an unbound variable." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used to get namespaces and their prefixes. This magic property takes the namespace (string) or a variable on the left and a prefix or a variable on the right. If both are unbound variables, then it will iterate over all namespaces and their prefixes. Otherwise it will bind the namespace or prefix. If both are bound, the system checks whether the given prefix is for the given namespace." ;
  rdfs:label "prefix" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spif:random
  a spin:Function ;
  spin:returnType xsd:double ;
  rdfs:comment "Creates a random xsd:double between 0 and 1." ;
  rdfs:label "random" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
spif:referencedVar
  a spin:MagicProperty ;
  rdfs:comment "For a given SPIN RDF expression or command (left hand side) this magic property delivers all used variables (right hand side). The algorithm basically walks into all depending blank nodes from the root and returns all unique values of sp:varName." ;
  rdfs:label "referenced var" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spif:regex
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:string ;
      rdfs:comment "The optional string returned as result string if no match occurs. If this string is empty and no match occurs, then the result string is unbound." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "The replacement expression" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """An input string is converted into a result string by applying a match and replacement expressions.
For example, the input string \"semantic web\" with the match expression \"([A-z]+) ([A-z]+)\" and the replacement expression \"The $1 life\" returns the string \"The semantic life\".
An optional input string is returned, if no match occurs. If this string is empty and no match occurs, then the result string is unbound.""" ;
  rdfs:label "regex" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:replaceAll
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to operate on." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The regular expression to search for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "The replacement string." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Does a string replacement based on the Java function String.replaceAll()." ;
  rdfs:label "replace all" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:shortestObjectsPath
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The optional target resource (root of the tree). If not specified, then the first node that has no further objects will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to start with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to walk, e.g. rdfs:subClassOf or skos:broader." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Finds the shortest path from a given subject walking up a given predicate (for example, rdfs:subClassOf) and returns the path as a string of URIs separated with a space. This can be used to find the shortest path from a resource in a tree structure to the root resource." ;
  rdfs:label "shortest objects path" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:shortestSubjectsPath
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The optional target resource (root of the tree). If not specified, then the first node that has no further subjects will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The object to start with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to walk, e.g. schema:child." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Finds the shortest path from a given object walking up a given predicate (for example, schema:child) and returns the path as a string of URIs separated with a space. This can be used to find the shortest path from a resource in a tree structure to the root resource." ;
  rdfs:label "shortest subjects path" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spif:split
  a spin:MagicProperty ;
  rdfs:comment """Splits a given string and iterates over all sub-strings. An unbound variable must be placed on the left side of this magic property. A list with two members must be on the right. The first is the string to split, and the second is a regular expression.

For example, ?str spif:split (\"Hello World\" \" \") will bind ?str to \"Hello\" and \"World\".""" ;
  rdfs:label "split" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spif:timeMillis
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:dateTime ;
      rdfs:comment "The xsd:dateTime to convert." ;
    ] ;
  spin:returnType xsd:long ;
  rdfs:comment "Returns the time of a given xsd:dateTime value in milliseconds." ;
  rdfs:label "time millis" ;
  rdfs:subClassOf spl:DateFunctions ;
.
spif:timeMillisToDateTime
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:millis ;
      spl:valueType xsd:long ;
      rdfs:comment "The milliseconds to convert." ;
    ] ;
  rdfs:comment "Converts a given time milliseconds value (xsd:long or xsd:integer) into a corresponding xsd:dateTime literal." ;
  rdfs:label "time millis to date time" ;
  rdfs:subClassOf spl:DateFunctions ;
.
spif:titleCase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string to title case.
For example, \"germany\" becomes \"Germany\".
An optional matching expression can be given to only convert the matched characters.""" ;
  rdfs:label "title case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:toJavaIdentifier
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Produces a valid Java identifier based on a given input string, dropping any characters that would not be valid Java identifiers. Produces the empty string if no character can be reused from the given string. Note that this function is even stricter than the normal Java identifier algorithm, as it only allows ASCII characters or digits." ;
  rdfs:label "to Java identifier" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:trim
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the text to trim" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates a new string value by trimming an input string. Leading and trailing whitespaces are deleted." ;
  rdfs:label "trim" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:unCamelCase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Converts an input string into a reverse camel case." ;
  rdfs:label "un-camel case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:upperCase
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into upper case. 
For example, \"semantic web\" becomes \"SEMANTIC WEB\".
An optional matching expression can be given to only convert the matched characters.""" ;
  rdfs:label "upper case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
spif:walkObjects
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The start node of the traversal." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to walk up." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType spin:Function ;
      rdfs:comment "The SPIN/SPARQL function to execute for each node." ;
    ] ;
  rdfs:comment """Performs a depth-first tree traversal starting at a given node (?arg1) and then following the objects using a given predicate (?arg2). For each node it applies a given function (?arg3) that must take the current node as its first argument. All other arguments of the walkObjects function call will be passed into that function. The traversal stops on the first non-null result of the nested function calls.

As use case of this function is to walk up superclasses, e.g. to find the \"nearest\" owl:Restriction of a certain kind.""" ;
  rdfs:label "walk objects" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
<http://spinrdf.org/spin>
  a owl:Ontology ;
  rdfs:comment "An RDF Schema that can be used to attach constraints and rules to RDFS classes, and to encapsulate reusable SPARQL queries into functions and templates." ;
  rdfs:label "SPIN Modeling Vocabulary" ;
  owl:imports <http://spinrdf.org/sp> ;
  owl:versionInfo "1.4" ;
.
spin:
  tosh:systemNamespace true ;
.
spin:AskTemplate
  a rdfs:Class ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate spin:body ;
      spl:valueType sp:Ask ;
      rdfs:comment "The ASK query wrapped by this template." ;
    ] ;
  rdfs:comment "A SPIN template that wraps an ASK query." ;
  rdfs:label "Ask template" ;
  rdfs:subClassOf spin:Template ;
.
spin:AskTemplates
  a spin:AskTemplate ;
  spin:abstract true ;
  rdfs:comment "Suggested abstract base class for all AskTemplates." ;
  rdfs:label "Ask templates" ;
  rdfs:subClassOf spin:Templates ;
.
spin:Column
  a rdfs:Class ;
  rdfs:comment "Provides metadata about a column in the result set of a (SPARQL) query, for example of the body queries of SPIN templates. Columns can define human-readable labels that serve as column titles, using rdfs:label." ;
  rdfs:label "Column" ;
  rdfs:subClassOf rdfs:Resource ;
.
spin:ConstraintViolation
  a rdfs:Class ;
  rdfs:comment "An object that can be created by spin:constraints to provide information about a constraint violation." ;
  rdfs:label "Constraint violation" ;
  rdfs:subClassOf rdfs:Resource ;
.
spin:ConstraintViolationLevel
  a rdfs:Class ;
  rdfs:comment "The type of the supported levels of constraint violations, including spin:Error and spin:Warning." ;
  rdfs:label "Constraint violation level" ;
  rdfs:subClassOf rdfs:Resource ;
.
spin:ConstructTemplate
  a rdfs:Class ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate spin:body ;
      spl:valueType sp:Construct ;
      rdfs:comment "The CONSTRUCT query wrapped by this template." ;
    ] ;
  rdfs:label "Construct template" ;
  rdfs:subClassOf spin:Template ;
.
spin:ConstructTemplates
  a spin:ConstructTemplate ;
  spin:abstract true ;
  rdfs:comment "Suggested abstract base class for all ConstructTemplates." ;
  rdfs:label "Construct templates" ;
  rdfs:subClassOf spin:Templates ;
.
spin:Error
  a spin:ConstraintViolationLevel ;
  rdfs:comment "Indicates that the associated constraint violation is an error that should be fixed." ;
  rdfs:label "Error" ;
.
spin:Fatal
  a spin:ConstraintViolationLevel ;
  rdfs:comment "Indicates that the associated constraint violation is a severe error that must be fixed. Constraint checking engines may decide to stop further evaluation once a fatal error has been detected." ;
  rdfs:label "Fatal" ;
.
spin:Function
  a rdfs:Class ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate spin:body ;
      rdfs:comment "the body of the function" ;
    ] ;
  rdfs:comment "Metaclass for functions that can be used in SPARQL expressions (e.g. FILTER or BIND). The function themselves are classes that are instances of this metaclass. Function calls are instances of the function classes, with property values for the arguments." ;
  rdfs:label "Function" ;
  rdfs:subClassOf spin:Module ;
.
spin:Functions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Attribute ;
      spl:defaultValue "result" ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the result variable. In SPARQLMotion, a result variable must be specified, but we leave the minCount constraint on 0 to remove clutter in constraint checking." ;
    ] ;
  rdfs:comment "An abstract base class for all defined functions. This class mainly serves as a shared root so that the various instances of the Function metaclass are grouped together." ;
  rdfs:label "Functions" ;
  rdfs:subClassOf spin:Modules ;
.
spin:Info
  a spin:ConstraintViolationLevel ;
  rdfs:comment "Indicates that the associated constraint violation is a not a problem. This level can be used for diagnostic and debugging purposes." ;
  rdfs:label "Info" ;
.
spin:LibraryOntology
  a rdfs:Class ;
  rdfs:comment "A marker class that can be attached to base URIs (ontologies) to instruct SPIN engines that this ontology only contains a library of SPIN declarations. Library Ontologies should be ignored by SPIN inference engines even if they have been imported by a domain model. For example, a SPIN version of OWL RL may contain all the OWL RL axioms, attached to owl:Thing, but nothing else. However, when executed, these axioms should not be executed over themselves, because we don't want the system to reason about the SPIN triples to speed up things." ;
  rdfs:label "Library ontology" ;
  rdfs:subClassOf owl:Ontology ;
.
spin:MagicProperties
  a spin:MagicProperty ;
  spin:abstract true ;
  rdfs:comment "An abstract superclass that can be used to group all spin:MagicProperty instances under a single parent class." ;
  rdfs:label "Magic properties" ;
  rdfs:subClassOf spin:Functions ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:MagicProperty
  a rdfs:Class ;
  rdfs:label "Magic property" ;
  rdfs:subClassOf spin:Function ;
  rdfs:subClassOf rdf:Property ;
.
spin:Module
  a rdfs:Class ;
  rdfs:comment "An abstract building block of a SPARQL system. A Module can take Arguments as input and applies them on an input RDF Graph. The Arguments should be declared as spin:constraints." ;
  rdfs:label "Module" ;
  rdfs:subClassOf rdfs:Class ;
.
spin:Modules
  a rdfs:Class ;
  spin:constructor [
      a spl:ConstructDefaultValues ;
    ] ;
  rdfs:comment "An \"artificial\" parent class for all Functions and Templates." ;
  rdfs:label "Modules" ;
  rdfs:subClassOf rdfs:Resource ;
.
spin:Rule
  a rdfs:Class ;
  rdfs:comment "Groups together the kinds of SPARQL commands that can appear as SPIN rules and constructors: CONSTRUCT, DELETE WHERE and DELETE/INSERT. This class is never to be instantiated directly." ;
  rdfs:label "Rule" ;
  rdfs:subClassOf sp:Command ;
.
spin:RuleProperty
  a rdfs:Class ;
  rdfs:comment "The metaclass of spin:rule and its subproperties. spin:RuleProperties can have additional metadata attached to them." ;
  rdfs:label "Rule property" ;
  rdfs:subClassOf rdf:Property ;
.
spin:SelectTemplate
  a rdfs:Class ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate spin:body ;
      spl:valueType sp:Select ;
      rdfs:comment "The SELECT query wrapped by this template." ;
    ] ;
  rdfs:comment "A SPIN template that wraps a SELECT query." ;
  rdfs:label "Select template" ;
  rdfs:subClassOf spin:TableDataProvider ;
  rdfs:subClassOf spin:Template ;
.
spin:SelectTemplates
  a spin:SelectTemplate ;
  spin:abstract true ;
  rdfs:comment "Suggested abstract base class for all SelectTemplates." ;
  rdfs:label "Select templates" ;
  rdfs:subClassOf spin:Templates ;
.
spin:TableDataProvider
  a rdfs:Class ;
  rdfs:comment """An abstraction of objects that can produce tabular data. This serves as a base class of spin:SelectTemplate, because SELECT queries can produce tables with columns for each result variable. However, other types of TableDataProviders are conceivable by other frameworks, and this class may prove as a useful shared foundation.

TableDataProviders can link to definitions of columns via spin:column, and these definitions can inform rendering engines.""" ;
  rdfs:label "Table data provider" ;
  rdfs:subClassOf rdfs:Class ;
.
spin:Template
  a rdfs:Class ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate spin:body ;
      rdfs:comment "the body of the Template" ;
    ] ;
  rdfs:comment "The metaclass of SPIN templates. Templates are classes that are instances of this class. A template represents a reusable SPARQL query or update request that can be parameterized with arguments. Templates can be instantiated in places where normally a SPARQL query or update request is used, in particular as spin:rules and spin:constraints." ;
  rdfs:label "Template" ;
  rdfs:subClassOf spin:Module ;
.
spin:Templates
  a spin:Template ;
  spin:abstract true ;
  rdfs:comment "Suggested abstract base class for all Templates." ;
  rdfs:label "Templates" ;
  rdfs:subClassOf spin:Modules ;
.
spin:UpdateTemplate
  a rdfs:Class ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate spin:body ;
      spl:valueType sp:Update ;
      rdfs:comment "The UPDATE command wrapped by this template." ;
    ] ;
  rdfs:comment "A SPIN template that has an UPDATE command as its body." ;
  rdfs:label "Update template" ;
  rdfs:subClassOf spin:Template ;
.
spin:UpdateTemplates
  a spin:UpdateTemplate ;
  spin:abstract true ;
  rdfs:comment "Suggested abstract base class for all UpdateTemplates." ;
  rdfs:label "Update templates" ;
  rdfs:subClassOf spin:Templates ;
.
spin:Warning
  a spin:ConstraintViolationLevel ;
  rdfs:comment "Indicates that the associated constraint violation is a problem that may not have to be fixed but may lead to issues in the future." ;
  rdfs:label "Warning" ;
.
spin:_arg1
  a sp:Variable ;
  sp:varName "arg1" ;
.
spin:_arg2
  a sp:Variable ;
  sp:varName "arg2" ;
.
spin:_arg3
  a sp:Variable ;
  sp:varName "arg3" ;
.
spin:_arg4
  a sp:Variable ;
  sp:varName "arg4" ;
.
spin:_arg5
  a sp:Variable ;
  sp:varName "arg5" ;
.
spin:_this
  a sp:Variable ;
  sp:varName "this" ;
  rdfs:comment "A system variable representing the current context instance in a rule or constraint." ;
  rdfs:label "_this" ;
.
spin:abstract
  a rdf:Property ;
  rdfs:comment "Can be set to true to indicate that this module shall not be instantiated. Abstract modules are only there to organize other modules into hierarchies." ;
  rdfs:domain spin:Module ;
  rdfs:label "abstract" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:ask
  a spin:Function ;
  rdfs:comment """Executes a given ASK query and returns its boolean result. The first argument must point to an sp:Ask or a SPIN template call that has an ASK query as its body. All subsequent argument can come in pairs, with the first one being a variable name and the second its binding.

Example:

    BIND (spin:ask(?query, \"this\", owl:Thing) AS ?result) .

will execute the sp:Ask behind ?query with the variable ?this pre-bound to owl:Thing.""" ;
  rdfs:label "ask" ;
  rdfs:subClassOf spin:Functions ;
.
spin:body
  a rdf:Property ;
  rdfs:comment "The body of a Function or Template. This points to a Query instance. For Functions, this is limited to either ASK or SELECT type queries. If the body is the ASK function then the return value is xsd:boolean. Otherwise, the SELECT query must have a single return variable. The first binding of this SELECT query will be returned as result of the function call." ;
  rdfs:label "body" ;
  rdfs:range sp:Command ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:cachable
  a rdf:Property ;
  rdfs:comment "Can be set to true to instruct the SPIN engine that it may cache the results of all calls to the associated function. Functions should only be marked as cachable if the same combination of input arguments always returns the same result. Functions that query a graph or other background data that may change over time should not be cached. Caching can significantly improve performance of frequently needed functions." ;
  rdfs:domain spin:Function ;
  rdfs:label "cachable" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:cachableForOntologies
  a rdf:Property ;
  rdfs:comment "Can be set to true to instruct the SPIN engine that the outcome of the function does not depend on any instances/indivuduals in the current query graph, but only on the definitions of classes, properties and shapes. Engines may cache the results of all calls to the associated function. Functions should only be marked as cachable if the same combination of input arguments always returns the same result." ;
  rdfs:domain spin:Function ;
  rdfs:label "cachable for ontologies" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:column
  a rdf:Property ;
  rdfs:comment "Can link a TableDataProvider (esp. SelectTemplate) with one or more columns that provide metadata for rendering purposes. Columns can be sorted by their spin:columnIndex (which must align with the ordering of variables in the SELECT query starting with 0). Not all result variables of the underlying query need to have a matching spin:Column." ;
  rdfs:domain spin:TableDataProvider ;
  rdfs:label "column" ;
  rdfs:range spin:Column ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:columnIndex
  a rdf:Property ;
  rdfs:comment "The index of a column (from left to right) starting at 0." ;
  rdfs:domain spin:Column ;
  rdfs:label "column index" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:columnType
  a rdf:Property ;
  rdfs:comment "The datatype or resource type of a spin:Column. For example this is useful as metadata to inform a rendering engine that numeric columns (e.g. xsd:float) need to be right-aligned." ;
  rdfs:domain spin:Column ;
  rdfs:label "column type" ;
  rdfs:range rdfs:Class ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:columnWidth
  a rdf:Property ;
  rdfs:comment "The preferred width of the associated Column, for display purposes. Values in pixels (rendering engines may multiply the values depending on resolution)." ;
  rdfs:domain spin:Column ;
  rdfs:label "column width" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:command
  a rdf:Property ;
  rdfs:comment "Can be used to link a resource with a SPARQL query or update request (sp:Command)." ;
  rdfs:label "command" ;
  rdfs:range sp:Command ;
.
spin:constraint
  a rdf:Property ;
  rdfs:comment "Links a class with constraints on its instances. The values of this property are \"axioms\" expressed as CONSTRUCT or ASK queries where the variable ?this refers to the instances of the surrounding class. ASK queries must evaluate to false for each member of this class - returning true means that the instance ?this violates the constraint. CONSTRUCT queries must create instances of spin:ConstraintViolation to provide details on the reason for the violation." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "constraint" ;
  rdfs:subPropertyOf spin:query ;
.
spin:construct
  a spin:MagicProperty ;
  rdfs:comment """Evaluates a given sp:Construct or SPIN template call (first argument on the left hand side) and binds the resulting triples to the variables on the right hand side.

Example:

    (?query \"this\" owl:Thing) spin:construct (?s ?p ?o)

will execute the sp:Construct ?query using the binding of owl:Thing to ?this. The resulting triples will be bound to ?s, ?p and ?o. If any of ?s ?p ?o are bound, it will only return the matching triples.""" ;
  rdfs:label "construct" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spin:constructViolations
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The instance to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that this type is validated against." ;
    ] ;
  rdfs:comment """Takes an instance (?arg1) and a class definition (?arg2) and returns all constraint violations for that instance as triples. This magic property basically runs its own constraint checker for defining meta-constraints, and can also be used to classify instances.

Example:

    CONSTRUCT {
        ?s ?p ?o .
    }
    WHERE {
        (my:Person my:OldPerson) spin:constructViolations (?s ?p ?o) .
    }""" ;
  rdfs:label "construct violations" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spin:constructor
  a rdf:Property ;
  rdfs:comment "Can be used to attach a \"constructor\" to a class. A constructor is a SPARQL CONSTRUCT query or INSERT/DELETE Update operation that can add initial values to the current instance. At execution time, the variable ?this is bound to the current instance. Tools can call constructors of a class and its superclasses when an instance of a class has been created. Constructors will also be used to initialize resources that have received a new rdf:type triple as a result of spin:rules firing." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "constructor" ;
  rdfs:range spin:Rule ;
  rdfs:subPropertyOf spin:command ;
.
spin:eval
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The expression to evaluate. Should be a sp:Select, sp:Ask, a sp:Variable or an instance of a SPARQL function class, but may also be a simple RDF value." ;
    ] ;
  rdfs:comment "Evaluates a given SPIN expression or SELECT or ASK query, and returns its result. The first argument must be the expression in SPIN RDF syntax. All other arguments must come in pairs: first a property name, and then a value. These name/value pairs will be pre-bound variables for the execution of the expression." ;
  rdfs:label "eval" ;
  rdfs:subClassOf spin:Functions ;
.
spin:evalInGraph
  a spin:Function ;
  rdfs:comment "Evaluates a given SPIN expression or SELECT or ASK query, and returns its result. The first argument must be the expression in SPIN RDF syntax. This RDF representation of this expression is expected to be in the currently active query graph. The second argument is the URI of a graph that the actual query shall be evaluated against. All other arguments must come in pairs: first a property name, and then a value. These name/value pairs will be pre-bound variables for the execution of the expression." ;
  rdfs:label "eval in graph" ;
  rdfs:subClassOf spin:Functions ;
.
spin:fix
  a rdf:Property ;
  rdfs:comment "Can be used to link a ConstraintViolation with one or more UPDATE Templates that would help fix the violation." ;
  rdfs:domain spin:ConstraintViolation ;
  rdfs:label "fix" ;
  rdfs:range spin:UpdateTemplate ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:imports
  a owl:OntologyProperty ;
  rdfs:comment "Can be used to link an RDF graph (usually the instance of owl:Ontology) with a SPIN library to define constraints. SPIN-aware tools should include the definitions from those libraries for constraint checking. Using such libraries is a simpler alternative than explicitly importing them using owl:imports, because it does not force all the SPIN triples into the RDF model." ;
  rdfs:domain owl:Ontology ;
  rdfs:label "imports" ;
  rdfs:range owl:Ontology ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:inverseBody
  a rdf:Property ;
  rdfs:comment "The inverse body of a magic property - used to provide a more optimized query if there is one result variable (on the right). The values must be instances of Select and must return SELECT ?arg1 etc. The WHERE clause can access the variable ?object to refer to the provided value on the right hand side of the magic property." ;
  rdfs:domain spin:MagicProperty ;
  rdfs:label "inverse body" ;
  rdfs:range sp:Select ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:labelTemplate
  a rdf:Property ;
  rdfs:comment "A template string for displaying instantiations of a module in human-readable form. The template may contain the argument variable names in curly braces to support substitution. For example, \"The number of values of the {?arg1} property.\"" ;
  rdfs:domain spin:Template ;
  rdfs:label "label template" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:nextRuleProperty
  a rdf:Property ;
  rdfs:comment "Can be used to link two sub-properties of spin:rule (or spin:rule itself) to instruct the SPIN engine to execute one set of rules before another one. The values of the subject property will be executed before those of the object property." ;
  rdfs:domain spin:RuleProperty ;
  rdfs:label "next rule property" ;
  rdfs:range spin:RuleProperty ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:private
  a rdf:Property ;
  rdfs:comment "Can be set to true to indicate that a SPIN function or template is only meant to be used as a helper of other modules, but not directly. Among others, this allows user interfaces to filter out private modules. Furthermore, it tells potential users of this module that they should avoid using this module, as it may not be stable." ;
  rdfs:domain spin:Module ;
  rdfs:label "private" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:query
  a rdf:Property ;
  rdfs:comment "Can be used to point from any resource to a Query." ;
  rdfs:label "query" ;
  rdfs:range sp:Query ;
  rdfs:subPropertyOf spin:command ;
.
spin:returnType
  a rdf:Property ;
  rdfs:comment "The return type of a Function, e.g. xsd:string." ;
  rdfs:domain spin:Function ;
  rdfs:label "return type" ;
  rdfs:range rdfs:Class ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:rule
  a spin:RuleProperty ;
  rdfs:comment "An inferencing rule attached to a class. Rules are expressed as CONSTRUCT queries or INSERT/DELETE operations where the variable ?this will be bound to the current instance of the class. These inferences can be used to derive new values from existing values at the instance." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "rule" ;
  rdfs:range spin:Rule ;
  rdfs:subPropertyOf spin:command ;
.
spin:rulePropertyMaxIterationCount
  a rdf:Property ;
  rdfs:comment "Can be attached to spin:rule (or subclasses thereof) to instruct a SPIN rules engine that it shall only execute the rules max times. If no value is specified, then the rules will be executed with no specific limit." ;
  rdfs:domain spin:RuleProperty ;
  rdfs:label "rule property max iteration count" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:select
  a spin:MagicProperty ;
  rdfs:comment """Executes a given SELECT or ASK query (or a corresponding SPIN template call) and binds its result rows to the variables specified on the right hand side. May also pre-bind variables for the query execution, using name-value pairs on the left hand side.

Example:

    (?query \"this\" owl:Thing) spin:select (?a ?b)

will execute the sp:Select or sp:Ask that ?query points to and pre-bind ?this with the value of owl:Thing for the execution of the query. The first result variable of the query's result set will be bound to ?a, the second to ?b etc. If the nodes on the right are bound (or constants) then it will match with the values from the result set.

Note that the first argument on the left hand side can be an instance of a SPIN template (but not the template itself). If you need to execute a template, retrieve its spin:body first.""" ;
  rdfs:label "select" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spin:symbol
  a rdf:Property ;
  rdfs:comment "The symbol of a function, e.g. \"=\" for the eq function." ;
  rdfs:domain spin:Function ;
  rdfs:label "symbol" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:systemProperty
  a rdf:Property ;
  rdfs:comment "An \"abstract\" base property that groups together those system properties that the user will hardly ever need to see in property trees. This property may be dropped in future versions of this ontology - right now it's mainly here for convenience." ;
  rdfs:label "system property" ;
.
spin:thisUnbound
  a rdf:Property ;
  rdfs:comment "Can be set to true for SPIN rules and constraints that do not require pre-binding the variable ?this with all members of the associated class. This flag should only be set to true if the WHERE clause is sufficiently strong to only bind instances of the associated class, or its subclasses. In those cases, the engine can greatly improve performance of query execution, because it does not need to add clauses to narrow down the WHERE clause." ;
  rdfs:domain sp:Construct ;
  rdfs:label "this unbound" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:update
  a rdf:Property ;
  rdfs:comment "Can be used to point from any resource to an Update." ;
  rdfs:label "update" ;
  rdfs:range sp:Update ;
  rdfs:subPropertyOf spin:command ;
.
spin:violatesConstraints
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The instance to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the constraints of." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given instance (?arg1) violates any of the constraints defined for a given class (?arg2)." ;
  rdfs:label "violates constraints" ;
  rdfs:subClassOf spin:Functions ;
.
spin:violationDetail
  a rdf:Property ;
  rdfs:comment "Links a (parent) spin:ConstraintViolation with one or more (child) spin:ConstraintViolations that provide details on the parent violation. This is commonly used in conjunction with spin:constructViolations to indicate that certain violations have triggered the parent violation." ;
  rdfs:domain spin:ConstraintViolation ;
  rdfs:label "violation detail" ;
  rdfs:range spin:ConstraintViolation ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:violationLevel
  a rdf:Property ;
  rdfs:comment "An optional attribute of ConstraintViolations to point at a violation level (such as Error and Warning). Defaults to spin:Error." ;
  rdfs:domain spin:ConstraintViolation ;
  rdfs:label "violation level" ;
  rdfs:range spin:ConstraintViolationLevel ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:violationPath
  a rdf:Property ;
  rdfs:comment "An optional attribute of ConstraintViolations to provide a path expression from the root resource to the value that is invalid. If this is a URI then the path represents the predicate of a subject/predicate combination. Otherwise it should be a blank node of type sp:Path." ;
  rdfs:domain spin:ConstraintViolation ;
  rdfs:label "violation path" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:violationRoot
  a rdf:Property ;
  rdfs:comment "The root resource of the violation (often ?this in the constraint body)." ;
  rdfs:domain spin:ConstraintViolation ;
  rdfs:label "violation root" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:violationSource
  a rdf:Property ;
  rdfs:comment "Can be used to link a spin:ConstraintViolation with the query or template call that caused it. This property is typically filled in automatically by the constraint checking engine and does not need to be set manually. However, it can be useful to learn more about the origin of a violation." ;
  rdfs:domain spin:ConstraintViolation ;
  rdfs:label "violation source" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf spin:systemProperty ;
.
spin:violationValue
  a rdf:Property ;
  rdfs:comment "An optional attribute of ConstraintViolations to point at a specific RDF node that caused the violation. Should be accessible from the root via the violationPath." ;
  rdfs:domain spin:ConstraintViolation ;
  rdfs:label "violation value" ;
  rdfs:subPropertyOf spin:systemProperty ;
.
<http://spinrdf.org/spl>
  a spin:LibraryOntology ;
  a owl:Ontology ;
  rdfs:comment "A collection of generally useful SPARQL functions (expressed as SPIN functions), and SPIN templates. Also provides a top-level classification of functions, and definitions of the standard SPARQL functions." ;
  rdfs:label "SPIN Standard Library" ;
  owl:imports <http://spinrdf.org/spin> ;
  owl:versionInfo "1.4.2" ;
.
spl:
  tosh:systemNamespace true ;
.
spl:AllArguments
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "arg" ;
          ]
          [
            sp:varName "atClass" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "atClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "arg" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "atClass" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "arg" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate spl:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the arguments of." ;
    ] ;
  spin:labelTemplate "All spl:Arguments of {?class}" ;
  rdfs:comment "Gets a list of all spl:Arguments declared at a given class and its superclasses." ;
  rdfs:label "All arguments" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
spl:Argument
  a spin:ConstructTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b14277 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b14277 ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b14277 ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b14277 ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Filter ;
              sp:expression [
                  a sp:isIRI ;
                  sp:arg1 spin:_this ;
                ] ;
            ]
          )
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    (
                      [
                        a sp:Filter ;
                        sp:expression [
                            a sp:or ;
                            sp:arg1 [
                                a sp:not ;
                                sp:arg1 [
                                    a sp:bound ;
                                    sp:arg1 [
                                        sp:varName "optional" ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "optional" ;
                                  ] ;
                                sp:arg2 false ;
                              ] ;
                          ] ;
                      ]
                    )
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:notExists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "value" ;
                                  ] ;
                                sp:predicate [
                                    sp:varName "predicate" ;
                                  ] ;
                                sp:subject spin:_this ;
                              ]
                            ) ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:notExists ;
                          sp:elements (
                              [
                                sp:object [
                                    sp:varName "template" ;
                                  ] ;
                                sp:predicate rdf:type ;
                                sp:subject spin:_this ;
                              ]
                              [
                                a sp:Filter ;
                                sp:expression [
                                    a spl:instanceOf ;
                                    sp:arg1 [
                                        sp:varName "template" ;
                                      ] ;
                                    sp:arg2 spl:UnionTemplate ;
                                  ] ;
                              ]
                            ) ;
                        ] ;
                    ]
                  )
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:concat ;
                        sp:arg1 "Missing value for argument " ;
                        sp:arg2 [
                            a afn:localname ;
                            sp:arg1 [
                                sp:varName "predicate" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
                (
                  (
                    (
                      [
                        a sp:Filter ;
                        sp:expression [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "valueType" ;
                              ] ;
                          ] ;
                      ]
                    )
                    [
                      sp:object [
                          sp:varName "value" ;
                        ] ;
                      sp:predicate [
                          sp:varName "predicate" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:and ;
                          sp:arg1 [
                              a sp:not ;
                              sp:arg1 [
                                  a spl:instanceOf ;
                                  sp:arg1 [
                                      sp:varName "value" ;
                                    ] ;
                                  sp:arg2 [
                                      sp:varName "valueType" ;
                                    ] ;
                                ] ;
                            ] ;
                          sp:arg2 [
                              a sp:or ;
                              sp:arg1 [
                                  a sp:ne ;
                                  sp:arg1 [
                                      sp:varName "valueType" ;
                                    ] ;
                                  sp:arg2 rdfs:Resource ;
                                ] ;
                              sp:arg2 [
                                  a sp:isLiteral ;
                                  sp:arg1 [
                                      sp:varName "value" ;
                                    ] ;
                                ] ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:concat ;
                        sp:arg1 "Incorrect type of argument " ;
                        sp:arg2 [
                            a afn:localname ;
                            sp:arg1 [
                                sp:varName "predicate" ;
                              ] ;
                          ] ;
                        sp:arg3 " (expected: " ;
                        sp:arg4 [
                            a afn:localname ;
                            sp:arg1 [
                                sp:varName "valueType" ;
                              ] ;
                          ] ;
                        sp:arg5 ")" ;
                      ] ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate spl:defaultValue ;
      rdfs:comment "the default value for the argument" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate spl:optional ;
      spl:valueType xsd:boolean ;
      rdfs:comment "indicates whether the argument is optional" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate spl:valueType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the value type of the argument" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:hidden ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates whether this is a \"hidden\" argument. Hidden arguments will not be presented to the user in input dialogs but instead always have their defaultValue." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate rdfs:comment ;
      spl:valueType xsd:string ;
      rdfs:comment "a comment describing the argument" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate spl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property holding the values of each function call" ;
    ] ;
  spin:labelTemplate "Argument {?predicate} : {?valueType}" ;
  rdfs:comment "Provides metadata about an argument of a SPIN Function or Template. Arguments wrap a given rdf:Property (predicate) and specify its value type and whether the argument is optional. When used as spin:constraint, the body of this template will verify that a non-optional value exists and that it has the specified value type. Arguments that have been declared spl:optional true become optional if the type of ?this is spl:UnionTemplate. " ;
  rdfs:label "Argument" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:Attribute
  a spin:ConstructTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b70470 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b70470 ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b70470 ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:or ;
                    sp:arg1 [
                        a sp:and ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "minCount" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:lt ;
                            sp:arg1 [
                                a spl:objectCount ;
                                sp:arg1 spin:_this ;
                                sp:arg2 [
                                    sp:varName "predicate" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                sp:varName "minCount" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:and ;
                        sp:arg1 [
                            a sp:bound ;
                            sp:arg1 [
                                sp:varName "maxCount" ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:gt ;
                            sp:arg1 [
                                a spl:objectCount ;
                                sp:arg1 spin:_this ;
                                sp:arg2 [
                                    sp:varName "predicate" ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                sp:varName "maxCount" ;
                              ] ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:exists ;
                    sp:elements (
                        (
                          [
                            a sp:Filter ;
                            sp:expression [
                                a sp:bound ;
                                sp:arg1 [
                                    sp:varName "valueType" ;
                                  ] ;
                              ] ;
                          ]
                        )
                        [
                          sp:object [
                              sp:varName "value" ;
                            ] ;
                          sp:predicate [
                              sp:varName "predicate" ;
                            ] ;
                          sp:subject spin:_this ;
                        ]
                        [
                          a sp:Filter ;
                          sp:expression [
                              a sp:not ;
                              sp:arg1 [
                                  a spl:instanceOf ;
                                  sp:arg1 [
                                      sp:varName "value" ;
                                    ] ;
                                  sp:arg2 [
                                      sp:varName "valueType" ;
                                    ] ;
                                ] ;
                            ] ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate spl:defaultValue ;
      rdfs:comment "the default value of the attribute" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate spl:maxCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "the maximum number of values permitted for the property" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate spl:minCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "the minimum number of values permitted for the property" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate spl:valueType ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the type that all values of the property must have" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate rdfs:comment ;
      spl:valueType xsd:string ;
      rdfs:comment "a comment describing the meaning of this attribute" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate spl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "the RDF property holding the attribute value" ;
    ] ;
  spin:labelTemplate "Attribute {?predicate} : {?valueType} [{?minCount},{?maxCount}]" ;
  rdfs:comment """Defines an \"attribute\" of a class. Attribute definitions bundle common modeling patterns known from object-oriented languages like UML. Each attribute can have min and max cardinality, a value type and a default value. The attribute links a class with one RDF property. This template should be used as spin:constraints on a class to make sure that classes meet the expected cardinalities and valueType constraints.
If a model wants to use spl:defaultValue, then it should instantiate the spl:ConstructDefaultValues as a spin:constructor at some root class, such as rdfs:Resource.""" ;
  rdfs:label "Attribute" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:BooleanFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "A collection of functions that return a boolean value (true or false)." ;
  rdfs:label "Boolean functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:ConstraintTemplate
  a rdfs:Class ;
  rdfs:comment "Metaclass for CONSTRUCT templates that create spin:ConstraintViolations and can be used as values of spin:constraint." ;
  rdfs:label "Constraint template" ;
  rdfs:subClassOf spin:ConstructTemplate ;
.
spl:ConstraintTemplates
  a spl:ConstraintTemplate ;
  spin:abstract true ;
  rdfs:comment "Abstract superclass of templates that can be used as spin:constraints. The subclasses are expected to construct spin:ConstraintViolations and use ?this to talk about the instances of the associated class." ;
  rdfs:label "Constraint templates" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:ConstructDefaultValues
  a spin:ConstructTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object [
                sp:varName "defaultValue" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject spin:_this ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "directType" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_this ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "directType" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "attribute" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "defaultValue" ;
              ] ;
            sp:predicate spl:defaultValue ;
            sp:subject [
                sp:varName "attribute" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "predicate" ;
              ] ;
            sp:predicate spl:predicate ;
            sp:subject [
                sp:varName "attribute" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "Construct default values" ;
  rdfs:comment "This template can be attached as spin:constructor to a root class such as rdfs:Resource to ensure that SPIN processors assign default values to certain properties. Looks for any templates attached as spin:constraints to the types of ?this and then assigns their declared spl:defaultValues." ;
  rdfs:label "Construct default values" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:CountPropertyConstraintTemplates
  a spl:ConstraintTemplate ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:maxCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum number of values that the property must have." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:minCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The minimum number of values that the property must have." ;
    ] ;
  rdfs:comment "Abstract superclass of property constraints that compare the number of values with either min or max count." ;
  rdfs:label "Count property constraint templates" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:DateFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "A collection of functions that operate on date/time literals." ;
  rdfs:label "Date functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:ExistencePropertyPairConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b76881 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b76881 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b76881 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b76881 ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:exists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "someValue" ;
                        ] ;
                      sp:predicate [
                          sp:varName "otherProperty" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "object" ;
                        ] ;
                      sp:predicate [
                          sp:varName "property" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Property " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg3 " must have a value because " ;
                sp:arg4 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "otherProperty" ;
                      ] ;
                  ] ;
                sp:arg5 " has" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "The property {?property} must have a value whenever {?otherProperty} has a value" ;
  rdfs:label "Existence property pair constraint" ;
  rdfs:subClassOf spl:PropertyPairConstraintTemplates ;
.
spl:InferDefaultValue
  a spin:ConstructTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object [
                sp:varName "defaultValue" ;
              ] ;
            sp:predicate [
                sp:varName "predicate" ;
              ] ;
            sp:subject spin:_this ;
          ]
        ) ;
      sp:where (
          [
            a sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "anyValue" ;
                    ] ;
                  sp:predicate [
                      sp:varName "predicate" ;
                    ] ;
                  sp:subject spin:_this ;
                ]
              ) ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "anyValue" ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate spl:defaultValue ;
      rdfs:comment "The default value to infer." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate spl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to infer the default value of." ;
    ] ;
  spin:labelTemplate "Default value for {?predicate}: {?defaultValue}" ;
  rdfs:comment "Can be used to infer default values for a given subject/predicate combination. This is typically assigned as spin:rule to a class. If ?this does not already have a value for a given property {?predicate}, then this will infer the value {?defaultValue}." ;
  rdfs:label "Infer default value" ;
  rdfs:subClassOf spin:ConstructTemplates ;
.
spl:LessThanOtherPropertyPairConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b96155 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b96155 ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b96155 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b96155 ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b96155 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            sp:object [
                sp:varName "otherValue" ;
              ] ;
            sp:predicate [
                sp:varName "otherProperty" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:ge ;
                sp:arg1 [
                    sp:varName "value" ;
                  ] ;
                sp:arg2 [
                    sp:varName "otherValue" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
                sp:arg3 " of " ;
                sp:arg4 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg5 " must be less than " ;
                sp:arg6 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "otherValue" ;
                      ] ;
                  ] ;
                sp:arg7 " of " ;
                sp:arg8 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "otherProperty" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "Values of {?property} must be less than the values of {?otherProperty}" ;
  rdfs:comment "Can be used to define a constraint between two properties (?property and ?otherProperty) enforcing the invariant that the values of ?property must be smaller than the values of ?otherProperty. For example this can be used to state that ex:startDate must be < ex:endDate." ;
  rdfs:label "Less than other property pair constraint" ;
  rdfs:subClassOf spl:PropertyPairConstraintTemplates ;
.
spl:MathematicalFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "A collection of functions operating on numbers." ;
  rdfs:label "Mathematical functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:MiscFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "A collection of functions that are difficult to categorize." ;
  rdfs:label "Misc functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:NonExistencePropertyPairConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b47159 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b47159 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b47159 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b47159 ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "someValue" ;
                        ] ;
                      sp:predicate [
                          sp:varName "otherProperty" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:exists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "object" ;
                        ] ;
                      sp:predicate [
                          sp:varName "property" ;
                        ] ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Property " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg3 " must have no values because " ;
                sp:arg4 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "otherProperty" ;
                      ] ;
                  ] ;
                sp:arg5 " has none" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "The property {?property} must have no values as long as {?otherProperty} has none" ;
  rdfs:label "Non-existence property pair constraint" ;
  rdfs:subClassOf spl:PropertyPairConstraintTemplates ;
.
spl:ObjectCountPropertyConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b46843 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b46843 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b46843 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b46843 ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spl:objectCount ;
                sp:arg1 spin:_this ;
                sp:arg2 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "objectCount" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "minCount" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:lt ;
                        sp:arg1 [
                            sp:varName "objectCount" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "minCount" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "maxCount" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:gt ;
                        sp:arg1 [
                            sp:varName "objectCount" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "maxCount" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Invalid number of values: " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "objectCount" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "The property {?property} must have between {?minCount} and {?maxCount} values" ;
  rdfs:comment "Represents a constraint that can be attached to a class to specify that a given property must have between min and max values." ;
  rdfs:label "Object count property constraint" ;
  rdfs:subClassOf spl:CountPropertyConstraintTemplates ;
.
spl:OntologyFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "A collection of functions performing ontology-related operations." ;
  rdfs:label "Ontology functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:PrimaryKeyPropertyConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b83324 ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b83324 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b83324 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b83324 ;
          ]
        ) ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:notExists ;
                        sp:elements (
                            [
                              sp:object [
                                  sp:varName "any" ;
                                ] ;
                              sp:predicate [
                                  sp:varName "property" ;
                                ] ;
                              sp:subject spin:_this ;
                            ]
                          ) ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "Missing value for primary key property" ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:gt ;
                        sp:arg1 [
                            a spl:objectCount ;
                            sp:arg1 spin:_this ;
                            sp:arg2 [
                                sp:varName "property" ;
                              ] ;
                          ] ;
                        sp:arg2 1 ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression "Multiple values of primary key property" ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
                (
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:eq ;
                        sp:arg1 [
                            a spl:objectCount ;
                            sp:arg1 spin:_this ;
                            sp:arg2 [
                                sp:varName "property" ;
                              ] ;
                          ] ;
                        sp:arg2 1 ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "value" ;
                      ] ;
                    sp:predicate [
                        sp:varName "property" ;
                      ] ;
                    sp:subject spin:_this ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:concat ;
                        sp:arg1 [
                            sp:varName "uriStart" ;
                          ] ;
                        sp:arg2 [
                            a sp:encode_for_uri ;
                            sp:arg1 [
                                a xsd:string ;
                                sp:arg1 [
                                    sp:varName "value" ;
                                  ] ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "uri" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:ne ;
                        sp:arg1 [
                            a xsd:string ;
                            sp:arg1 spin:_this ;
                          ] ;
                        sp:arg2 [
                            sp:varName "uri" ;
                          ] ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:concat ;
                        sp:arg1 "Primary key value " ;
                        sp:arg2 [
                            a sp:str ;
                            sp:arg1 [
                                sp:varName "value" ;
                              ] ;
                          ] ;
                        sp:arg3 " does not align with the expected URI " ;
                        sp:arg4 [
                            sp:varName "uri" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "label" ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a sp:Ask ;
      sp:where (
          [
            sp:object rdfs:label ;
            sp:predicate arg:property ;
            sp:subject spin:_this ;
          ]
        ) ;
      rdfs:comment "rdfs:label cannot be used as primary key" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:uriStart ;
      spl:valueType xsd:string ;
      rdfs:comment "The start of the URIs of well-formed instances of the associated class." ;
    ] ;
  spin:labelTemplate "The property {?property} is the primary key and URIs start with {?uriStart}" ;
  rdfs:comment "Specifies that the given property is a primary key for instances of the associated class (and its subclasses). If a property has been declared to be the primary key then each instance of the class must have exactly one value for that property. Furthermore, the URIs of those instances must start with a given string (arg:uriStart), followed by the URL-encoded primary key value. For example if arg:uriStart is \"http://example.org/country-\" and the primary key for an instance is \"de\" then the URI must be \"http://example.org/country-de\". Finally, as a result of the URI policy, there can not be any other instance with the same value under the same primary key policy." ;
  rdfs:label "Primary key property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:PropertyConstraintTemplates
  a spl:ConstraintTemplate ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property being constrained." ;
    ] ;
  rdfs:comment "Abstract superclass of constraint templates that constrain exactly one property." ;
  rdfs:label "Property constraint templates" ;
  rdfs:subClassOf spl:ConstraintTemplates ;
.
spl:PropertyPairConstraintTemplates
  a spl:ConstraintTemplate ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:otherProperty ;
      spl:valueType rdf:Property ;
      rdfs:comment "The \"other\" property." ;
    ] ;
  rdfs:comment "Abstract base class for templates that take two properties as arguments and establish a relationship between them." ;
  rdfs:label "Property pair constraint templates" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:RangePropertyConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b28065 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b28065 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b28065 ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b28065 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b28065 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "min" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:lt ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "min" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "max" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:gt ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "max" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must be in the interval [" ;
                sp:arg4 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "min" ;
                      ] ;
                  ] ;
                sp:arg5 ", " ;
                sp:arg6 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "max" ;
                      ] ;
                  ] ;
                sp:arg7 "]" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:max ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The maximum value." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:min ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The minimum value." ;
    ] ;
  spin:labelTemplate "Values of {?property} must be within the interval [ {?min} , {?max} ]" ;
  rdfs:comment "Represents a constraint that narrows down a property by a minimum and maximum value compared by <= and >=." ;
  rdfs:label "Range property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:RegexPropertyConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b11396 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b11396 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b11396 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b11396 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a sp:regex ;
                    sp:arg1 [
                        a xsd:string ;
                        sp:arg1 [
                            sp:varName "object" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        sp:varName "pattern" ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must match the regular expression \"" ;
                sp:arg4 [
                    sp:varName "pattern" ;
                  ] ;
                sp:arg5 "\"" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:pattern ;
      spl:valueType xsd:string ;
      rdfs:comment "The regular expression to match." ;
    ] ;
  spin:labelTemplate "Values of {?property} must match the regular expression {?pattern}" ;
  rdfs:label "Regex property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:RunTestCases
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "testCase" ;
          ]
          [
            sp:varName "expected" ;
          ]
          [
            sp:varName "actual" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "expr" ;
              ] ;
            sp:predicate spl:testExpression ;
            sp:subject [
                sp:varName "testCase" ;
              ] ;
          ]
          [
            a sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "expected" ;
                    ] ;
                  sp:predicate spl:testResult ;
                  sp:subject [
                      sp:varName "testCase" ;
                    ] ;
                ]
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spin:eval ;
                sp:arg1 [
                    sp:varName "expr" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "actual" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:ne ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "expected" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "actual" ;
                          ] ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "expected" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:ne ;
                        sp:arg1 [
                            sp:varName "actual" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "expected" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Runs all spl:TestCases on the current model." ;
  rdfs:label "Run test cases" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
spl:SPINOverview
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "class" ;
          ]
          [
            sp:varName "property" ;
          ]
          [
            sp:varName "rule" ;
          ]
        ) ;
      sp:where (
          (
            [
              a sp:Union ;
              sp:elements (
                  (
                    [
                      a sp:Bind ;
                      sp:expression spin:constraint ;
                      sp:variable [
                          sp:varName "bp" ;
                        ] ;
                    ]
                  )
                  (
                    [
                      a sp:Bind ;
                      sp:expression spin:constructor ;
                      sp:variable [
                          sp:varName "bp" ;
                        ] ;
                    ]
                  )
                  (
                    [
                      a sp:Bind ;
                      sp:expression spin:rule ;
                      sp:variable [
                          sp:varName "bp" ;
                        ] ;
                    ]
                  )
                ) ;
            ]
          )
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "bp" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "rule" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:ne ;
                sp:arg1 [
                    sp:varName "class" ;
                  ] ;
                sp:arg2 spin:Modules ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object spl:Argument ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object spl:Attribute ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "rule" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "SPIN Overview" ;
  rdfs:comment "Finds all constraints and rules attached to classes in the current graph, using spin:constraint, spin:constructor, spin:rule or their sub-properties. The result set will contain the associated class, the predicate, and the SPIN rule." ;
  rdfs:label "SPIN Overview" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
spl:StringFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "A collection of functions that return strings." ;
  rdfs:label "String functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:StringLengthPropertyConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b54635 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b54635 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b54635 ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b54635 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b54635 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:strlen ;
                sp:arg1 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "length" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:lt ;
                    sp:arg1 [
                        sp:varName "length" ;
                      ] ;
                    sp:arg2 [
                        a sp:coalesce ;
                        sp:arg1 [
                            sp:varName "minLength" ;
                          ] ;
                        sp:arg2 0 ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:and ;
                    sp:arg1 [
                        a sp:bound ;
                        sp:arg1 [
                            sp:varName "maxLength" ;
                          ] ;
                      ] ;
                    sp:arg2 [
                        a sp:gt ;
                        sp:arg1 [
                            sp:varName "length" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "maxLength" ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must have between " ;
                sp:arg4 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "minLength" ;
                      ] ;
                  ] ;
                sp:arg5 " and " ;
                sp:arg6 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "maxLength" ;
                      ] ;
                  ] ;
                sp:arg7 " characters" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:maxLength ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum number of characters (defaults to unlimited)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:minLength ;
      spl:valueType xsd:integer ;
      rdfs:comment "The minimum number of characters (default to 0)." ;
    ] ;
  spin:labelTemplate "Values of {?property} must have between {?minLength} and {?maxLength} characters" ;
  rdfs:comment "Represents a constraint that narrows down a property by a minimum and maximum length of the characters of the string representation of its values. This constraint is typically used for string literals, but may also be useful for integers (e.g. 4 digit numbers), and may even be used to limit the length of URIs." ;
  rdfs:label "String length property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:Test-instanceOf-lingualString
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 "test"@en ;
      sp:arg2 xsd:string ;
    ] ;
  spl:testResult true ;
.
spl:Test-instanceOf-rdfsClass
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 owl:Thing ;
      sp:arg2 rdfs:Class ;
    ] ;
  spl:testResult true ;
.
spl:Test-instanceOf-rdfsClass-false
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 owl:versionInfo ;
      sp:arg2 rdfs:Class ;
    ] ;
  spl:testResult false ;
.
spl:Test-instanceOf-rdfsClassInheritance
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 owl:Restriction ;
      sp:arg2 rdfs:Class ;
    ] ;
  spl:testResult true ;
.
spl:Test-instanceOf-rdfsLiteral
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 "test" ;
      sp:arg2 rdfs:Literal ;
    ] ;
  spl:testResult true ;
.
spl:Test-instanceOf-rdfsLiteral-false
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 owl:Thing ;
      sp:arg2 rdfs:Literal ;
    ] ;
  spl:testResult false ;
.
spl:Test-instanceOf-typedString
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 "test" ;
      sp:arg2 xsd:string ;
    ] ;
  spl:testResult true ;
.
spl:Test-instanceOf-typedString-false
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 "test" ;
      sp:arg2 xsd:integer ;
    ] ;
  spl:testResult false ;
.
spl:Test-instanceOf-untypedString
  a spl:TestCase ;
  spl:testExpression [
      a spl:instanceOf ;
      sp:arg1 "test" ;
      sp:arg2 xsd:string ;
    ] ;
  spl:testResult true ;
.
spl:Test-object-labelOfArgument
  a spl:TestCase ;
  spl:testExpression [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a spl:object ;
                      sp:arg1 spl:Argument ;
                      sp:arg2 rdfs:label ;
                    ] ;
                  sp:variable [
                      sp:varName "value" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode <http://spinrdf.org/spl> ;
          ]
        ) ;
    ] ;
  spl:testResult "Argument" ;
.
spl:Test-object-noValue
  a spl:TestCase ;
  spl:testExpression [
      a spl:object ;
      sp:arg1 owl:versionInfo ;
      sp:arg2 owl:versionInfo ;
    ] ;
.
spl:TestCase
  a rdfs:Class ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate spl:testResult ;
      rdfs:comment "The expected result of the test case, or nothing to indicate that an error is expected." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate spl:testExpression ;
      rdfs:comment "The test expression or SELECT query (anything that can be evaluated with spin:eval)." ;
    ] ;
  rdfs:comment "A test to verify that a SPIN function or magic property works as expected, and to generate documentation of example uses of the function. Each TestCase consists of a SPARQL function call or an expression that can be executed with spin:eval, and an expected result. The test framework only needs to execute spin:eval on the expression and compare it with the expected result." ;
  rdfs:label "Test case" ;
  rdfs:subClassOf rdfs:Resource ;
.
spl:TypePropertyConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b52205 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b52205 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b52205 ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b52205 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b52205 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a spl:instanceOf ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "type" ;
                      ] ;
                  ] ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must have the type " ;
                sp:arg4 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "type" ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class that the values must have as their rdf:type (or a subclass thereof)." ;
    ] ;
  spin:labelTemplate "Values of {?property} must have the type {?type}" ;
  rdfs:comment "Represents a constraint that narrows down the rdf:type of the values of a property." ;
  rdfs:label "Type property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:URIFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "A collection of functions that create URI resources." ;
  rdfs:label "URI functions" ;
  rdfs:subClassOf spin:Functions ;
.
spl:UnionTemplate
  a rdfs:Class ;
  rdfs:comment "This type can be used for templates that serve as the union (or \"collector\") of other templates. Union templates differ from other templates in that all spl:Arguments are optional. This means that union templates can be declared as subclasses of multiple other templates, yet when instantiated, only some of the arguments defined by the superclasses need to be filled in." ;
  rdfs:label "Union template" ;
  rdfs:subClassOf spin:Template ;
.
spl:UniquePropertyValueConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b40220 ;
          ]
          [
            sp:object [
                sp:varName "label" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b40220 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b40220 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b40220 ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate spin:violationValue ;
            sp:subject _:b40220 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:exists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "value" ;
                        ] ;
                      sp:predicate [
                          sp:varName "property" ;
                        ] ;
                      sp:subject [
                          sp:varName "other" ;
                        ] ;
                    ]
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:ne ;
                          sp:arg1 spin:_this ;
                          sp:arg2 [
                              sp:varName "other" ;
                            ] ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Property must have a unique value, but " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
                sp:arg3 "  already exists elsewhere. " ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "Values of {?property} must be unique" ;
  rdfs:comment "Reports an error if the given property has a value that is also used elsewhere, for the same property." ;
  rdfs:label "Unique property value constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:UntypedObjectPropertyConstraint
  a spl:ConstraintTemplate ;
  spin:body [
      a sp:Construct ;
      sp:templates (
          [
            sp:object spin:ConstraintViolation ;
            sp:predicate rdf:type ;
            sp:subject _:b30331 ;
          ]
          [
            sp:object spin:_this ;
            sp:predicate spin:violationRoot ;
            sp:subject _:b30331 ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate spin:violationPath ;
            sp:subject _:b30331 ;
          ]
          [
            sp:object [
                sp:varName "message" ;
              ] ;
            sp:predicate rdfs:label ;
            sp:subject _:b30331 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_this ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "anyType" ;
                        ] ;
                      sp:predicate rdf:type ;
                      sp:subject [
                          sp:varName "object" ;
                        ] ;
                    ]
                  ) ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "Value " ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 [
                        sp:varName "object" ;
                      ] ;
                  ] ;
                sp:arg3 " must have a type" ;
              ] ;
            sp:variable [
                sp:varName "message" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:labelTemplate "Values of {?property} must have a type" ;
  rdfs:comment "A generic SPIN template that can be used to declare a constraint that all values of a given property must have an rdf:type." ;
  rdfs:label "Untyped object property constraint" ;
  rdfs:subClassOf spl:PropertyConstraintTemplates ;
.
spl:class
  a rdf:Property ;
  rdfs:label "class" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:count
  a rdf:Property ;
  rdfs:label "count" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:defaultValue
  a rdf:Property ;
  rdfs:label "default value" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:hasArgument
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "con" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "superClass" ;
              ] ;
          ]
          [
            sp:object spl:Argument ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "con" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate spl:class ;
      spl:valueType spin:Module ;
      rdfs:comment "The module class to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given module class (?module) has at least one declared spl:Argument." ;
  rdfs:label "has argument" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spl:hasPrimaryKey
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spl:primaryKeyProperty ;
                arg:class [
                    sp:varName "class" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "primaryKey" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "primaryKey" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given class has a declared primary key, using spl:PrimaryKeyPropertyConstraint." ;
  rdfs:label "has primary key" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:hasValue
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "p" ;
              ] ;
          ]
          [
            sp:object spin:_arg3 ;
            sp:predicate [
                sp:varName "p" ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the subject that is expected to have the value" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property that is expected to hold the value" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "the expected value" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource (?arg1) has a given value (?arg3) for a given property (?arg2) or one of the sub-properties of it." ;
  rdfs:label "hasValue" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spl:hasValueOfType
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "p" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value" ;
              ] ;
            sp:predicate [
                sp:varName "p" ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a spl:instanceOf ;
                sp:arg1 [
                    sp:varName "value" ;
                  ] ;
                sp:arg2 spin:_arg3 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the subject that is expected to have the value" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the expected property" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the type to match against" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given subject (?arg1) has at least one value of a given type (?arg3) for a given property (?arg2) or one of its sub-properties." ;
  rdfs:label "hasValueOfType" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spl:instance
  a rdf:Property ;
  rdfs:domain sp:ModuleCall ;
  rdfs:label "instance" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:instanceOf
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Union ;
            sp:elements (
                (
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:or ;
                          sp:arg1 [
                              a sp:isIRI ;
                              sp:arg1 spin:_arg1 ;
                            ] ;
                          sp:arg2 [
                              a sp:isBlank ;
                              sp:arg1 spin:_arg1 ;
                            ] ;
                        ] ;
                    ]
                  )
                  [
                    a sp:TriplePath ;
                    sp:object spin:_arg2 ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdfs:subClassOf ;
                      ] ;
                    sp:subject [
                        sp:varName "class" ;
                      ] ;
                  ]
                  [
                    sp:object [
                        sp:varName "class" ;
                      ] ;
                    sp:predicate rdf:type ;
                    sp:subject spin:_arg1 ;
                  ]
                )
                (
                  (
                    [
                      a sp:Filter ;
                      sp:expression [
                          a sp:isLiteral ;
                          sp:arg1 spin:_arg1 ;
                        ] ;
                    ]
                  )
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:datatype ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                    sp:variable [
                        sp:varName "datatype" ;
                      ] ;
                  ]
                  [
                    a sp:Filter ;
                    sp:expression [
                        a sp:or ;
                        sp:arg1 [
                            a sp:or ;
                            sp:arg1 [
                                a sp:eq ;
                                sp:arg1 [
                                    sp:varName "datatype" ;
                                  ] ;
                                sp:arg2 spin:_arg2 ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 spin:_arg2 ;
                                sp:arg2 rdfs:Literal ;
                              ] ;
                          ] ;
                        sp:arg2 [
                            a sp:and ;
                            sp:arg1 [
                                a sp:or ;
                                sp:arg1 [
                                    a sp:not ;
                                    sp:arg1 [
                                        a sp:bound ;
                                        sp:arg1 [
                                            sp:varName "datatype" ;
                                          ] ;
                                      ] ;
                                  ] ;
                                sp:arg2 [
                                    a sp:eq ;
                                    sp:arg1 rdf:langString ;
                                    sp:arg2 [
                                        sp:varName "datatype" ;
                                      ] ;
                                  ] ;
                              ] ;
                            sp:arg2 [
                                a sp:eq ;
                                sp:arg1 spin:_arg2 ;
                                sp:arg2 xsd:string ;
                              ] ;
                          ] ;
                      ] ;
                  ]
                )
              ) ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the instance being tested" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the type that the instance must have" ;
    ] ;
  spin:labelTemplate "{?arg1} instance of {?arg2}" ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given resource (?arg1) has a given type (?arg2). In order to fulfill this condition, there must either be a triple ?arg1 rdf:type ?arg2, or ?instance rdf:type ?subClass where ?subClass is a subclass of ?arg2. If the first argument is a literal, then the second argument must be the matching XSD datatype." ;
  rdfs:label "instanceOf" ;
  rdfs:subClassOf spl:BooleanFunctions ;
  owl:versionInfo "Note that in TopBraid this function has been implemented in native Java code, for performance reasons." ;
.
spl:isPrimaryKeyPropertyOfInstance
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spl:primaryKeyProperty ;
                arg:class [
                    sp:varName "type" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "pk" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    sp:varName "property" ;
                  ] ;
                sp:arg2 [
                    sp:varName "pk" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:instance ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The instance to check." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property that may or may not be the primary key." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given property is the primary key of a given instance." ;
  rdfs:label "is primary key property of instance" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:isUntypedLiteral
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:and ;
                sp:arg1 [
                    a sp:isLiteral ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 [
                    a sp:not ;
                    sp:arg1 [
                        a sp:sameTerm ;
                        sp:arg1 spin:_arg1 ;
                        sp:arg2 [
                            a xsd:string ;
                            sp:arg1 spin:_arg1 ;
                          ] ;
                      ] ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The literal to test." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given literal is untyped. This function was introduced because the built-in datatype operand in SPARQL casts untyped literals to xsd:string, making it impossible to check it this way. This function here uses a work-around using sameTerm instead." ;
  rdfs:label "isUntypedLiteral" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
spl:max
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:gt ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 spin:_arg2 ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The first argument." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The second argument." ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Takes two arguments and returns the larger one of them." ;
  rdfs:label "max" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
spl:maxCount
  a rdf:Property ;
  rdfs:subPropertyOf spl:count ;
.
spl:min
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:lt ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 spin:_arg2 ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The first argument." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The second argument." ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Takes two arguments and returns the smaller one of them." ;
  rdfs:label "min" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
spl:minCount
  a rdf:Property ;
  rdfs:subPropertyOf spl:count ;
.
spl:object
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the object from." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the object of." ;
    ] ;
  rdfs:comment """Gets the object of a given subject (?arg1) / predicate (?arg2) combination.

Note that if multiple values are present then the result might be unpredictably random. Furthermore, if one of the arguments is unbound, it will return the first match of the resulting SPO pattern. These scenarios are strongly discouraged but remain left supported for backward compatibility reasons.""" ;
  rdfs:label "object" ;
  rdfs:subClassOf spl:OntologyFunctions ;
  owl:versionInfo "Note that in TopBraid this function has been implemented in native Java code, for performance reasons." ;
.
spl:objectCount
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:Count ;
                sp:expression [
                    sp:varName "object" ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the subject to get the number of objects of" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property to get the number of values of" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the number of values of a given property (?arg2) at a given subject (?arg1). The result is the number of matches of (?arg1, ?arg2, ?object)." ;
  rdfs:label "objectCount" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:objectInGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "object" ;
                    ] ;
                  sp:predicate spin:_arg2 ;
                  sp:subject spin:_arg1 ;
                ]
              ) ;
            sp:graphNameNode spin:_arg3 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the object from." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the object of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to query in." ;
    ] ;
  rdfs:comment "Gets the object of a given subject (?arg1) / predicate (?arg2) combination in a given graph ?arg3. Note that if multiple values are present then the result might be unpredictably random." ;
  rdfs:label "object in graph" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:objectSubProp
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject [
                sp:varName "property" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "object" ;
              ] ;
            sp:predicate [
                sp:varName "property" ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject to get the object from." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the object of (including sub-properties of it)." ;
    ] ;
  rdfs:comment "Gets the object of a given subject (?arg1) / predicate (?arg2) combination, also taking the sub-properties of ?arg2 into account. Note that if multiple values are present then the result might be unpredictably random." ;
  rdfs:label "object sub prop" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:optional
  a rdf:Property ;
  rdfs:label "optional" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf sp:arg ;
.
spl:predicate
  a rdf:Property ;
  rdfs:label "predicate" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:primaryKeyProperty
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "property" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "constraint" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object spl:PrimaryKeyPropertyConstraint ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:predicate arg:property ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the primary key property declared for a given class, using spl:PrimaryKeyPropertyConstraint." ;
  rdfs:label "primary key property" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:primaryKeyURIStart
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "type" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "constraint" ;
              ] ;
            sp:predicate spin:constraint ;
            sp:subject [
                sp:varName "type" ;
              ] ;
          ]
          [
            sp:object spl:PrimaryKeyPropertyConstraint ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "result" ;
              ] ;
            sp:predicate arg:uriStart ;
            sp:subject [
                sp:varName "constraint" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the primary key of." ;
    ] ;
  spin:returnType rdf:Property ;
  rdfs:comment "Gets the URI start declared as part of a primary key declaration for a given class, using spl:PrimaryKeyPropertyConstraint." ;
  rdfs:label "primary key URI start" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:relevantPropertyAtClass
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:distinct true ;
      sp:resultVariables (
          [
            sp:varName "class" ;
          ]
        ) ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "superClass" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class" ;
              ] ;
          ]
          [
            a sp:Union ;
            sp:elements (
                (
                  [
                    sp:object [
                        sp:varName "superClass" ;
                      ] ;
                    sp:predicate rdfs:domain ;
                    sp:subject [
                        sp:varName "property" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "property" ;
                      ] ;
                    sp:predicate owl:onProperty ;
                    sp:subject [
                        sp:varName "superClass" ;
                      ] ;
                  ]
                )
                (
                  [
                    sp:object [
                        sp:varName "superClass" ;
                      ] ;
                    sp:predicate rdf:first ;
                    sp:subject [
                        sp:varName "listSegment" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "listSegment" ;
                      ] ;
                    sp:path [
                        a sp:ModPath ;
                        sp:modMax -2 ;
                        sp:modMin 0 ;
                        sp:subPath rdf:rest ;
                      ] ;
                    sp:subject [
                        sp:varName "list" ;
                      ] ;
                  ]
                  [
                    a sp:TriplePath ;
                    sp:object [
                        sp:varName "list" ;
                      ] ;
                    sp:path [
                        a sp:SeqPath ;
                        sp:path1 rdfs:domain ;
                        sp:path2 owl:unionOf ;
                      ] ;
                    sp:subject [
                        sp:varName "property" ;
                      ] ;
                  ]
                )
              ) ;
          ]
          [
            a sp:TriplePath ;
            sp:object [
                sp:varName "property" ;
              ] ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:or ;
                sp:arg1 [
                    a sp:eq ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 [
                        sp:varName "property" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a sp:notExists ;
                    sp:elements (
                        [
                          sp:object [
                              sp:varName "anyDomain" ;
                            ] ;
                          sp:predicate rdfs:domain ;
                          sp:subject spin:_arg1 ;
                        ]
                      ) ;
                  ] ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:isIRI ;
                sp:arg1 [
                    sp:varName "class" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property." ;
    ] ;
  spin:returnType rdfs:Class ;
  rdfs:comment """A magic property that establishes a relationship between properties (left) and classes (right) to determine which properties are \"relevant\" for the class. Relevant means that they have the class in their domain and/or restrictions, including superclasses and sub-properties (unless they define their own domain). Domains consisting of an owl:unionOf are also handled.

Note that the performance of the body of this magic property has been optimized for the case in which the class is given, so ideally use this for queries such as  ?property spl:relevantPropertyAtClass skos:Concept .""" ;
  rdfs:label "relevant property at class" ;
  rdfs:subClassOf spin:MagicProperties ;
.
spl:subClassOf
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The potential sub-class." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The potential super-class." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given class (?arg1) is a (transitive) sub-class of another class (?arg2)." ;
  rdfs:label "sub class of" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:subPropertyOf
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:TriplePath ;
            sp:object spin:_arg2 ;
            sp:path [
                a sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subPropertyOf ;
              ] ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The potential sub-property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The potential super-property." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given property (?arg1) is a (transitive) sub-property of another property (?arg2)." ;
  rdfs:label "sub property of" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:subject
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "subject" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg2 ;
            sp:predicate spin:_arg1 ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The object." ;
    ] ;
  rdfs:comment "Gets the \"first\" subject of a given predicate (?arg1)/object (?arg2) combination. Note that if multiple values are present then the result might be unpredictably random." ;
  rdfs:label "subject" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:subjectCount
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                a sp:Count ;
                sp:expression [
                    sp:varName "subject" ;
                  ] ;
              ] ;
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg2 ;
            sp:predicate spin:_arg1 ;
            sp:subject [
                sp:varName "subject" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the predicate to get the number of subjects of" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "the object to get the number of subjects of" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the number of values of a given property (?arg1) at a given object (?arg2). The result is the number of matches of (?subject, ?arg1, ?arg2)." ;
  rdfs:label "subjectCount" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:subjectInGraph
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "subject" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  sp:object spin:_arg2 ;
                  sp:predicate spin:_arg1 ;
                  sp:subject [
                      sp:varName "subject" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode spin:_arg3 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The object." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to operate on." ;
    ] ;
  rdfs:comment "Gets the \"first\" subject of a given predicate (?arg1)/object (?arg2) combination in a given graph (?arg3). Note that if multiple values are present then the result might be unpredictably random." ;
  rdfs:label "subject in graph" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
spl:testExpression
  a rdf:Property ;
  rdfs:label "test expression" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:testResult
  a rdf:Property ;
  rdfs:label "testResult" ;
  rdfs:subPropertyOf sp:arg ;
.
spl:valueType
  a rdf:Property ;
  rdfs:label "value type" ;
  rdfs:subPropertyOf sp:arg ;
.
<http://spinrdf.org/spr>
  a owl:Ontology ;
  rdfs:comment "A collection of SPIN functions that can be used to query, traverse and aggregate tabular data." ;
  rdfs:seeAlso <http://spinrdf.org/spr.html> ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:versionInfo "1.0.1" ;
.
spr:Aggregator
  a rdfs:Class ;
  rdfs:comment "A pair of SPARQL functions that can be used to aggregate values of a SPR table. Instances of this class can be passed into the various aggregateXY functions." ;
  rdfs:label "Aggregator" ;
  rdfs:subClassOf rdfs:Resource ;
.
spr:AggregatorFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Aggregator ;
      rdfs:comment "The aggregator to perform." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to iterate over." ;
    ] ;
  rdfs:label "Aggregator functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:AggregatorResultFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The end result after stepping through the values." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The total number of steps." ;
    ] ;
  rdfs:label "Aggregator result functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:AggregatorStepFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The old value to start with, e.g. 0 for SUM." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The current cell value that shall be aggregated on top of ?arg1." ;
    ] ;
  rdfs:label "Aggregator step functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:Avg
  a spr:Aggregator ;
  spr:resultFunction sp:divide ;
  spr:startValue "0"^^xsd:double ;
  spr:stepFunction sp:add ;
  rdfs:label "Avg" ;
.
spr:CellFunctions
  a spin:Function ;
  spin:abstract true ;
  rdfs:label "Cell functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:ColCountFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:TableClass ;
      rdfs:comment "The table to get the number of columns of." ;
    ] ;
  rdfs:label "Column count functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:ColNameFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The table to get the column name for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The column index, starting at zero." ;
    ] ;
  rdfs:label "Column name functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:ColTypeFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The table to get the column name for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The column index, starting at zero." ;
    ] ;
  rdfs:label "Column type functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:ColWidthFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The table to get the column name for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The column index, starting at zero." ;
    ] ;
  rdfs:label "Column width functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:Functions
  a spin:Function ;
  spin:abstract true ;
  rdfs:comment "Base class of various SPR related functions." ;
  rdfs:label "SPR Functions" ;
  rdfs:subClassOf spin:Functions ;
.
spr:MagicProperties
  a spin:MagicProperty ;
  spin:abstract true ;
  rdfs:label "Magic SPR properties" ;
  rdfs:subClassOf spin:MagicProperties ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:Product
  a spr:Aggregator ;
  spr:startValue "1"^^xsd:double ;
  spr:stepFunction sp:mul ;
  rdfs:label "Product" ;
.
spr:RowCountFunctions
  a spin:Function ;
  spin:abstract true ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to get the number of rows for." ;
    ] ;
  rdfs:label "Row count functions" ;
  rdfs:subClassOf spr:Functions ;
.
spr:Sum
  a spr:Aggregator ;
  spr:startValue "0"^^xsd:double ;
  spr:stepFunction sp:add ;
  rdfs:label "Sum" ;
.
spr:Table
  a spr:TableClass ;
  rdfs:comment "Base class of table classes. Must define the URIs of low-level SPARQL functions that are used by SPR to access individual table cells and table meta data." ;
  rdfs:label "Table" ;
  rdfs:subClassOf rdfs:Resource ;
.
spr:TableClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of classes that can represent tabular data. The classes that have this metaclass as their type need to specify SPARQL/SPIN functions for various look up tasks." ;
  rdfs:label "Table class" ;
  rdfs:subClassOf rdfs:Class ;
.
spr:aggregateCol
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "stepFunction" ;
              ] ;
            sp:predicate spr:stepFunction ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "startValue" ;
              ] ;
            sp:predicate spr:startValue ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "resultFunction" ;
                    ] ;
                  sp:predicate spr:resultFunction ;
                  sp:subject spin:_arg1 ;
                ]
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spr:rowCount ;
                sp:arg1 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "rowCount" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spr:visitCol ;
                sp:arg1 spin:_arg2 ;
                sp:arg2 spin:_arg3 ;
                sp:arg3 0 ;
                sp:arg4 [
                    a sp:sub ;
                    sp:arg1 [
                        sp:varName "rowCount" ;
                      ] ;
                    sp:arg2 1 ;
                  ] ;
                sp:arg5 [
                    sp:varName "stepFunction" ;
                  ] ;
                sp:arg6 [
                    sp:varName "startValue" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "stepped" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "resultFunction" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:invoke ;
                    sp:arg1 [
                        sp:varName "resultFunction" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "stepped" ;
                      ] ;
                    sp:arg3 [
                        sp:varName "rowCount" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "stepped" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The column index." ;
    ] ;
  rdfs:comment "Applies the spr:Aggregator ?arg1 to all rows of column ?arg3 of spr:Table ?arg2." ;
  rdfs:label "aggregate row" ;
  rdfs:subClassOf spr:AggregatorFunctions ;
.
spr:aggregateRow
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "stepFunction" ;
              ] ;
            sp:predicate spr:stepFunction ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "startValue" ;
              ] ;
            sp:predicate spr:startValue ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Optional ;
            sp:elements (
                [
                  sp:object [
                      sp:varName "resultFunction" ;
                    ] ;
                  sp:predicate spr:resultFunction ;
                  sp:subject spin:_arg1 ;
                ]
              ) ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spr:colCount ;
                sp:arg1 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "colCount" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spr:visitRow ;
                sp:arg1 spin:_arg2 ;
                sp:arg2 spin:_arg3 ;
                sp:arg3 0 ;
                sp:arg4 [
                    a sp:sub ;
                    sp:arg1 [
                        sp:varName "colCount" ;
                      ] ;
                    sp:arg2 1 ;
                  ] ;
                sp:arg5 [
                    sp:varName "stepFunction" ;
                  ] ;
                sp:arg6 [
                    sp:varName "startValue" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "stepped" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "resultFunction" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:invoke ;
                    sp:arg1 [
                        sp:varName "resultFunction" ;
                      ] ;
                    sp:arg2 [
                        sp:varName "stepped" ;
                      ] ;
                    sp:arg3 [
                        sp:varName "colCount" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "stepped" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The row index." ;
    ] ;
  rdfs:comment "Applies the spr:Aggregator ?arg1 to all columns of row ?arg3 of spr:Table ?arg2." ;
  rdfs:label "aggregate row" ;
  rdfs:subClassOf spr:AggregatorFunctions ;
.
spr:cell
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "tableClass" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "function" ;
              ] ;
            sp:predicate spr:cellFunction ;
            sp:subject [
                sp:varName "tableClass" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
                sp:arg4 spin:_arg3 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to get the cell value of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The row index, starting at 0." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The column index, starting at 0." ;
    ] ;
  rdfs:comment "Gets the cell value of a given Table (?arg1) at a given row (?arg2) and column (?arg3)." ;
  rdfs:label "cell" ;
  rdfs:subClassOf spr:CellFunctions ;
.
spr:cellFunction
  a rdf:Property ;
  rdfs:domain spr:TableClass ;
  rdfs:label "cell function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:colCells
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
          [
            sp:varName "row" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "row" ;
              ] ;
            sp:predicate spr:rowIndices ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spr:cell ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 [
                    sp:varName "row" ;
                  ] ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "value" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to get the values for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The column index, starting at zero." ;
    ] ;
  rdfs:comment "Iterates over all rows of a given table (left side, ?arg1) at column ?arg2 and binds the variable on the right with the cell values. The second variable on the right may be bound to the row index as well." ;
  rdfs:label "col cells" ;
  rdfs:subClassOf spr:MagicProperties ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:colCount
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "tableClass" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "function" ;
              ] ;
            sp:predicate spr:colCountFunction ;
            sp:subject [
                sp:varName "tableClass" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the number of columns of a given result set." ;
  rdfs:label "column count" ;
  rdfs:subClassOf spr:ColCountFunctions ;
.
spr:colCountBase
  spin:returnType xsd:integer ;
.
spr:colCountFunction
  a rdf:Property ;
  rdfs:domain spr:TableClass ;
  rdfs:label "colCount function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:colIndices
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "index" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:sub ;
                sp:arg1 [
                    a spr:colCount ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 1 ;
              ] ;
            sp:variable [
                sp:varName "lastIndex" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate <http://www.topbraid.org/tops#for> ;
            sp:subject [
                sp:varName "index" ;
              ] ;
          ]
          [
            sp:object 0 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "lastIndex" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to get the row indexes of." ;
    ] ;
  rdfs:comment "Iterates over all columns of a given table (left side, ?arg1) and binds the variable on the right with the index of the columns." ;
  rdfs:label "row indices" ;
  rdfs:subClassOf spr:MagicProperties ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:colName
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "tableClass" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "function" ;
              ] ;
            sp:predicate spr:colNameFunction ;
            sp:subject [
                sp:varName "tableClass" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the name of a column in a given result set. The name is usually derived from the variable name, but may also originate from spin:Columns attached to the table data provider." ;
  rdfs:label "column name" ;
  rdfs:subClassOf spr:ColNameFunctions ;
.
spr:colNameFunction
  a rdf:Property ;
  rdfs:domain spr:TableClass ;
  rdfs:label "colName function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:colType
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "tableClass" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "function" ;
              ] ;
            sp:predicate spr:colTypeFunction ;
            sp:subject [
                sp:varName "tableClass" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets the (data) type of a column, if this information is present. The datatype may be derived from spin:Columns attached to the table data provider." ;
  rdfs:label "column type" ;
  rdfs:subClassOf spr:ColTypeFunctions ;
.
spr:colTypeFunction
  a rdf:Property ;
  rdfs:domain spr:TableClass ;
  rdfs:label "colType function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:colWidth
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "tableClass" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "function" ;
              ] ;
            sp:predicate spr:colWidthFunction ;
            sp:subject [
                sp:varName "tableClass" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the width (in pixels) of a given column. This may have been derived from spin:Columns attached to the table data provider." ;
  rdfs:label "column width" ;
  rdfs:subClassOf spr:ColWidthFunctions ;
.
spr:colWidthFunction
  a rdf:Property ;
  rdfs:domain spr:TableClass ;
  rdfs:label "colWidth function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:colWithName
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "colIndex" ;
          ]
        ) ;
      sp:where (
          (
            [
              sp:object [
                  sp:varName "colIndex" ;
                ] ;
              sp:predicate spr:colIndices ;
              sp:subject spin:_arg1 ;
            ]
            [
              a sp:Bind ;
              sp:expression [
                  a spr:colName ;
                  sp:arg1 spin:_arg1 ;
                  sp:arg2 [
                      sp:varName "colIndex" ;
                    ] ;
                ] ;
              sp:variable [
                  sp:varName "colName" ;
                ] ;
            ]
          )
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    sp:varName "colName" ;
                  ] ;
                sp:arg2 spin:_arg2 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to iterate over." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the col to get." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the index of a column with a given name." ;
  rdfs:label "col with name" ;
  rdfs:subClassOf spr:Functions ;
.
spr:hasCell
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            sp:object [
                sp:varName "tableClass" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "function" ;
              ] ;
            sp:predicate spr:cellFunction ;
            sp:subject [
                sp:varName "tableClass" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 spin:_arg1 ;
                sp:arg3 spin:_arg2 ;
                sp:arg4 spin:_arg3 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "result" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to get the cell value of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The row index, starting at 0." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The column index, starting at 0." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if there is a cell value in a given Table (?arg1) at a given row (?arg2) and column (?arg3)." ;
  rdfs:label "hasCell" ;
  rdfs:subClassOf spr:CellFunctions ;
.
spr:isEmpty
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:eq ;
                sp:arg1 [
                    a spr:rowCount ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 0 ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given SPR table has zero rows." ;
  rdfs:label "is empty" ;
  rdfs:subClassOf spr:RowCountFunctions ;
.
spr:resultFunction
  a rdf:Property ;
  rdfs:comment "The URI of the SPIN Function that shall be called at the end of the steps." ;
  rdfs:domain spr:Aggregator ;
  rdfs:label "result function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:rowCells
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
          [
            sp:varName "col" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "col" ;
              ] ;
            sp:predicate spr:colIndices ;
            sp:subject spin:_arg1 ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spr:cell ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 spin:_arg2 ;
                sp:arg3 [
                    sp:varName "col" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "value" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to get the values for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The row index, starting at zero." ;
    ] ;
  rdfs:comment "Iterates over all columns of a given table (left side, ?arg1) at row ?arg2 and binds the variable on the right with the cell values. The second variable on the right may be bound to the column index as well." ;
  rdfs:label "row cells" ;
  rdfs:subClassOf spr:MagicProperties ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:rowCount
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "tableClass" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject spin:_arg1 ;
          ]
          [
            sp:object [
                sp:varName "function" ;
              ] ;
            sp:predicate spr:rowCountFunction ;
            sp:subject [
                sp:varName "tableClass" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spif:invoke ;
                sp:arg1 [
                    sp:varName "function" ;
                  ] ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the number of rows in a given table." ;
  rdfs:label "row count" ;
  rdfs:subClassOf spr:RowCountFunctions ;
.
spr:rowCountFunction
  a rdf:Property ;
  rdfs:domain spr:TableClass ;
  rdfs:label "rowCount function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:rowIndices
  a spin:MagicProperty ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "index" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:sub ;
                sp:arg1 [
                    a spr:rowCount ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 1 ;
              ] ;
            sp:variable [
                sp:varName "lastIndex" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?0" ;
              ] ;
            sp:predicate <http://www.topbraid.org/tops#for> ;
            sp:subject [
                sp:varName "index" ;
              ] ;
          ]
          [
            sp:object 0 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "lastIndex" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to get the row indexes of." ;
    ] ;
  rdfs:comment "Iterates over all rows of a given table (left side, ?arg1) and binds the variable on the right with the index of the rows." ;
  rdfs:label "row indices" ;
  rdfs:subClassOf spr:MagicProperties ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:startValue
  a rdf:Property ;
  rdfs:domain spr:Aggregator ;
  rdfs:label "start value" ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:stepFunction
  a rdf:Property ;
  rdfs:comment "The URI of the SPIN Function that shall be called at each step." ;
  rdfs:domain spr:Aggregator ;
  rdfs:label "step function" ;
  rdfs:range spin:Function ;
  rdfs:subPropertyOf spr:systemProperty ;
.
spr:systemProperty
  a rdf:Property ;
  rdfs:comment "An \"abstract\" base property that groups together those system properties that the user will hardly ever need to see in property trees. This property may be dropped in future versions of this ontology - right now it's mainly here for convenience." ;
  rdfs:label "system property" ;
.
spr:visitCol
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spr:cell ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 spin:_arg3 ;
                sp:arg3 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "value" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:invoke ;
                    sp:arg1 spin:_arg5 ;
                    sp:arg2 [
                        sp:varName "arg6" ;
                      ] ;
                    sp:arg3 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "arg6" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "next" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:lt ;
                    sp:arg1 spin:_arg3 ;
                    sp:arg2 spin:_arg4 ;
                  ] ;
                sp:arg2 [
                    a spr:visitCol ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 spin:_arg2 ;
                    sp:arg3 [
                        a sp:add ;
                        sp:arg1 spin:_arg3 ;
                        sp:arg2 1 ;
                      ] ;
                    sp:arg4 spin:_arg4 ;
                    sp:arg5 spin:_arg5 ;
                    sp:arg6 [
                        sp:varName "next" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "next" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to iterate over." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The row to iterate over." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The current step index." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The max number of steps to make." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg5 ;
      spl:valueType spin:Function ;
      rdfs:comment "The step function." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg6 ;
      rdfs:comment "The current aggregate value." ;
    ] ;
  rdfs:comment "Visits a given column ?arg2 of Table ?arg1 with a given spr:AggregatorStepFunction (?arg5) and then calls itself recursively until the last value index (?arg4) has been reached. ?arg6 is the result of the previous step." ;
  rdfs:label "visit row" ;
  rdfs:subClassOf spr:Functions ;
.
spr:visitRow
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a spr:cell ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 spin:_arg2 ;
                sp:arg3 spin:_arg3 ;
              ] ;
            sp:variable [
                sp:varName "value" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:bound ;
                    sp:arg1 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
                sp:arg2 [
                    a spif:invoke ;
                    sp:arg1 spin:_arg5 ;
                    sp:arg2 [
                        sp:varName "arg6" ;
                      ] ;
                    sp:arg3 [
                        sp:varName "value" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "arg6" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "next" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:lt ;
                    sp:arg1 [
                        a sp:add ;
                        sp:arg1 spin:_arg3 ;
                        sp:arg2 1 ;
                      ] ;
                    sp:arg2 spin:_arg4 ;
                  ] ;
                sp:arg2 [
                    a spr:visitRow ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 spin:_arg2 ;
                    sp:arg3 [
                        a sp:add ;
                        sp:arg1 spin:_arg3 ;
                        sp:arg2 1 ;
                      ] ;
                    sp:arg4 spin:_arg4 ;
                    sp:arg5 spin:_arg5 ;
                    sp:arg6 [
                        sp:varName "next" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "next" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spr:Table ;
      rdfs:comment "The spr:Table to iterate over." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The row to iterate over." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The current step index." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The max number of steps to make." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg5 ;
      spl:valueType spin:Function ;
      rdfs:comment "The step function." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg6 ;
      rdfs:comment "The current aggregate value." ;
    ] ;
  rdfs:comment "Visits a given row ?arg2 of Table ?arg1 with a given spr:AggregatorStepFunction (?arg5) and then calls itself recursively until the last value index (?arg4) has been reached. ?arg6 is the result of the previous step." ;
  rdfs:label "visit row" ;
  rdfs:subClassOf spr:Functions ;
.
<http://spinrdf.org/spra>
  a owl:Ontology ;
  rdfs:comment "An implementation of the SPR specification that stores table cells in URIs derived from the URI of the table. For example, if the spra:Table object has URI ex:MyTable, then the cells are called ex:MyTable-r1-c2 for column 2 and row 1." ;
  owl:imports <http://spinrdf.org/spr> ;
  owl:versionInfo "0.6.0" ;
.
spra:Table
  a spr:TableClass ;
  spr:cellFunction spra:cellFunction ;
  spr:colCountFunction spra:colCountFunction ;
  spr:colNameFunction spra:colNameFunction ;
  spr:rowCountFunction spra:rowCountFunction ;
  rdfs:label "Table" ;
  rdfs:subClassOf spr:Table ;
.
spra:cellFunction
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "value" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 [
                    a sp:str ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 "-r" ;
                sp:arg3 [
                    a sp:str ;
                    sp:arg1 spin:_arg2 ;
                  ] ;
                sp:arg4 "-c" ;
                sp:arg5 [
                    a sp:str ;
                    sp:arg1 spin:_arg3 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "cellURI" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    sp:varName "cellURI" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "cell" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spl:object ;
                sp:arg1 [
                    sp:varName "cell" ;
                  ] ;
                sp:arg2 spra:value ;
              ] ;
            sp:variable [
                sp:varName "value" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:label "cell function" ;
  rdfs:subClassOf spr:CellFunctions ;
.
spra:colCount
  a rdf:Property ;
  rdfs:domain spra:Table ;
  rdfs:label "col count" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf spra:systemProperty ;
.
spra:colCountFunction
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "colCount" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "colCount" ;
              ] ;
            sp:predicate spra:colCount ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:label "col count function" ;
  rdfs:subClassOf spr:ColCountFunctions ;
.
spra:colNameFunction
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "colName" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a sp:concat ;
                sp:arg1 "http://spinrdf.org/spra#colName" ;
                sp:arg2 [
                    a sp:str ;
                    sp:arg1 spin:_arg2 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "propertyURI" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:iri ;
                sp:arg1 [
                    sp:varName "propertyURI" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "property" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a spl:object ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 [
                    sp:varName "property" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "colName" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:label "col name function" ;
  rdfs:subClassOf spr:ColNameFunctions ;
.
spra:rowCount
  a rdf:Property ;
  rdfs:domain spra:Table ;
  rdfs:label "row count" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf spra:systemProperty ;
.
spra:rowCountFunction
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "rowCount" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "rowCount" ;
              ] ;
            sp:predicate spra:rowCount ;
            sp:subject spin:_arg1 ;
          ]
        ) ;
    ] ;
  spin:private true ;
  rdfs:label "row count function" ;
  rdfs:subClassOf spr:RowCountFunctions ;
.
spra:systemProperty
  a rdf:Property ;
  rdfs:comment "An \"abstract\" base property that groups together those system properties that the user will hardly ever need to see in property trees. This property may be dropped in future versions of this ontology - right now it's mainly here for convenience." ;
  rdfs:label "system property" ;
.
spra:value
  a rdf:Property ;
  rdfs:label "value" ;
  rdfs:subPropertyOf spra:systemProperty ;
.
<http://topbraid.org/email>
  a owl:Ontology ;
  owl:imports <http://www.topbraid.org/2007/05/composite.owl> ;
  owl:versionInfo "1.1.0" ;
.
email:Address
  a owl:Class ;
  rdfs:label "Address" ;
  rdfs:subClassOf owl:Thing ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty email:server ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:address ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:name ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:password ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:protocol ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:userName ;
    ] ;
.
email:Attachment
  a owl:Class ;
  rdfs:label "Attachment" ;
  rdfs:subClassOf owl:Thing ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty email:fileName ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:mimeType ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:size ;
    ] ;
.
email:Message
  a owl:Class ;
  rdfs:label "Message" ;
  rdfs:subClassOf owl:Thing ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:body ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:date ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:from ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:number ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:subject ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:minCardinality "0"^^xsd:int ;
      owl:onProperty email:attachment ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:minCardinality "0"^^xsd:int ;
      owl:onProperty email:bcc ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:minCardinality "0"^^xsd:int ;
      owl:onProperty email:cc ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:minCardinality "0"^^xsd:int ;
      owl:onProperty email:to ;
    ] ;
.
email:Server
  a owl:Class ;
  rdfs:comment "Connection metadata for an SMTP (outgoing) email server." ;
  rdfs:label "Server" ;
  rdfs:subClassOf owl:Thing ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:cardinality "1"^^xsd:int ;
      owl:onProperty email:server ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:password ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:port ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty email:userName ;
    ] ;
  rdfs:subClassOf [
      a owl:Restriction ;
      owl:maxCardinality "1"^^xsd:nonNegativeInteger ;
      owl:onProperty email:ssl ;
    ] ;
.
email:address
  a owl:DatatypeProperty ;
  rdfs:label "address" ;
  rdfs:range xsd:string ;
.
email:attachment
  a owl:ObjectProperty ;
  rdfs:comment "attachment filepath must comply with URI specification as defined by RFC 2396" ;
  rdfs:label "attachment" ;
  rdfs:range email:Attachment ;
  rdfs:subPropertyOf composite:child ;
.
email:bcc
  a owl:ObjectProperty ;
  rdfs:label "bcc" ;
  rdfs:range email:Address ;
.
email:body
  a owl:DatatypeProperty ;
  rdfs:label "body" ;
  rdfs:range xsd:string ;
.
email:cc
  a owl:ObjectProperty ;
  rdfs:label "cc" ;
  rdfs:range email:Address ;
.
email:date
  a owl:DatatypeProperty ;
  rdfs:label "date" ;
  rdfs:range xsd:dateTime ;
.
email:fileName
  a owl:DatatypeProperty ;
  rdfs:label "file name" ;
  rdfs:range xsd:string ;
.
email:from
  a owl:ObjectProperty ;
  rdfs:label "from" ;
  rdfs:range email:Address ;
.
email:mimeType
  a owl:DatatypeProperty ;
  rdfs:label "mime type" ;
  rdfs:range xsd:string ;
.
email:name
  a owl:DatatypeProperty ;
  rdfs:label "name" ;
  rdfs:range xsd:string ;
.
email:number
  a owl:DatatypeProperty ;
  rdfs:label "number" ;
  rdfs:range xsd:int ;
  rdfs:subPropertyOf composite:index ;
.
email:password
  a owl:DatatypeProperty ;
  rdfs:label "password" ;
  rdfs:range xsd:string ;
.
email:port
  a owl:DatatypeProperty ;
  rdfs:label "port" ;
  rdfs:range xsd:int ;
.
email:protocol
  a owl:DatatypeProperty ;
  rdfs:label "protocol" ;
  rdfs:range xsd:string ;
.
email:server
  a owl:DatatypeProperty ;
  rdfs:label "server" ;
  rdfs:range xsd:string ;
.
email:size
  a owl:DatatypeProperty ;
  rdfs:label "size" ;
  rdfs:range xsd:int ;
.
email:ssl
  a owl:DatatypeProperty ;
  rdfs:comment "Indicates whether the SSL protocol shall be used to connect to a server." ;
  rdfs:label "ssl" ;
  rdfs:range xsd:boolean ;
.
email:subject
  a owl:DatatypeProperty ;
  rdfs:comment "The subject of an email message" ;
  rdfs:label "subject" ;
  rdfs:range xsd:string ;
.
email:to
  a owl:ObjectProperty ;
  rdfs:label "to" ;
  rdfs:range email:Address ;
.
email:userName
  a owl:DatatypeProperty ;
  rdfs:label "user name" ;
  rdfs:range xsd:string ;
.
<http://topbraid.org/functions-afn>
  a owl:Ontology ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:versionInfo "1.0.0" ;
.
<http://topbraid.org/functions-fn>
  a owl:Ontology ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:versionInfo "1.1.1" ;
.
<http://topbraid.org/functions-smf>
  a owl:Ontology ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:versionInfo "1.3.0" ;
.
<http://topbraid.org/search>
  a owl:Ontology ;
  rdfs:comment "A schema that can be used to represent searches, e.g. as entered by the SWA search forms. A Search is a tree of blank nodes, with specific facet types for each value entered by the user." ;
  owl:imports <http://datashapes.org/dash> ;
  owl:imports <http://spinrdf.org/spin> ;
  owl:imports <http://www.w3.org/2004/02/skos/core> ;
.
search:AbstractSearch
  a rdfs:Class ;
  rdfs:comment "Shared base class of Search and NestedFacetValue. Both describe a single class (or variable) and share properties." ;
  rdfs:label "Abstract search" ;
  rdfs:subClassOf rdfs:Resource ;
.
search:AnyFacetValue
  a rdfs:Class ;
  rdfs:comment "Represents a filter condition in which the matching instance must have any value for the given facet - it doesn't matter which value but it must have at least one value." ;
  rdfs:label "Any facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:CardinalityFacetValue
  a rdfs:Class ;
  rdfs:comment "Represents a filter condition in which the matching instance must have a number of values within an interval specified by >= the given min value and <= the given max value. Either one of those may be empty." ;
  rdfs:label "Cardinality facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:ColumnType
  a rdfs:Class ;
  rdfs:label "Column type" ;
  rdfs:subClassOf rdfs:Resource ;
.
search:ConceptFacetValue
  a rdfs:Class ;
  rdfs:comment "Represents a filter condition in which the matching instance must have the given value (rootConcept) or a skos:Concept that is skos:narrower than that. For example, if someone enters \"Europe\" on a search form, then this would also match instances that have \"Liechtenstein\" as a value for the given facet." ;
  rdfs:label "Concept facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:ContainsStringFacetValue
  a rdfs:Class ;
  rdfs:label "Contains string facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:CountColumnType
  a search:ColumnType ;
  rdfs:label "Count column type" ;
.
search:DefaultSearch
  a search:Search ;
  search:rootType rdfs:Resource ;
  rdfs:comment "The default search configuration that shall be used for faceted search if no more detailed search has been specified in the class hierarchy." ;
  rdfs:label "Default search" ;
.
search:Facet
  a rdfs:Class ;
  rdfs:label "Facet" ;
  rdfs:subClassOf rdfs:Resource ;
.
search:FacetCount
  a rdfs:Class ;
  rdfs:comment "A single value-count pair as displayed as result of faceted search (example: Book (93))." ;
  rdfs:label "Facet count" ;
  rdfs:subClassOf rdfs:Resource ;
.
search:FacetValue
  a rdfs:Class ;
  rdfs:label "Facet value" ;
  rdfs:subClassOf rdfs:Resource ;
.
search:IntersectionSetFacetValue
  a rdfs:Class ;
  rdfs:label "Intersection set facet value" ;
  rdfs:subClassOf search:SetFacetValue ;
.
search:InversePropertyColumn
  a rdfs:Class ;
  rdfs:comment "A column backed by an InversePropertyFacet." ;
  rdfs:label "Inverse property column" ;
  rdfs:subClassOf search:SinglePropertyColumn ;
.
search:InversePropertyFacet
  a rdfs:Class ;
  rdfs:label "Inverse property facet" ;
  rdfs:subClassOf search:SinglePropertyFacet ;
.
search:LabelRegexFacetValue
  a rdfs:Class ;
  rdfs:comment "Represents a filter condition in which the matching instance must have values that have a label that contains the provided regular expression." ;
  rdfs:label "Label regex facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:NestedFacetValue
  a rdfs:Class ;
  rdfs:comment "A nested facet value is a pointer to another resource that may have additional filter criteria. The provided nestedSubjectVarName is matched with the subjectVarName of the Facets appearing as nested search conditions." ;
  rdfs:label "Nested facet value" ;
  rdfs:subClassOf search:AbstractSearch ;
  rdfs:subClassOf search:FacetValue ;
.
search:NoneFacetValue
  a rdfs:Class ;
  rdfs:comment "Represents a filter condition in which the matching instance must have no value for the given facet." ;
  rdfs:label "None facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:ObjectFacetValue
  a rdfs:Class ;
  rdfs:comment "Represents a filter condition in which the matching instance must have exactly the given object as a value for the facet." ;
  rdfs:label "Object facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:PropertiesUnionFacet
  a rdfs:Class ;
  rdfs:label "Properties union facet" ;
  rdfs:subClassOf search:Facet ;
.
search:PropertyColumn
  a rdfs:Class ;
  rdfs:comment "A column backed by a PropertyFacet." ;
  rdfs:label "Property column" ;
  rdfs:subClassOf search:SinglePropertyColumn ;
.
search:PropertyFacet
  a rdfs:Class ;
  rdfs:label "Property facet" ;
  rdfs:subClassOf search:SinglePropertyFacet ;
.
search:RangeFacetValue
  a rdfs:Class ;
  rdfs:comment "Represents a filter condition in which the matching instance must have values >= the given min value and <= the given max value. Either one of those may be empty." ;
  rdfs:label "Range facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:RegexFacetValue
  a rdfs:Class ;
  rdfs:comment "Represents a filter condition in which the matching instance must have values that match the provided regular expression, and (optionally) a language tag." ;
  rdfs:label "Regex facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:Search
  a rdfs:Class ;
  rdfs:comment "A Search represents information that can be sent to a search engine to perform a search. In a nutshell, a Search points to a collection of Facets, and each Facet may have a FacetValue. Facets that do not have FacetValues mean that the client is only interested in the counts of faceted search, while the actual FacetValues narrow down the result space." ;
  rdfs:label "Search" ;
  rdfs:subClassOf search:AbstractSearch ;
.
search:SearchResultsTestCase
  a rdfs:Class ;
  a sh:Shape ;
  rdfs:comment "A type of test cases that run a (stored) Search against a given query graph and compare the sets of result resources with those that are stored as \"expected\" resources with the test case." ;
  rdfs:label "Search results test case" ;
  rdfs:subClassOf dash:TestCase ;
  sh:property [
      sh:path dash:expectedResult ;
      sh:datatype xsd:string ;
      sh:description "Points at the expected JSON result set." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "expected result" ;
    ] ;
  sh:property [
      sh:path search:queryGraph ;
      sh:description "The graph being queried." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "query graph" ;
      sh:nodeKind sh:IRI ;
    ] ;
  sh:property [
      sh:path search:search ;
      sh:class search:Search ;
      sh:description "The search:Search to run." ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "search" ;
    ] ;
.
search:SetFacetValue
  a rdfs:Class ;
  rdfs:label "Set facet value" ;
  rdfs:subClassOf search:FacetValue ;
.
search:SinglePropertyColumn
  a rdfs:Class ;
  rdfs:label "Single property column" ;
  rdfs:subClassOf spin:Column ;
.
search:SinglePropertyFacet
  a rdfs:Class ;
  rdfs:label "Single property facet" ;
  rdfs:subClassOf search:Facet ;
.
search:Template
  a rdfs:Class ;
  rdfs:label "Template" ;
  rdfs:subClassOf spin:Module ;
  rdfs:subClassOf spin:TableDataProvider ;
.
search:UnionSetFacetValue
  a rdfs:Class ;
  rdfs:label "Union set facet value" ;
  rdfs:subClassOf search:SetFacetValue ;
.
search:body
  a rdf:Property ;
  rdfs:comment "Links a Search Template with a Search that can be used to create the executable query. The body Search may point to the argument variables of the Template anywhere, e.g. as value of search:object or search:max." ;
  rdfs:domain search:Template ;
  rdfs:label "body" ;
  rdfs:range search:Search ;
.
search:closed
  a rdf:Property ;
  rdfs:comment "If set to true then the user can not add new properties to the associated search:Search." ;
  rdfs:domain search:AbstractSearch ;
  rdfs:label "closed" ;
  rdfs:range xsd:boolean ;
.
search:columnProperty
  a rdf:Property ;
  rdfs:comment "Represents the property behind the values of the column." ;
  rdfs:domain search:SinglePropertyColumn ;
  rdfs:label "column property" ;
  rdfs:range rdf:Property ;
.
search:columnSubjectVarName
  a rdf:Property ;
  rdfs:domain search:SinglePropertyColumn ;
  rdfs:label "column subject var name" ;
  rdfs:range xsd:string ;
.
search:columnType
  a rdf:Property ;
  rdfs:comment "Can be set to search:CountColumnType to indicate that this is a COUNT aggregation column." ;
  rdfs:domain search:SinglePropertyColumn ;
  rdfs:label "column type" ;
  rdfs:range search:ColumnType ;
.
search:count
  a rdf:Property ;
  rdfs:domain search:FacetCount ;
  rdfs:label "count" ;
  rdfs:range xsd:integer ;
.
search:countValue
  a rdf:Property ;
  rdfs:domain search:FacetCount ;
  rdfs:label "count value" ;
.
search:creator
  a rdf:Property ;
  rdfs:domain search:Search ;
  rdfs:label "creator" ;
  rdfs:range rdfs:Resource ;
.
search:defaultSearch
  a rdf:Property ;
  rdfs:comment "Links a class with a Search instance that informs the search forms about its initial state, e.g. which key properties to select." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "default search" ;
  rdfs:range search:Search ;
.
search:directInstancesSearch
  a rdf:Property ;
  rdfs:comment "Indicates that the search shall be executed over direct instances of the root class only, i.e. instances of subclasses will be ignored if set to true." ;
  rdfs:domain search:AbstractSearch ;
  rdfs:label "direct instances search" ;
  rdfs:range xsd:boolean ;
.
search:excludedFacetProperty
  a rdf:Property ;
  rdfs:comment "Can point to rdf:Properties that shall not be available as choices when the user adds a property to a faceted search. This can be used to block properties that either do not make sense as facets (due to their value space) or may lead to significant performance issues if selected." ;
  rdfs:domain search:AbstractSearch ;
  rdfs:label "excluded facet property" ;
  rdfs:range rdf:Property ;
.
search:expanded
  a rdf:Property ;
  rdfs:comment "Indicates whether the facet shall be displayed as \"expanded\" in a faceted search UI. By default, facets are collapsed." ;
  rdfs:domain search:Facet ;
  rdfs:label "expanded" ;
  rdfs:range xsd:boolean ;
.
search:facet
  a rdf:Property ;
  rdfs:comment """Links a Search with a collection of Facets. The existence of a Facet means that the search engine shall return faceted results (counting of equal results) when run in faceted search mode. A Facet may also have FacetValues, in which case it means that a search condition is present.

Note that earlier versions of this ontology had this point from FacetValues to Facets, but the domain has been changed to Search since 4.3.""" ;
  rdfs:domain search:AbstractSearch ;
  rdfs:label "facet" ;
  rdfs:range search:Facet ;
.
search:facetCount
  a rdf:Property ;
  rdfs:comment "If this Search has been created as a result of a search execution, then a Facet may point to one or more FacetCounts that hold the numbers for each value." ;
  rdfs:domain search:Facet ;
  rdfs:label "facet count" ;
  rdfs:range search:FacetCount ;
.
search:facetIndex
  a rdf:Property ;
  rdfs:comment "An optional index that can be used to determine the ordering of facets on a screen. Values should be from 0 onwards, meaning that 0 will be placed on top of the screen." ;
  rdfs:domain search:Facet ;
  rdfs:label "facet index" ;
  rdfs:range xsd:integer ;
.
search:facetValue
  a rdf:Property ;
  rdfs:comment """Links a Facet with (at most one) FacetValue.

Note that earlier versions of this ontology had this point from the Search to multiple FacetValues. This has been changed since 4.3.""" ;
  rdfs:domain search:Facet ;
  rdfs:label "facet value" ;
  rdfs:range search:FacetValue ;
.
search:facetedSearch
  a rdf:Property ;
  rdfs:comment "Links a class with one or more faceted search configurations. Faceted search gadgets can walk up the class hierarchy to pick the most suitable faceted search for a given root class." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "faceted search" ;
  rdfs:range search:Search ;
.
search:inverseKeyProperty
  a owl:DeprecatedProperty ;
  rdfs:comment "Deprecated as of TopBraid 4.3: Use search:InversePropertyColumn via spin:column instead." ;
  rdfs:domain search:Search ;
  rdfs:label "inverse key property" ;
  rdfs:range rdf:Property ;
.
search:keyProperty
  a owl:DeprecatedProperty ;
  rdfs:comment "Deprecated as of TopBraid 4.3: Use search:PropertyColumn via spin:column instead." ;
  rdfs:domain search:Search ;
  rdfs:label "key property" ;
  rdfs:range rdf:Property ;
.
search:lang
  a rdf:Property ;
  rdfs:label "lang" ;
  rdfs:range xsd:string ;
.
search:local
  a rdf:Property ;
  rdfs:comment "True if this search should return the locally defined resources only, i.e. their rdf:type must be in the base graph of the current query graph." ;
  rdfs:domain search:Search ;
  rdfs:label "local" ;
  rdfs:range xsd:boolean ;
.
search:max
  a rdf:Property ;
  rdfs:domain search:RangeFacetValue ;
  rdfs:label "max" ;
.
search:maxCardinality
  a rdf:Property ;
  rdfs:domain search:CardinalityFacetValue ;
  rdfs:label "max cardinality" ;
  rdfs:range xsd:integer ;
.
search:min
  a rdf:Property ;
  rdfs:domain search:RangeFacetValue ;
  rdfs:label "min" ;
.
search:minCardinality
  a rdf:Property ;
  rdfs:domain search:CardinalityFacetValue ;
  rdfs:label "min cardinality" ;
  rdfs:range xsd:integer ;
.
search:nestedSubjectVarName
  a rdf:Property ;
  rdfs:domain search:NestedFacetValue ;
  rdfs:label "nested subject var name" ;
  rdfs:range xsd:string ;
.
search:object
  a rdf:Property ;
  rdfs:domain search:ObjectFacetValue ;
  rdfs:label "object" ;
.
search:pattern
  a rdf:Property ;
  rdfs:label "pattern" ;
  rdfs:range xsd:string ;
.
search:property
  a rdf:Property ;
  rdfs:domain search:SinglePropertyFacet ;
  rdfs:label "property" ;
  rdfs:range rdf:Property ;
.
search:queryGraph
  a rdf:Property ;
  rdfs:comment "The graph to execute the query over." ;
  rdfs:domain search:Search ;
  rdfs:label "query graph" ;
  rdfs:range rdfs:Resource ;
.
search:rootConcept
  a rdf:Property ;
  rdfs:domain search:ConceptFacetValue ;
  rdfs:label "root concept" ;
  rdfs:range skos:Concept ;
.
search:rootType
  a rdf:Property ;
  rdfs:comment "The class associated with the search - only instances of that class or its subclasses are valid matches." ;
  rdfs:domain search:AbstractSearch ;
  rdfs:label "root type" ;
  rdfs:range rdfs:Class ;
.
search:savedSearch
  a rdf:Property ;
  rdfs:comment "Links a class with one or more \"saved searches\". Saved searches are typically created by a user to remember the state of a search form." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "saved search" ;
  rdfs:range search:Search ;
.
search:search
  a rdf:Property ;
.
search:setObject
  a rdf:Property ;
  rdfs:domain search:SetFacetValue ;
  rdfs:label "set object" ;
.
search:string
  a rdf:Property ;
  rdfs:comment "A global query string for full text search." ;
  rdfs:domain search:Search ;
  rdfs:label "string" ;
  rdfs:range xsd:string ;
.
search:stringCaseSensitive
  a rdf:Property ;
  rdfs:comment "Can be set to interpret the search:string as case-sensitive  full text search." ;
  rdfs:domain search:Search ;
  rdfs:label "string case sensitive" ;
  rdfs:range xsd:boolean ;
.
search:subString
  a rdf:Property ;
  rdfs:comment "The string that must be contained in the matching values." ;
  rdfs:domain search:ContainsStringFacetValue ;
  rdfs:label "sub-string" ;
  rdfs:range xsd:string ;
.
search:subjectVarName
  a rdf:Property ;
  rdfs:domain search:Facet ;
  rdfs:label "subject var name" ;
  rdfs:range xsd:string ;
.
search:unionProperty
  a rdf:Property ;
  rdfs:domain search:PropertiesUnionFacet ;
  rdfs:label "union property" ;
  rdfs:range rdf:Property ;
.
search:widget
  a rdf:Property ;
  rdfs:domain search:FacetValue ;
  rdfs:label "widget" ;
  rdfs:range rdfs:Resource ;
.
<http://topbraid.org/sparqlmotion>
  a owl:Ontology ;
  rdfs:comment "Core ontology of SPARQLMotion: a declarative scripting language for Semantic Web technology. This ontology defines the basic building blocks of SPARQLMotion scripts. Scripts consist of modules, which are instances of (some subclass of) sm:Module. Modules can be chained together using sm:next and the sm:child properties." ;
  rdfs:seeAlso <http://sparqlmotion.org> ;
  owl:imports <http://spinrdf.org/spl> ;
  owl:versionInfo "2.3" ;
.
sm:CSV
  a sm:ValueType ;
  rdfs:label "CSV" ;
.
sm:Function
  a rdfs:Class ;
  rdfs:comment "A SPIN Function backed by a SPARQLMotion script. When the function is called, the body script will be executed. Can also be called as web service using a SM servlet container such as the TopBraid Live. An sm:Function must point to the end of the executing script via sm:returnModule. SPARQLMotion functions must not have side effects, e.g. sml:PerformUpdate is not permitted." ;
  rdfs:label "SPARQLMotion function" ;
  rdfs:subClassOf spin:Function ;
.
sm:Functions
  a sm:Function ;
  spin:abstract true ;
  rdfs:comment "An abstract superclass grouping together SPARQLMotion Functions." ;
  rdfs:label "Functions" ;
  rdfs:subClassOf spin:Functions ;
.
sm:JSON
  a sm:ValueType ;
  rdfs:label "JSON" ;
.
sm:Module
  a rdfs:Class ;
  rdfs:comment """The metaclass of SPARQLMotion modules. SPARQLMotion modules are SPIN Modules that can perform some arbitrary data processing task.
The instances of this metaclass define the input properties that are used to control the behavior. In order to declare a property, the following two SPIN templates must be used (attached to the class via spin:constraint):
- spl:Argument: this is the most common case for single-valued properties that are configured by the user. In addition to concrete RDF nodes, spl:Arguments can also point to a SPARQL SELECT query (sp:Select), a SPIN Template call, or a SPARQL expression. In those cases, the value of the property will be computed dynamically at execution time. The nested SPARQL expressions can access any pre-bound input variable.
- spl:Attribute: this should be used for any other value, such as SPARQL queries that drive the behavior of the module. No inline queries are supported for spl:Attributes.""" ;
  rdfs:label "Module" ;
  rdfs:subClassOf spin:Module ;
.
sm:Modules
  a rdfs:Class ;
  spin:abstract true ;
  spin:constructor [
      a spl:ConstructDefaultValues ;
    ] ;
  rdfs:comment "The abstract base class for the various types of SPARQLMotion data processing modules." ;
  rdfs:label "Modules" ;
  rdfs:subClassOf spin:Modules ;
.
sm:SIMPLE_JSON
  a sm:ValueType ;
  rdfs:label "SIMPLE JSON" ;
.
sm:SelectTemplates
  a spin:SelectTemplate ;
  spin:abstract true ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body script of the template. Will be executed for each row of the result set." ;
    ] ;
  rdfs:comment "Root class of SPARQLMotion modules that are based on SPIN templates. Subclasses of this should also have rdf:type sm:Module. The SPARQLMotion engine will execute the SELECT query specified as spin:body of the module and repeat the sm:body of the module in each iteration, with pre-bound variables for each binding in the result set row." ;
  rdfs:label "Select templates" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
sm:TSV
  a sm:ValueType ;
  rdfs:label "TSV" ;
.
sm:ValueType
  a rdfs:Class ;
  rdfs:comment "A value type such as XML or JSON." ;
  rdfs:label "value type" ;
  rdfs:subClassOf rdfs:Resource ;
.
sm:XML
  a sm:ValueType ;
  rdfs:label "XML" ;
.
sm:body
  a rdf:Property ;
  rdfs:comment "Links an iterator modules with its body, i.e. the start of a module chain that is executed as part of the loop." ;
  rdfs:label "body" ;
  rdfs:range spin:Modules ;
  rdfs:subPropertyOf sm:child ;
.
sm:child
  a rdf:Property ;
  rdfs:comment "Links a parent module with a child module that marks the start of a nested sub-script. This property is not meant to be used directly, but its primary function is to serve as superproperty of sm:body, sm:if and sm:else." ;
  rdfs:label "child" ;
  rdfs:range spin:Modules ;
.
sm:else
  a rdf:Property ;
  rdfs:comment "Links a branching module with its \"false\" branch, i.e. the branch that shall be executed if the condition is false." ;
  rdfs:label "else" ;
  rdfs:range spin:Modules ;
  rdfs:subPropertyOf sm:child ;
.
sm:icon
  a rdf:Property ;
  rdfs:comment "Can link a sm:Module subclass with an image URL so that the module can be displayed in visual editors. Images should be 48x48 pixels and in PNG, GIF or JPG format." ;
  rdfs:label "icon" ;
.
sm:if
  a rdf:Property ;
  rdfs:comment "Links a branching module with its \"true\" branch, i.e. the branch that shall be executed if the condition is true." ;
  rdfs:label "if" ;
  rdfs:range spin:Modules ;
  rdfs:subPropertyOf sm:child ;
.
sm:next
  a rdf:Property ;
  rdfs:comment "Links a source module (subject) with a target module (object), describing a chain of execution and evaluation." ;
  rdfs:domain spin:Modules ;
  rdfs:label "next" ;
  rdfs:range spin:Modules ;
.
sm:nodeX
  a rdf:Property ;
  rdfs:comment "The x coordinate of a module on a diagram." ;
  rdfs:label "node x" ;
  rdfs:range xsd:integer ;
.
sm:nodeY
  a rdf:Property ;
  rdfs:comment "The y coordinate of a module on a diagram." ;
  rdfs:label "node y" ;
  rdfs:range xsd:integer ;
.
sm:outputVariable
  a rdf:Property ;
  rdfs:comment "The name of the declared output variable of a module. This is typically used by modules to enable script users to bind the output of a module with matching variables in the target module." ;
  rdfs:label "outputVariable" ;
  rdfs:range xsd:string ;
.
sm:returnModule
  a rdf:Property ;
  rdfs:comment "Can be attached to user-defined SPARQLMotion functions to define the return module of the function's SPARQLMotion script. The result of the function will depend on the selected return module type." ;
  rdfs:domain spin:Function ;
  rdfs:label "return module" ;
  rdfs:range sm:Modules ;
.
sm:source
  a owl:AnnotationProperty ;
  rdfs:comment "Can be used to link a resource to the SPARQLMotion script that generated it. For example, if a file has been automatically generated by a SPARQLMotion script then the owl:Ontology in the resulting file should point back to the script, so that others can re-run the generation if the input data has changed." ;
  rdfs:label "source" ;
  rdfs:subPropertyOf rdfs:seeAlso ;
.
<http://topbraid.org/sparqlmotionfunctions>
  a owl:Ontology ;
  owl:imports <http://spinrdf.org/spif> ;
  owl:imports <http://topbraid.org/functions-afn> ;
  owl:imports <http://topbraid.org/functions-fn> ;
  owl:imports <http://topbraid.org/functions-smf> ;
  owl:versionInfo "2.0.0" ;
.
smf:Test-dbpedia-1
  a spl:TestCase ;
  spl:testExpression [
      a smf:dbpedia ;
      sp:arg1 "Dean Allemang" ;
    ] ;
  spl:testResult <http://dbpedia.org/resource/Dean_Allemang> ;
.
smf:Test-dbpedia-2
  a spl:TestCase ;
  spl:testExpression [
      a smf:dbpedia ;
      sp:arg1 "cycloyasi" ;
    ] ;
  spl:testResult false ;
.
smf:Test-dbpedia-3
  a spl:TestCase ;
  spl:testExpression [
      a smf:dbpedia ;
      sp:arg1 "Cyclone Yasi" ;
    ] ;
  spl:testResult <http://dbpedia.org/resource/Severe_Tropical_Cyclone_Yasi> ;
.
smf:applicableFamily
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The wildcard asset that was returned using smf:wildcardAsset." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """A magic property that can be used to walk through all applicable AssetFamilies for a WildCardAsset in the current TopBraid workspace.

Example usage:

	?wildcardAsset smf:applicableFamily ?family .
    
An unbound variable is required on the right hand side.  ?wildcardAsset can be bound to a wildcard asset which was returned from the smf:wildcardAsset magic property.""" ;
  rdfs:label "applicable family" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:asInternationalPhoneNumber
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The default country code, as an upper-case two letter abbreviation." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to check." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes the string of a phone number from a variety of formats, and an optional two-letter uppercase country code, and produces a \"normalized\" string using international conventions. Returns nothing if the phone number cannot be handled (use smf:isPhoneNumber beforehand)." ;
  rdfs:label "as international phone number" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:baseURI
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The path string, e.g. \"/MyProject/MyFolder/MyFile.rdf\"." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Returns the base URI (resource) of a given file (?arg1), where the file is specified as a path string relative to the workspace root. This function might be used in conjunction with tops:files." ;
  rdfs:label "base URI" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:buildString
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the template string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Constructs a new string by inserting the existing variable bindings into a template. The template can mention variable names in curly braces, such as \"Hello {?index}\" would create \"Hello 42\" is ?index has the value 42. As an alternative to variable names, the function can take additional arguments after the template, the variables of which can be accessed using {?1}, {?2} etc. For example: smf:buildString(\"Hello-{?1}-{?2}\", ?day, ?month) would insert day and month at places {?1} and {?2}.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:buildString.""" ;
  rdfs:label "buildString" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:buildStringFromRDFList
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "the separator to insert between each string" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:List ;
      rdfs:comment "the head of the rdf:List to convert to string" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the template string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Builds a string from the members of a given rdf:List (?arg1). The function iterates over all members of the list (which must be well-formed according to the RDF syntax rules). For each member, a string template (?arg2) is applied where the expression {?member} will be substituted with the current member. Optionally, a separator (?arg3) can be inserted between the list members in the result string, e.g. to insert a comma.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:buildStringFromRDFList.""" ;
  rdfs:label "buildStringFromRDFList" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:buildURI
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI template such as \"<http://my.com/Instance-{?index}>\". If the template contains a full URI, then it must be wrapped by <...>, otherwise the system will treat it as a qname." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """Constructs a new URI resource by inserting the existing variable bindings into a template. The template can mention variable names in curly braces, such as \"my:Instance-{?index}\" would create \"my:Instance-42\" is ?index has the value 42. As an alternative to variable names, the function can take additional arguments after the template, the variables of which can be accessed using {?1}, {?2} etc. For example: smf:buildURI(\"my:Instance-{?1}-{?2}\", ?day, ?month) would insert day and month at places {?1} and {?2}.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:buildURI.""" ;
  rdfs:label "buildURI" ;
  rdfs:subClassOf spl:URIFunctions ;
.
smf:buildUniqueURI
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI template such as \"<http://my.com/Instance-{?index}>\". If the template contains a full URI, then it must be wrapped by <...>, otherwise the system will treat it as a qname." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """A variation of smf:buildURI that also makes sure that the created URI is unique in the current graph (that is, no triple contains the URI as either subject, predicate or object). This function is particularly useful for ontology mapping from a legacy data source into an RDF model.

Deprecated: this function is now available as part of the TopBraid SPIN Libraries as spif:buildUniqueURI.""" ;
  rdfs:label "buildUniqueURI" ;
  rdfs:subClassOf spl:URIFunctions ;
.
smf:camelCase
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into camel case. 
For example, \"semantic web\" becomes \"SemanticWeb\".
An optional matching expression can be given to only convert the matched characters.

Deprecated: use spif:camelCase instead.""" ;
  rdfs:label "camelCase" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:canInvoke
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The first argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The second argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      rdfs:comment "The third argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg5 ;
      rdfs:comment "The forth argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spin:Function ;
      rdfs:comment "The function to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """Checks whether a given SPIN function (?arg1) can be invoked with a given list of argument (?arg2, ?arg3, ...) without violating any of its declared SPIN constraints. In addition to the usual argument declarations, the SPIN function may declare ASK and CONSTRUCT queries to check additional pre-conditions.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:canInvoke.""" ;
  rdfs:label "can invoke" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:canRead
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Graph base URI" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given graph can be read (by the current user)." ;
  rdfs:label "canRead" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:canWrite
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "Graph base URI" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given graph can be modified (by the current user)." ;
  rdfs:label "can write" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:cast
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The target datatype, e.g. xsd:integer. Leave blank for untyped literals." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the \"old\" literal that shall be converted" ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment """Creates a new literal from an existing literal, but with a different datatype. This can, for example, be used to convert between floating point values and int values.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:cast.""" ;
  rdfs:label "cast" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:checkCurrentUserRole
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:roleName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the role to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if current user belongs to a named role." ;
  rdfs:label "check if current user belongs to a role" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:configParam
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression [
                      a sp:iri ;
                      sp:arg1 [
                          a sp:concat ;
                          sp:arg1 "http://server.topbraidlive.org/web/2009/config#" ;
                          sp:arg2 [
                              sp:varName "param" ;
                            ] ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "predicate" ;
                    ] ;
                ]
                [
                  sp:object [
                      sp:varName "result" ;
                    ] ;
                  sp:predicate [
                      sp:varName "predicate" ;
                    ] ;
                  sp:subject <http://server.topbraidlive.org/dynamic/config#configuration> ;
                ]
              ) ;
            sp:graphNameNode <http://server.topbraidlive.org/dynamic/config> ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:param ;
      spl:valueType xsd:string ;
      rdfs:comment "The local name of the parameter property, e.g. \"smtpServer\" for <http://server.topbraidlive.org/web/2009/config#smtpServer>." ;
    ] ;
  rdfs:comment "Gets the value of a system configuration parameter from the dynamic config graph." ;
  rdfs:label "config param" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:convertRDFToText
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The optional serialization format of the output. By default, it is Turtle. This value should be an instance of \"sml:RDFSerialization\" from the sparqlmotionlib ontology, for example sml:RDFXML." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional pointer to the URI of a .context.json file - only used for JSON-LD." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Converts the current RDF graph to text. Optionally the serialization of the RDF graph as text can be given. By default, the serialization is Turtle." ;
  rdfs:label "convertRDFToText" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:convertSPINRDFToString
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "true to embed HTML markup into the output" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType sp:Query ;
      rdfs:comment "the root of the SPIN RDF query" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts a SPARQL query encoded in SPIN RDF format to a SPARQL string in textual form. The SPIN query must be well-formed in the context graph at execution time, and the provided argument must be the root of the expression (e.g., an instance of sp:Select).

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:convertSPINRDFToString.""" ;
  rdfs:label "convertSPINRDFToString" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:countMatches
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the subject in the match triple, or an unbound variable for a wildcard" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the predicate in the match triple, or an unbound variable for a wildcard" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "the object in the match triple, or an unbound variable for a wildcard" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment """Counts all occurrences of a triple pattern based on subject (?arg1), predicate (?arg2) and object (?arg3) input. Any of those can be unbound variables.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:countMatches.""" ;
  rdfs:label "countMatches" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:countResults
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the SPARQL select query string to execute" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Runs an nested SPARQL query and counts its results. Note that the nested query will reuse the variable bindings from its surrounding." ;
  rdfs:label "countResults" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:createARFF
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The shape defining the ARFF." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a SHACL shape and produces a Weka ARFF file as a string. The shape needs to declare sh:property constraints for each attribute. sh:maxCount 1 should be used for single-valued properties, otherwise the system will produce a new column/attribute for each value. The shape must declare a target, and all target nodes that conform to the shape will be turned into rows/instances in the ARFF file." ;
  rdfs:label "create ARFF" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:currentBaseURI
  a spin:Function ;
  spin:returnType owl:Ontology ;
  rdfs:comment "Gets the base URI of the current TopBraid session, as a URI resource. The current session is the currently open domain model of TBE or TBC. If used in SPARQLMotion scripts, this function may return the script's URI itself if executed within TBC, but the TBE session if executed from TBE." ;
  rdfs:label "current base URI" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:currentTimeMillis
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:returnType xsd:long ;
  rdfs:comment """Returns the current time in milliseconds. See System.currentTimeMillis() in Java.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:currentTimeMillis.""" ;
  rdfs:label "currentTimeMillis" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:currentUserAttribute
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:attributeName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the attribute to get (e.g. \"company\")." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets a named attribute of the user that is currently logged into TopBraid. The attribute name must be present in the selected user management system (e.g. LDAP), and typical values include \"company\" and \"mail\"." ;
  rdfs:label "current user attribute" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:currentUserName
  a spin:Function ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the name of the user that is currently logged into TopBraid. Should be preceeded by smf:hasCurrentUser to avoid exceptions." ;
  rdfs:label "current user name" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:dbpedia
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the label to get a DBpedia resource for" ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Attempts to get a DBPedia page for a string. Returns false if no matching DBPedia page could be found." ;
  rdfs:label "dbpedia" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:definedIn
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The input resource" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns the base URI of the ontology that the input resource is defined in. If the resource is defined in an unnamed graph (e.g., inference graph), then this function returns no value." ;
  rdfs:label "definedIn" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
smf:definedInFile
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The input resource" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns the workspace file path of the ontology that the input resource is defined in, if it exists." ;
  rdfs:label "definedInFile" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
smf:deriveURI
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          _:b9425
        ) ;
      sp:where (
          [
            a sp:Let ;
            sp:expression [
                a smf:resource ;
                sp:arg1 [
                    a fn:concat ;
                    sp:arg1 [
                        a xsd:string ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                    sp:arg2 spin:_arg2 ;
                  ] ;
              ] ;
            sp:variable _:b9425 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the URI resource that constitutes the left part of the new URI" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the additional string that will be appended to the right of {?arg1}" ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """Constructs a new URI resource by concatenating a string constant {?arg2} to the URI of a given resource {?arg1}. Example:

smf:deriveURI(owl:Thing, \"-Child\") = owl:Thing-Child""" ;
  rdfs:label "deriveURI" ;
  rdfs:subClassOf spl:URIFunctions ;
.
smf:duration
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The type of the duration: It can be one of: \"ms\", \"s\", \"m\", \"h\", \"d\", \"mon\", \"y\", \"c\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The begin date" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The end date" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Returns the duration between two dates in terms of one of the given \"types\". \"type\" is a string constant, which indicates the type of duration. It can be:
String value - Explanation
ms - milliseconds
s - seconds
m - minutes
h - hours
d - days
mon - months
y - years
c - centuries""" ;
  rdfs:label "duration" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:encodeURL
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "UTF-8" ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) encoding. Defaults to UTF-8." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to encode." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Encodes a URL string, for example so that it can be passed as an argument to REST services.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:encodeURL.""" ;
  rdfs:label "encode URL" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:escapeXML
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to escape." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Encodes a string so that it can be inserted into XML documents. Special characters will be converted." ;
  rdfs:label "escape XML" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:exec
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The command to execute." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Executes a named system command with an optional number of arguments. For example, on Windows you can call smf:exec(\"/my.bat\") to invoke a batch file in the root folder of your default hard drive. Note that \\ will be interpreted as an escape character - to insert a backslash, use \\\\ instead." ;
  rdfs:label "exec" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:file
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The base URI - either as string or a URI resource." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the absolute path to the workspace file holding a given base URI (?arg1)." ;
  rdfs:label "file" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:generateLabel
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment """An (optional) string template, that may include any of the following special commands:
- {date} inserts the current date
- {name} inserts the generated label
- {name:lower-case} inserts the label as lower case
- {name:upper-case} inserts the label as upper case
- {name:title-case} insert the label as title case
Any other characters will be inserted as they appear.""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "A URI resource or string literal that is used to generate a label. For URI resources, the local name will be used, the full string otherwise." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Can be used to derive a \"human-readable\" label from a resource URI or local name. For example, with the input ex:firstName this will return \"first name\". The result can then be used in the rest of the SPARQL query, e.g. to create an rdfs:label." ;
  rdfs:label "generate label" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:generateUUID
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:returnType xsd:string ;
  rdfs:comment """Generates a new unique ID as a string literal. This is often useful for creating \"random\" URIs and other identifiers.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:generateUUID.""" ;
  rdfs:label "generateUUID" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:geoCode
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "An (optional) country code such as \"au\" to aid the search." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The address as a raw string, e.g. \"1600 Amphitheatre Parkway, Mountain View, CA\"." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Attempts to convert a textual address (?arg1) into a comma-separated pair of lat/long values. The implementation currently uses the Google API (http://code.google.com/apis/maps/documentation/geocoding/) to do the actual work." ;
  rdfs:label "geo code" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:groupHasUser
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The group to get the users of." ;
    ] ;
  rdfs:comment """A magic property that can be used to walk through all available TBUsers for a permission group in the current TopBraid workspace.

Example usage:

    ?group smf:groupHasUser ?user .
    
An unbound variable is required on the right hand side.  ?group can be bound to a permission group which was returned from the pg:group magic property.""" ;
  rdfs:label "group has user" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:hasAllObjects
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the match subject" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the match predicate" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdf:List ;
      rdfs:comment "an rdf:List containing the match objects" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """Checks whether a given subject/predicate combination has all values enumerated from a given rdf:List. In other words, for each member ?object of the rdf:List, the triple (?arg1, ?arg2, ?object) must be in the model to return true. If the list is empty, true will also be returned.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:hasAllObjects.""" ;
  rdfs:label "hasAllObjects" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
smf:hasAsset
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The project, e.g. retrieved using smf:project." ;
    ] ;
  rdfs:comment """A magic property that can be used to walk through all available Assets and each Asset's AssetFamily for a project in the current TopBraid workspace.

Example usage:

    ?project smf:hasAsset (?asset ?family) .
    
A pair of unbound variables is required on the right hand side.  ?project can be bound to a project which was returned from the smf:project magic property.""" ;
  rdfs:label "has asset" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:hasBaseURI
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The path string, e.g. \"/MyProject/MyFolder/MyFile.rdf\"." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given file (?arg1) is known to have a base URI in the current workspace, where the file is specified as a path string relative to the workspace root. This function might be used in conjunction with tops:files." ;
  rdfs:label "has base URI" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:hasCurrentUser
  a spin:Function ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if there is a user that is currently logged into TopBraid." ;
  rdfs:label "has current user" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:hasFile
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The base URI - either as string or a URI resource." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if there is any workspace file holding a given base URI (?arg1)." ;
  rdfs:label "has file" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:hasLabelsPlugin
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The (blank) node for which the test is performed." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether there are any \"labels plugins\" for a given blank node. In the TopBraid platform, labels plugins provide special rendering of certain blank nodes. For example, OWL restrictions are rendered in Manchester Syntax." ;
  rdfs:label "has labels plugin" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
smf:htmlString
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Converts an input string to an HTML string - that is, special characters are converted." ;
  rdfs:label "htmlString" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:if
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "The condition that shall be evaluated. If true then return the ?arg2 argument, otherwise return ?arg3." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "the result if the condition is true" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "the result if the condition is false" ;
    ] ;
  rdfs:comment """Evaluates a condition and depending on the outcome either returns the true argument or the false argument. This is comparable to Java's ... ? ... : ... notation.

Note that SPARQL 1.1 introduces a built-in function IF with a very similar functionality. The only difference is that IF always requires three arguments, while smf:if can also be used with just two arguments. This case is equivalent to IF(?condition, ?trueCase, ?none) where ?none is an unbound variable.

As of TopBraid 5.2, smf:if has been deprecated and should no longer be used. Replace usages with IF.""" ;
  rdfs:label "if" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:importGraphCheck
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The graph to search for missing or duplicate imports." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """A magic property that can be used to find missing or duplicate imports given a base URI if no base URI is supplied the function will traverse all projects finding any missing or duplicate imports.

Example usage:
 
    ?projects smf:importGraphCheck ?results .  or  <http://baseUri/location> smf:importGraphCheck ?results .
    
An unbound variable is required on the right hand side.  ?projects can be assigned a base URI value if searching a specific graph.""" ;
  rdfs:label "missing or duplicate imports" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:indexOf
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The optional index to start with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the string to search in" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the sub string to search for" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment """Gets the index of the first occurrence of a certain substring in a given search string. Returns an error if the substring is not found.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:indexOf.""" ;
  rdfs:label "indexOf" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:invoke
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The first argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The second argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      rdfs:comment "The third argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg5 ;
      rdfs:comment "The forth argument of the function call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType spin:Function ;
      rdfs:comment "The URI resource defining the function to call." ;
    ] ;
  rdfs:comment """Calls another SPARQL function specified by a URI resource (?arg1), with additional arguments passed into from ?arg2 onwards. This can be used to dynamically call functions, the URI of which is now known statically. The result of the function call will be passed on as result of the invoke call.

The function can also be a binary built-in SPARQL function using the SPIN function identifiers from the SPL ontology. For example, sp:gt will be executed as ?left > ?right.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:invoke.""" ;
  rdfs:label "invoke" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:isBound
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the argument or variable to evaluate" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the input expression evaluates to a bound variable. This is similar to the built-in bound function of SPARQL, but bound expects a variable as argument and therefore can not be used to evaluate arbitrary nested functions." ;
  rdfs:label "isBound" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
smf:isCachedGraph
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph (URI resource) to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a given graph is cached. TopBraid applies a cache over all database graphs." ;
  rdfs:label "is cached graph" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:isDomainName
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to validate." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given string is a domain name as specified by RFC1034/RFC1123 and according to the IANA-recognized list of top-level domains (TLDs). Returns nothing if the provided argument is not a literal." ;
  rdfs:label "is domain name" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:isEmailAddress
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to validate." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given string is a valid Email address according to RFC 822 standards. Returns unbound if the given argument is not a literal." ;
  rdfs:label "is email address" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:isIndividualsGraph
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graphURI ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI of the graph to test." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment """Checks whether a given graph (contractually) only contains individuals, i.e. neither classes nor properties. This function does not actually look into the data, but currently assumes its result based on the following policies: In TBC-FE and SE, this always returns false. On the other platforms, it returns true for any graph under EVN/EDG teamwork control that is not an Ontology project (or of a similar asset type that declares teamwork:isOntologyProjectType=true.

Note: For working copies or graphs containing the user name, this function will not work and needs to be called against the master graph instead.""" ;
  rdfs:label "is individuals graph" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
smf:isLDAPConfigured
  a spin:Function ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Returns true if LDAP has been configured in the TBL server administration." ;
  rdfs:label "is LDAP configured" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:isPhoneNumber
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The default country code, as an upper-case two letter abbreviation." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given string is a valid phone number, possibly in the context of a given default country code." ;
  rdfs:label "is phone number" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:isTBL
  a spin:Function ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether the current working environment is TopBraid Live (stand-alone). False if we are in TopBraid Composer (including the personal server of Maestro Edition)." ;
  rdfs:label "is TBL" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:isURL
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:string ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given string is a well-formed URL by checking the scheme, authority, path, query, and fragment in turn." ;
  rdfs:label "is URL" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:isUserAccount
  a spin:Function ;
  spin:body [
      a sp:Ask ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a smf:userName ;
                sp:arg1 [
                    sp:varName "node" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "userName" ;
              ] ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:bound ;
                sp:arg1 [
                    sp:varName "userName" ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      rdfs:comment "The node to check." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given node represents a TopBraid user account (as produced by smf:userWithName)." ;
  rdfs:label "is user account" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:lastIndexOf
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The optional index to start with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the string to search in" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the sub string to search for" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment """Gets the index of the last occurrence of a certain substring in a given search string. Returns an error if the substring is not found.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:lastIndexOf.""" ;
  rdfs:label "lastIndexOf" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:lastModified
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      rdfs:comment "The URI of the graph to get the last modification of. May be a string or a URI resource." ;
    ] ;
  spin:returnType xsd:dateTime ;
  rdfs:comment "Gets the time stamp of last modification of the file associated with a given graph from the workspace." ;
  rdfs:label "last modified" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:levenshteinDistance
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The first string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The second string." ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Computes the Levenshtein Distance between two strings." ;
  rdfs:label "levenshtein distance" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:localRange
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the class to get the local range at" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property to get the range of" ;
    ] ;
  spin:returnType rdfs:Class ;
  rdfs:comment "Gets the local range of a property at a class. The function first checks for locally defined owl:allValuesFrom restrictions on the class or its superclasses. If none is found, it will try to use the global rdfs:range of the property. If this does not exist either, it will return rdfs:Resource." ;
  rdfs:label "localRange" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
smf:localSubjects
  a spin:MagicProperty ;
  rdfs:comment "If there is an unbound variable on the right hand side then this magic property assigns it to all subjects with a URI from the base graph of the current query graph (i.e. excluding those defined in imported sub-graphs). If there is a specific URI on the right hand side, the magic property checks whether that URI is a subject in the base graph." ;
  rdfs:label "local subjects" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:lowerCamelCase
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into lower camel case.
For example, \"semantic web\" becomes \"semanticWeb\".
An optional matching expression can be given to only convert the matched characters.

Deprecated: use spif:lowerCamelCase instead.""" ;
  rdfs:label "lowerCamelCase" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:lowerCase
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into lower case. 
For example, \"SEMANTIC Web\" becomes \"semantic web\".
An optional matching expression can be given to only convert the matched characters.

Deprecated: use spif:lowerCase instead.""" ;
  rdfs:label "lowerCase" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:lowerTitleCase
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into lower title case. 
For example, \"semantic web\" becomes \"semantic Web\".
An optional matching expression can be given to only convert the matched characters.

Deprecated: use spif:lowerTitleCase instead.""" ;
  rdfs:label "lowerTitleCase" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:luceneFacetQuery
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The limit.  If none provided the limit will default to 10." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment """The query string expression.
""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The list of applied facet filters." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The target property value." ;
    ] ;
  rdfs:comment """A magic property that can be used to query the available facets for 'Search the EDG' system index.

*This function is only available in TBC-ME and web products.*""" ;
  rdfs:label "lucene facet query" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:luceneQuery
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "A list of facet filters." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The offset. If none provided the offset will default to 0." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The limit.  If none provided the limit default to 100." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The query string expression." ;
    ] ;
  rdfs:comment """A magic property that can be used to query the 'Search the EDG' system index.

*This function is only available in TBC-ME and web products.*""" ;
  rdfs:label "lucene query" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:managedAssetsAndFamilies
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a group to get the available assets and asset families for." ;
    ] ;
  rdfs:comment """A magic property that can be used to walk through all available Assets and AssetFamilies for an asset permission group in the current TopBraid workspace.

Example usage:
 
     ?group smf:managedAssetsAndFamilies (?asset ?family) .
     
A pair of unbound variables is required on the right hand side.""" ;
  rdfs:label "managed assets and families" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:managedRole
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a group to get the roles of." ;
    ] ;
  rdfs:comment """A magic property that can be used to walk through all available roles for an asset permission group in the current TopBraid workspace.

Example usage:
 
    ?group smf:managedRole ?role .
    
An unbound variable is required on the right hand side.  ?group can be bound to a group which was returned from the smf:permissionGroup magic property.""" ;
  rdfs:label "managed role" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:maxCardinality
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the class to get the cardinality at" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property to get the cardinality of" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the maximum cardinality of a property at a class. The function checks for locally defined owl:maxCardinality restrictions on the class or its superclasses. If none is found, it will check if the property is functional and, if so, return 1. Otherwise it will return -1." ;
  rdfs:label "maxCardinality" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
smf:memberOf
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The role to get the groups of." ;
    ] ;
  rdfs:comment """A magic property that can be used to walk through all available Asset Permission Groups for a role in the current TopBraid workspace.

Example usage:

    ?role smf:memberOf ?group .
    
An unbound variable is required on the right hand side.  ?role can be bound to a role which was returned from the smf:role magic property.""" ;
  rdfs:label "member of" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:minCardinality
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "the class to get the minimum cardinality at" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "the property to get the cardinality of" ;
    ] ;
  spin:returnType xsd:integer ;
  rdfs:comment "Gets the minimum cardinality of a property at a class. The function checks for locally defined owl:minCardinality restrictions on the class or its superclasses. If none is found, it will return 0." ;
  rdfs:label "minCardinality" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
smf:name
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "the node (literal or resource) that shall be rendered into a string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Gets a human-readable string representation from an RDF node. If it's a literal, the function will return the literal's lexical text. If it's a resource the system will use the rdfs:label (if exists) or otherwise use the qname. For an unbound input, the function will return no value. 

Deprecated: use spif:name instead.""" ;
  rdfs:label "name" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:notManagedBy
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The role to get the unassociated groups of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """A magic property that can be used to walk through all available groups not currently associated with a specified role in the current TopBraid workspace.

Example usage:
 
    ?role smf:notManagedBy ?group .
    
An unbound variable is required on the right hand side.  ?role can be bound to a role which was returned from the smf:role magic property.""" ;
  rdfs:label "not managed by" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:parseDate
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:pattern ;
      spl:valueType xsd:string ;
      rdfs:comment "The template of the input string. This must conform to the pattern language implemented by the Java SimpleDateFormat class (http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input text" ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment """Converts a string in a semi-structured format into a xsd:date, xsd:dateTime or xsd:time literal. The input string must be in a given template format, e.g. \"yyyy.MM.dd G 'at' HH:mm:ss z\" for strings such as 2001.07.04 AD at 12:08:56 PDT.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:parseDate.""" ;
  rdfs:label "parseDate" ;
  rdfs:subClassOf spl:DateFunctions ;
.
smf:parseManchesterSyntax
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to parse." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Attempts to parse a string in OWL Manchester Syntax and returns an error string if something went wrong. Returns nothing (unbound) if the string could be parsed against the current query graph." ;
  rdfs:label "parse Manchester Syntax" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:permissionGroup
  a spin:MagicProperty ;
  spin:returnType xsd:string ;
  rdfs:comment """A magic property that can be used to walk through all available Asset Permission Groups for the current TopBraid workspace.

Example usage:

    () smf:permissionGroup ?group .
    
An unbound variable is required on the right hand side.""" ;
  rdfs:label "permission group" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:permissionsForAsset
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The group to get the permissions for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The asset to get the permissions of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "The asset family of the asset to get the permissions of." ;
    ] ;
  rdfs:comment """A magic property that can be used to walk through all available Permissions for an Asset in a group in the current TopBraid workspace.

Example usage:

    (?group ?assetId ?family) smf:permissionsForAsset ?permission
  or
    (?group ?assetId) smf:permissionsForAsset ?permission
    
An unbound variable is required on the right hand side.  If ?family is not
specified, then the GRAPH asset family will be assumed.""" ;
  rdfs:label "permissions for asset" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:prefix
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          _:b22060
        ) ;
      sp:where (
          [
            a sp:Let ;
            sp:expression [
                a smf:qname ;
                sp:arg1 spin:_arg1 ;
              ] ;
            sp:variable _:b88089 ;
          ]
          [
            a sp:Filter ;
            sp:expression [
                a sp:not ;
                sp:arg1 [
                    a fn:starts-with ;
                    sp:arg1 _:b88089 ;
                    sp:arg2 "<" ;
                  ] ;
              ] ;
          ]
          [
            a sp:Let ;
            sp:expression [
                a smf:indexOf ;
                sp:arg1 _:b88089 ;
                sp:arg2 ":" ;
              ] ;
            sp:variable _:b81418 ;
          ]
          [
            a sp:Let ;
            sp:expression [
                a afn:substr ;
                sp:arg1 _:b88089 ;
                sp:arg2 0 ;
                sp:arg3 _:b81418 ;
              ] ;
            sp:variable _:b22060 ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the prefix of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the prefix of a given resource (?arg1). Returns nothing if the argument is a URI that cannot be abbreviated with a prefix." ;
  rdfs:label "prefix" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:project
  a spin:MagicProperty ;
  spin:returnType xsd:string ;
  rdfs:comment """A magic property that can be used to walk through all known projects for the current TopBraid workspace.

Example usage:
 
     () smf:project ?project .
     
An unbound variable is required on the right hand side.""" ;
  rdfs:label "project" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:qname
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "the URI resource to get the qname of" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the qname of a resource, using the defined namespace abbreviations. In contrast to the official specs, this function will drop the : character if it's the first character in the string. If the resource does not have a suitable prefix abbreviation, the function will return the URI wrapped by <...>." ;
  rdfs:label "qname" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:random
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:returnType xsd:double ;
  rdfs:comment """Creates a random xsd:double between 0 and 1.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:random.""" ;
  rdfs:label "random" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
smf:regex
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:string ;
      rdfs:comment "The optional string returned as result string if no match occurs. If this string is empty and no match occurs, then the result string is unbound." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "The replacement expression" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """An input string is converted into a result string by applying a match and replacement expressions.
For example, the input string \"semantic web\" with the match expression \"([A-z]+) ([A-z]+)\" and the replacement expression \"The $1 life\" returns the string \"The semantic life\".
An optional input string is returned, if no match occurs. If this string is empty and no match occurs, then the result string is unbound.

Deprecated: use spif:regex instead.""" ;
  rdfs:label "regex" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:replaceAll
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to operate on." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The regular expression to search for." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "The replacement string." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Does a string replacement based on the Java function String.replaceAll().

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:replaceAll.""" ;
  rdfs:label "replace all" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:resetCachedGraph
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph (URI resource) to reset." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Resets a given cached graph. This can be used to force a refresh of a TopBraid graph if the underlying database has been changed outside of TopBraid." ;
  rdfs:label "reset cached graph" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:resource
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the URI to convert" ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Converts a given URI string to an RDF resource with that URI. As of SPARQL 1.1, this function is no longer needed and can be substituted with IRI(?string)." ;
  rdfs:label "resource" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:role
  a spin:MagicProperty ;
  spin:returnType xsd:string ;
  rdfs:comment """A magic property that can be used to walk through all available Roles for the current TopBraid workspace.

Example usage:

    () smf:role ?role .
    
An unbound variable is required on the right hand side.""" ;
  rdfs:label "role" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:roleHasUser
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The role to get the users of." ;
    ] ;
  rdfs:comment """A magic property that can be used to walk through all available TBUsers for a role in the current TopBraid workspace.

Example usage:

    ?role smf:roleHasUser ?user .
    
An unbound variable is required on the right hand side.  ?role can be bound to a role which was returned from the pg:role magic property.""" ;
  rdfs:label "role has user" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:rootURISubject
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to find the reference to." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Takes a resource (usually a blank node) as argument and finds a URI resource that is the root of a blank node tree that contains the blank node. For example, if there is a blank node inside of a SPIN RDF structure that is linked to a class via spin:rule, then this function will return the class that points to the root of the SPIN RDF structure. Another example is OWL expressions such as owl:Restrictions." ;
  rdfs:label "root URI subject" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
smf:setLanguage
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:language ;
      spl:valueType xsd:string ;
      rdfs:comment "the language of the result literal; may be empty to delete any existing language" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the text to set the language of" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates a new string literal with a given language from an existing value. For example, smf:setLanguage(\"House\", \"en\") becomes \"House\"@en." ;
  rdfs:label "setLanguage" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:splitTextFile
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The index of the first record to return, starting with 1." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg4 ;
      spl:valueType xsd:integer ;
      rdfs:comment "The maximum number of records to return. May be left blank to get all entries." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The absolute path to the text file in the workspace (e.g., /myProject/myFolder/test.txt)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The delimiter string, for example \",\" for comma-separated lists." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Can be used to split a file into multiple sub-strings separated based on a delimiter from a start record to the end record.

For example,

    (\"/myProject/myfile.txt\" \"\\\\n\"  1 10) smf:splitTextFile ?result

will open the file with the given absolute path, split its content for every new line, and return the first 10 entries starting with first one. An unbound variable must be placed on the right hand side of this magic property.""" ;
  rdfs:label "split text file" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:subGraph
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The base graph to get the subgraphs of." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Can be used to query all named subgraphs of a given (SDB) graph. For example, http://example.org/graph/mysub is a subgraph of http://example.org/graph. The magic property only works if the base graph is given." ;
  rdfs:label "sub graph" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:subString
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:fromIndex ;
      spl:valueType xsd:integer ;
      rdfs:comment "the start index (0 is the first character); if not bound, then the function will return null" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:toIndex ;
      spl:valueType xsd:integer ;
      rdfs:comment "the end index; if not bound, use the length of text - 1" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Extracts a substring from an input string. This is similar to afn:substr but more robust against null values." ;
  rdfs:label "subString" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:titleCase
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string to title case.
For example, \"germany\" becomes \"Germany\".
An optional matching expression can be given to only convert the matched characters.

Deprecated: use spif:titleCase instead.""" ;
  rdfs:label "titleCase" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:trace
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the template string to print" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Same as smf:buildString, but with the side effect of printing the string into TopBraid's Error Log. This can be used as a debugging aid. The result of the function is the evaluated template.

You can control the log level by prefixing the template string with either of the following:
- \"INFO:\" will record an info item in the log (default)
- \"WARN:\" will record a warning in the log
- \"ERROR:\" will actually throw and report an exeception

For example: smf:trace(\"WARN: The value of {?1} is invalid\", -10) will log a warning \"smf:trace: The value of -10 is invalid\".""" ;
  rdfs:label "trace" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:trim
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the text to trim" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Creates a new string value by trimming an input string. Leading and trailing whitespaces are deleted.

Deprecated: this function is available as part of the TopBraid SPIN Libraries as spif:trim.""" ;
  rdfs:label "trim" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:tripleDefinedIn
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The subject of the triple." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the triple." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg3 ;
      rdfs:comment "The object of the triple." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Returns the IRI of the subgraph that a given triple (subject, predicate, object) has been defined in. This is supported for graphs that are known to TopBraid's graph registry only, including union graphs such as those created with ui:graphWithImports." ;
  rdfs:label "triple defined in" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
smf:turtleString
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      rdfs:comment "The RDF node to render into Turtle." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns a Turtle (source code) representation of a given RDF node, using the prefixes from the current query graph. For blank nodes this includes depending triples, for URIs and literals just the single value rendering." ;
  rdfs:label "turtle string" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:unmanagedRole
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The group to get the unavailable roles." ;
    ] ;
  rdfs:comment """A magic property that can be used to walk through all available roles not currently associated with a specified asset permission group in the current TopBraid workspace.

Example usage:

    ?group smf:unmanagedRole ?role .
     
An unbound variable is required on the right hand side.  ?group can be bound to a group which was returned from the smf:permissionGroup magic property.""" ;
  rdfs:label "unmanaged role" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:upperCase
  a spin:Function ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The match expression" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The input string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Converts an input string into upper case. 
For example, \"semantic web\" becomes \"SEMANTIC WEB\".
An optional matching expression can be given to only convert the matched characters.

Deprecated: use spif:upperCase instead.""" ;
  rdfs:label "upperCase" ;
  rdfs:subClassOf spl:StringFunctions ;
.
smf:user
  a spin:MagicProperty ;
  spin:returnType rdfs:Resource ;
  rdfs:comment """A magic property that can be used to walk through all available users in the current TopBraid workspace.

Example usage:

    () smf:user ?user .
    
An unbound variable is required on the right hand side.""" ;
  rdfs:label "user" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:userDisplayName
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:user ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI node of the user." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the display name of a user with a given URI (of the form urn:x-tb-users:XY). Note that the result of this can not necessarily be used as input to smf:userwithName, because the display name may be different from the internal user name." ;
  rdfs:label "user display name" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:userEmail
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:user ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI node of the user." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the email address associated with a user with a given URI (of the form urn:x-tb-users:XY). This could be retrieved from the LDAP directory, or from any property with local name \"email\" in the users.ttl file, or from the property edg:email in the active query graph." ;
  rdfs:label "user email" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:userName
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The user resource to convert to a name." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Converts a user URI resource into a user name. Returns nothing if the given node is not a URI that follows the URI naming pattern used by TopBraid. The inverse function is smf:userWithName." ;
  rdfs:label "user name" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:userRole
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The user resource." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "This magic property requires a user resource on the left hand and an unbound variable on the right. This variable will contain the URIs of the security roles (e.g. LDAP) that the given user is known to have." ;
  rdfs:label "user role" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:userWithName
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name to convert to a resource." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Converts a user name into a URI resource, following the default settings in TopBraid. Often used in conjunction with smf:currentUserName(). The inverse function is smf:userName." ;
  rdfs:label "user with name" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:wekaClassifiers
  a spin:MagicProperty ;
  spin:returnType xsd:string ;
  rdfs:comment """Gets the keys of all Weka classifiers that are currently on the configured Maui server. Usually they will have been created using sml:CreateWekaClassifier, but they may still be around from a previous run of a TopBraid product. The magic property takes nothing on the left hand side and needs an unbound variable on the right hand side, e.g.

() smf:wekaClassifiers ?key .""" ;
  rdfs:label "Weka classifiers" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:wekaClassify
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:key ;
      spl:valueType xsd:string ;
      rdfs:comment "The key of the Weka classifier. Must be the same as the sml:key used in sml:CreateWekaClassifier." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to classify." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:shape ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The shape defining which properties/paths have to be sent to the Weka engine." ;
    ] ;
  rdfs:comment "Classifies a given resource via Weka. The classifier must be executing on the configured Maui server, typically created in a previous step using sml:CreateWekaClassifier. This function here uses the trained Weka classifier to produce a suggestion for the property/path that has been specified when the classifier was created." ;
  rdfs:label "Weka classify" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
smf:wildcardAsset
  a spin:MagicProperty ;
  rdfs:comment """A magic property that can be used to walk through all available WildCardAssets for the current TopBraid workspace.

Example usage:
 
    () smf:wildcardAsset (?wildcardAsset ?family)

A pair of unbound variables is required on the right hand side.""" ;
  rdfs:label "wildcard asset" ;
  rdfs:subClassOf spin:MagicProperties ;
.
smf:workspacePath
  a spin:Function ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the absolute path of the workspace in the local hard disk." ;
  rdfs:label "workspace path" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
<http://topbraid.org/sparqlmotionlib>
  a owl:Ontology ;
  rdfs:comment "An umbrella file that imports all of TopBraid's SPARQLMotion modules." ;
  owl:imports <http://topbraid.org/sparqlmotionlib-tb> ;
  owl:versionInfo "2.2.4" ;
.
sml:AddGraph
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:uri ;
      spl:valueType xsd:string ;
      rdfs:comment "The URI of the graph to add the triples to." ;
    ] ;
  rdfs:comment "Performs a bulk update in which all triples from the input graph are added to a given named graph." ;
  rdfs:label "Add graph" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:AddUserDictionaryWord
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:word ;
      spl:valueType xsd:string ;
      rdfs:comment "The word to add." ;
    ] ;
  rdfs:comment "Adds a given word to the user dictionary used for spell-checking (see sml:CheckSpelling)." ;
  rdfs:label "Add user dictionary word" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:AppendText
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sml:variable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable to append to." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:template ;
      spl:valueType xsd:string ;
      rdfs:comment "The (template) string to append to the variable value." ;
    ] ;
  rdfs:comment "Appends a given text (possibly containing template expressions, sml:template) to the value of a given variable (sml:variable) and binds the concatenation of the old value plus the new text to the same variable. This can be used to incrementally build up a string." ;
  rdfs:label "Append text" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ApplyConstruct
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      rdfs:comment "If set to true, the output triples will only contain the constructed triples. If no values or false are specified, the output will be the union of the input triples and the constructed triples." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:minCount 1 ;
      spl:predicate sml:constructQuery ;
      rdfs:comment "The SPARQL Construct queries that deliver the triples that shall be added." ;
    ] ;
  rdfs:comment "Runs one or more SPARQL Construct queries on the input triples. The output RDF will consist of the constructed triples and (unless sml:replace is true) the input triples." ;
  rdfs:label "Apply Construct" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ApplyResourceConstructors
  a sm:Module ;
  a owl:DeprecatedClass ;
  rdfs:comment """DEPRECATED: as of TopBraid 6.1 this module should no longer be used, and customers are encouraged to use SHACL rules.

Executes all spin:constructors for the instances in the input graph, and returns the union of the constructed triples and the input graph.""" ;
  rdfs:label "Apply resource constructors" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ApplySHACLRules
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:focusNode ;
      rdfs:comment "If specified then only those rules will be executed that are attached to shapes that target the given focus node. Only the inferences for that focus node will be produced." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies whether the resulting inferred triples shall replace the input. If false, the union of inferred triples and old triples are returned." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:shapesGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional shapes graph, defaults to the input graph." ;
    ] ;
  rdfs:comment "Applies the SHACL rules inference engine on the input graph. This assumes that the input graph (or, if provided, the given shapes graph) contains one or more SHACL rules. The output graph is by default the union of the input graph plus the inferred triples, unless sml:replace is set to true." ;
  rdfs:label "Apply SHACL rules" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ApplyTopSPIN
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue spin:rule ;
      spl:optional true ;
      spl:predicate sml:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the rules from. Usually spin:rule, but can be any SPIN property (subPropertyOf spin:query)" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:flatten ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, the engine will copy all input triples into a single in-memory graph, and then operate on that (faster) graph. In some cases, this option has improved performance by a factor of 8. Note that this option may not make sense if one of the input graphs is a (large) database. Setting this option to true will also lead to ignore the value of sml:replace, and only the flattened graph will be forwarded into the next steps of the script (i.e. sml:replace=true)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies whether the resulting inferred triples shall replace the input. If false, the union of inferred triples and old triples are returned. Note that this flag is not supported if sml:flatten = true." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:singlePass ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies whether only a single pass over all rules shall be made. By default (false), TopSPIN will iterate until no further inferences have been made." ;
    ] ;
  rdfs:comment "Applies the TopSPIN rules inference engine on the input graph. This assumes that the input graph contains one or more SPIN rules (stored using the property specified under sml:predicate, which defaults to spin:rule)." ;
  rdfs:label "Apply TopSPIN" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:AssertTrue
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "the error message" ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:askQuery ;
      spl:valueType sp:Ask ;
      rdfs:comment "The ASK query that must return true." ;
    ] ;
  rdfs:comment "Evaluates an ASK condition and stops the execution of the script and reports an error if the condition is false. This module is particularly useful for web services that simply cannot execute if unexpected situations are encountered. The module will simply pass through all variable bindings and RDF triples if no errors are found." ;
  rdfs:label "Assert true" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BindBySelect
  a sm:Module ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:selectQuery ;
      rdfs:comment "A SPARQL Select query that is executed over the input triples. The result variables of the first result row will be bound in the succeeding modules." ;
    ] ;
  rdfs:comment "Runs a SPARQL select query and binds all result variables of the first matching result set. The input RDF is simply passed through to the next module. For example, if you run SELECT ?name ?age WHERE { my:Person my:name ?name ; my:age ?age } then the variables name and age will be bound as output variables." ;
  rdfs:label "Bind by select" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BindByXPath
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue xsd:string ;
      spl:optional true ;
      spl:predicate sml:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The datatype of the result variable (xsd:string if left blank)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "value" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable to bind." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document or node to operate on." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xpath ;
      spl:valueType xsd:string ;
      rdfs:comment "The XPath to process." ;
    ] ;
  rdfs:comment "Evaluates an XPath on a given XML node (or document) and binds the first result to a given variable." ;
  rdfs:label "Bind by XPath" ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:BindLiteralVariable
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue xsd:string ;
      spl:predicate sml:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The target datatype, e.g. xsd:string or xsd:int. Default: xsd:string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the output variable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:template ;
      rdfs:comment "the template string" ;
    ] ;
  rdfs:comment "Binds the output variable with a constant of a given datatype, or with a value derived from one or more other input variable values. The template could be as simple as {?varName} to insert the variable's value or more complex such as {?firstName} {?lastName}. This module can also be used to convert the datatype, e.g. to convert a xsd:string into a xsd:float." ;
  rdfs:label "Bind literal variable" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BindWithConstant
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the variable that will hold the constant. Default: text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:value ;
      rdfs:comment "The constant value (either a resource or a literal)." ;
    ] ;
  rdfs:comment "Binds a variable with a given RDF node." ;
  rdfs:label "Bind with constant" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BindWithParameter
  a sm:Module ;
  a owl:DeprecatedClass ;
  spin:abstract true ;
  rdfs:comment "Deprecated since 2.0.0: Web Services are now defined like user-defined functions and SPIN functions, and the parameters are instances of spl:Argument." ;
  rdfs:label "Bind with parameter" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:BranchByAsk
  a sm:Module ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate sm:else ;
      rdfs:comment "The start of the child script that shall be executed if the ask query evaluates to false." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 0 ;
      spl:predicate sm:if ;
      rdfs:comment "The start of the child script that shall be executed if the ask query evaluates to true." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:askQuery ;
      rdfs:comment "The SPARQL Ask query that delivers true (sm:if) or false (sm:else) to determine the branching condition." ;
    ] ;
  rdfs:comment "Runs a SPARQL Ask query and, depending on the resulting boolean, either continues with the sm:if or the sm:else branch. Both branches can be sub-scripts, and the sm:if and sm:else should point to the entry points of those sub-scripts. Those entry modules will be passed the same RDF triples and variable bindings as passed to theBranchByAsk module itself. The result of the execution will be the target module (last module in the sub-script) of the selected branch. All variable bindings of the result module will also be passed on as output to the next module(s). Both branches must have exactly one target module. If a branch is empty then the module's input will be passed on unchanged." ;
  rdfs:label "Branch by ask" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:CatchExceptions
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "error" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that shall hold the error message." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:stackTraceVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a variable that shall contain the full stack trace." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      spl:valueType sm:Modules ;
      rdfs:comment "The head of the script to execute. Must have a single end module." ;
    ] ;
  rdfs:comment "Runs a sub-script (sm:body) and catches any errors (Java Exceptions) that happened within it. Normally, the SPARQLMotion engine exits on hitting any Exception, but this module provides a level of error handling. If an error occurs, then the result variable (sm:outputVariable) will contain the error message, and the result graph will be the same as the input of the module itself. Otherwise, the output graph will be the last module of the nested body script, and any variable bindings from the body will be applied to the next modules. As an option, the full stack trace can be bound to a variable as well." ;
  rdfs:label "Catch exceptions" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:CheckConstraints
  a sm:Module ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "An (optional) SPARQL SELECT query that delivers the resources that shall be checked." ;
    ] ;
  rdfs:comment """DEPRECATED: as of TopBraid 6.1 this module should no longer be used, and customers are encouraged to use SHACL constraints only.

Runs all SPIN constraints defined in the current input graph. The output of this module will be a new RDF graph that only contains the spin:ConstraintViolation instances. If the SELECT query is specified, then only the selected resources will be checked, not the whole model.""" ;
  rdfs:label "Check constraints" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:CheckSpelling
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "The SELECT query that delivers all the literals that shall be spell checked." ;
    ] ;
  rdfs:comment """Runs a SPARQL select query and binds result variables for each matching result set.  Strings bound to variables in the SELECT clause will be passed to a TBL spellchecker, which will parse the string into individual words and return triples representing each word from the string not in the dictionary.  Each word returned is represented as an instance of the class http://topbraid.org/spellcheckresults#SpellResult with properties inputString, foundError, mispelledWords, and suggestions, all with the same prefix as SpellResult, http://topbraid.org/spellcheckresults#. The value of the suggestions property is an rdf:Bag with five suggested replacements for the word. In the checked content, terms in all upper-case such as acronyms are ignored.

The spellcheck dictionary is included with TopBraid Live (both Personal and Enterprise Server).  Words can be added to the dictionary through the sml:UpdateUserWordDictionary module.""" ;
  rdfs:label "Check spelling" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:CloneVariable
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will be created." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:inputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the input variable that shall be cloned." ;
    ] ;
  rdfs:comment """Clones a given variable value and assigns it to a new output variable. The input variable will keep its value.

This module can be useful to \"rename\" an existing variable so that it has a matching name that is expected by modules downstream in the script. For example, if you have a variable ?xmlFile but a next module expects an input argument ?xml (via an argument sml:xml), then you can use sml:CloneVariable to bind ?xml with the value of ?xmlFile. Note that in many (most?) cases, you can achieve the same by using inline SPARQL expressions: in TBC use \"Add SPARQL expression\" from the context menu of the property name and enter an expression such as ?xmlFile at the sml:xml property.""" ;
  rdfs:label "Clone variable" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:CollectGarbage
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI of the RDF model to \"forget\"." ;
    ] ;
  rdfs:comment "Collects \"garbage\" to clean up memory from RDF models that are no longer used. Currently, this requires specifying the base URI of a graph that has been previously loaded. Note that the use of this module is not safe in a multi-user setting, and should only be used if you know what you are doing." ;
  rdfs:label "Collect garbage" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:ConcatenateText
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the output variable that will contain the concatenated text string. Default: text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:separator ;
      rdfs:comment "An optional separator that will be inserted between the text units." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "The SPARQL Select query that will deliver the individual values that shall be concatenated." ;
    ] ;
  rdfs:comment "Executes a SPARQL Select query and creates a single long text string by concatenating all result variable bindings. This can be used, for example, to create a single \"fullName\" value from \"firstName\" and \"lastName\" properties (in which case the order of variables in the SELECT clause is relevant. Another use case is to build a single long string from multiple property values of the same kind, e.g. to concatenate all text bodies of all RSS items in a newsfeed. The resulting text can then be further processed by text processing modules such as text miners." ;
  rdfs:label "Concatenate text" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConstructNTFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to overwrite the NT file. False to append." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the target file path." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:minCount 1 ;
      spl:predicate sml:constructQuery ;
      rdfs:comment "The SPARQL Construct queries that deliver the triples that shall be added." ;
    ] ;
  rdfs:comment "Executes a CONSTRUCT query in a streaming fashion and writes all resulting triples into a given N-Triples file. The resulting file can then be used as input to databases, e.g. using the TDB import wizard of TopBraid Composer. This module has a smaller memory foot-print than sml:ApplyConstruct, in which all constructed triples need to fit into memory." ;
  rdfs:label "Construct NT file" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ControlFlowModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "Control Flow" ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:ConvertDDLToRDF
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue true ;
      spl:optional true ;
      spl:predicate sml:withDatatypeLinks ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), triples connecting columns to their datatypes are generated." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue true ;
      spl:optional true ;
      spl:predicate sml:withDatatypes ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), datatypes are imported." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue true ;
      spl:optional true ;
      spl:predicate sml:withSchema ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), schema elements such as tables and columns are imported." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional false ;
      spl:predicate sml:datatypesBaseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "If specified, URIs for datatype definitions will be breated from this base URI instead of the sml:baseURI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional false ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The input SQL script" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:baseURI ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "URIs for schema elements such as tables, columns, etc. will be created from this base URI. If not present, an example URI will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:databaseName ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional database name or catalog name that will be used as a prefix for schema elements when generating URIs and labels" ;
    ] ;
  rdfs:comment "Converts a SQL script containing DDL statements, such as \"CREATE TABLE\", to RDF. The input is given as a text string. The output will use classes and properties from the EDG Data Models schema." ;
  rdfs:label "Convert DDL to RDF" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertDatatype
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:datatype ;
      spl:valueType rdfs:Datatype ;
      rdfs:comment "The datatype (e.g. xsd:string) of the new triples. If the datatype is rdfs:Resource and the lexical form of the old value is a valid URI, then the resulting triple will point to a resource with that URI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate of the triples that shall be replaced." ;
    ] ;
  rdfs:comment "Replaces all triples that have a given property as predicate (specified by sml:predicate) by converting its object literals into a different RDF datatype (specified as sml:datatype)." ;
  rdfs:label "Convert datatype" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ConvertJSONToRDF
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "root" ;
      spl:optional true ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the result variable (defaults to \"root\") that will contain the root object of the converted JSON code." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:keepRootObject ;
      spl:valueType xsd:boolean ;
      rdfs:comment "In GraphQL mode (sml:service is provided) then the root object is typically just a container derived from the Query. By default, the triples of this root object will not be kept. Set to true to keep these triples in the result graph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:service ;
      spl:valueType graphql:Schema ;
      rdfs:comment "A GraphQL service object providing information on how to map the JSON to RDF using SHACL shapes." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The JSON input text, either a JSON object or array." ;
    ] ;
  rdfs:comment """Takes a JSON object or array (represented as text) and converts it to RDF triples with the same structure. The result graph will only contain the generated triples - the input graph will be ignored and may need to be passed on with a separate sm:next relationship. The graph uses the namespace prefix.

This module operates in two modes. By default it will use the \"json\" namespace (http://topbraid.org/json#) for properties and create blank nodes of type json:Object. However, if sml:service is set it will look for GraphQL shapes and walk them in parallel to the JSON object tree.

The conversion will start at the JSON root and does a recursive walk through of the JSON objects and arrays. Each JSON object becomes a resource. Each attribute of the JSON object is mapped into a property. In the simple case, it will pick a property from the json namespace, e.g. attribute \"firstName\" becomes a property json:firstName. In simple more, the values of those properties depend on the JSON attribute value and arrays are converted to rdf:Lists, JSON objects recursively become new blank nodes. Numbers, booleans and strings become corresponding RDF literals. In GraphQL mode, the shapes define how the mapping is performed and the root node must be a JSON object.

Optionally, the module can bind a new variable pointing at the root object of the new JSON data structure in RDF. This does not work if the provided JSON string is an Array with multiple entries.""" ;
  rdfs:label "Convert JSON to RDF" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertRDFToXML
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate sml:isAttributeUnqualified ;
      sml:hidden true ;
      rdfs:comment "Indicates if the attributes in the RDF are unqualified. Default is false." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the variable that will hold the resulting XML data. Default: xml." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:document ;
      spl:valueType sxml:Document ;
      rdfs:comment "The sxml:Document to use - if unspecified it will pick one found in the model, which will be unpredictable if multiple sxml:Document instances exist." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:fullNamespaces ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true then the converter will no longer trim xmlns attributes of their / or # endings. " ;
    ] ;
  rdfs:comment "Converts RDF into XML using the Semantic XML (sxml) ontology for the round-tripping. The resulting XML will be bound to the specified output variable. Note that this requires the RDF model to contain an SXML root document element - this function does not work with arbitrary RDF data!  For more, see Help > Import and Export > Creating, Importing, Querying, Saving XML documents with Semantic XML." ;
  rdfs:label "Convert RDF to XML" ;
  rdfs:seeAlso <http://composing-the-semantic-web.blogspot.com/2007/11/xmap-mapping-arbitrary-xml-documents-to.html> ;
  rdfs:seeAlso sml:ConvertXMLToRDF ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:ConvertSpreadsheetToRDF
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:className ;
      rdfs:comment "The optional name of the target class. If this value is unspecified, then cell (0, 0) of the spreadsheet is used instead. This value can be a localname, a qname or a URI string. If it doesn't exist, then it is created." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:encoding ;
      rdfs:comment "The canonical name of the text encoding of the spreadsheet file. If no value for this property is given, then the default JRE encoding is used. If an encoding value is given for this property, then the spreadsheet file will be evaluated using this value. The supported encodings can be found at the website: <http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html>" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:importToInputGraph ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, then the import will attempt to reuse properties defined in the input RDF graph for the column-to-property mapping." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:instancePattern ;
      rdfs:comment "The naming pattern for the generated instances. This can contain static characters or placeholders for columns. For example Person-%1 will create names that consist of the static string \"Person-\" and then the value of the first column." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:propertyPrefix ;
      rdfs:comment "The prefix that shall be used for the generated property names. Only used if no qname is specified for a column property and if a new graph is created from the spreadsheet, i.e. importToInputGraph value is false." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:sourceFilePath ;
      rdfs:comment "An optional file path to the spreadsheet. If this is specified then the module will directly do streaming loading from the given file. This should make it possible to handle files of arbitrary size." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:text ;
      rdfs:comment "The spreadsheet's text that shall be converted. If sml:sourceFilePath is set then this value is ignored." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:useUnderscore ;
      rdfs:comment "If true, it replaces special characters, i.e. characters that cannot be imported by default to create a resource URI, with an underscore. If false, these characters are ignored during import." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:useVerbatim ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true, it imports special characters, i.e. characters that cannot be imported by default to create a resource URI. If false, these characters are ignored during import." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:schemaNamespace ;
      rdfs:comment "The base namespace of the target schema." ;
    ] ;
  rdfs:comment """Creates an RDF graph from a tab-separated spreadsheet which is specified from a given string variable. In a typical use case, this will be used after sml:ImportTextFile, which binds the variable text which is also the default input variable of this module. For very large files that cannot be loaded into memory, the module provides the option to specify a file directly using sml:sourceFilePath.

Note that TopBraid supports multiple spreadsheet importer algorithms, including Semantic Tables and the Excel cell importer (sml:ImportExcelCellInstances). This module provides the functionality that is accessible through the TopBraid Composer Spreadsheet import wizard (Help > Import > Import Tab-Delimited Spreadsheet File).""" ;
  rdfs:label "Convert spreadsheet to RDF" ;
  rdfs:seeAlso sml:ImportExcelCellInstances ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertStringToSPINRDF
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:uri ;
      rdfs:comment "the URI of the query to create (either xsd:string or resource)" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "the SPARQL query in textual form; with or without namespace prefixes" ;
    ] ;
  rdfs:comment "Converts a SPARQL query (in textual form) to a SPIN RDF syntax resource. The resulting output graph will contain exactly the triples of the SPIN query. These triples can then be used, for example, to analyze the structure of a SPARQL query dynamically. The inverse operation can be achieved using the SPARQL function smf:convertSPINRDFToString." ;
  rdfs:label "Convert string to SPIN RDF" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertTextToRDF
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue sml:Turtle ;
      spl:optional true ;
      spl:predicate sml:serialization ;
      spl:valueType sml:RDFSerialization ;
      rdfs:comment "The optional serialization format, given as an instance of sml:RDFSerialization: sml:Turtle (default), sml:RDFXML, sml:NTriple, sml:JSONLD, etc." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:noStringSubstitution ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to skip the usual string templating mechanism in SPARQLMotion, e.g. {?str} will remain verbatim. This should always be used unless the content of the file is safely known in advance, or in cases where the value is {?str} from a pre-bound variable in the script." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to return only the parsed triples. Defaults to the union of the new triples and the input graph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:text ;
      rdfs:comment "The text to parse." ;
    ] ;
  rdfs:comment "Converts a text in one of the RDF serializations into an RDF graph. In a typical scenario, the text would be passed into the script as external (web service) input. The result of this module is (by default) the input RDF triples plus the parsed triples, unless sml:replace is set to true." ;
  rdfs:label "Convert text to RDF" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertTextToRDFList
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "list" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "the name of the output variable that will contain the rdf:List" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "the comma-separated list of URIs" ;
    ] ;
  rdfs:comment """Takes a comma-separated list of URIs as input and creates an rdf:List from it which is then visible to all modules downstream. The rdf:List will be a blank node (or rdf:nil) and the provided output variable will point to it. Note that the RDF output of this module consists of the rdf:List triples only, i.e. the input triples are not passed through.
Among others, this module can be used by web services that take lists as input.""" ;
  rdfs:label "Convert text to RDFList" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:ConvertXMLByXSLT
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The generated XML string variable. The recommended module to export or return the value of this variable is sml:ExportToXMLFile or sml:ReturnXML." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:template ;
      rdfs:comment "The string variable holding the XSLT script" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The source XML variable" ;
    ] ;
  rdfs:comment """Converts an XML document into another XML document using XSLT. The source XML document is either a XML or string variable. The target XML document is a string variable. XSLT script is provided as a string.

Any property other than the expected arguments (sm:outputVariable, sml:template, sml:xml, rdfs:label, and rdf:type) can be used to specify additional parameters for the XSL transformer. The local name of the property will be the parameter name. The values must be string literals. For example, set arg:myParam to \"{?myValue}\" and the value of the variable ?myValue will be set as parameter \"myParam\".""" ;
  rdfs:label "Convert XML by XSLT" ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:ConvertXMLToRDF
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true then the resulting output graph will not include the input graph, i.e. only the new triples will be returned." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:xmlType ;
      spl:valueType xsd:string ;
      rdfs:comment "An (optional) type indicator for the Semantic XML conversion. Current supported values are \"XHTML\" (treats the input as HTML source, and may run a tidy algorithm in case the HTML is not well-formed XHTML)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:baseURI ;
      rdfs:comment "The base URI of the new RDF (for the creation of the new class and property names)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document that shall be converted to RDF. To avoid character encoding issues, we strongly recommend this value to be a reference to an already parsed XML document, and not a literal. In other words, use \"Add SPARQL expression\" from the drop down menu and enter ?varName and do not use a string value such as {?varName}. The actual document parsing should be handled by predecessing modules such as sml:ImportXMLFromURL." ;
    ] ;
  rdfs:comment "Converts an arbitrary XML input document into an RDF graph using the Semantic XML mapping approach. The input graph of this module may contain class definitions that have sxml: declarations attached to them and these will be used for the instances. For more, see Help > Import and Export > Creating, Importing, Querying, Saving XML documents with Semantic XML." ;
  rdfs:label "Convert XML to RDF" ;
  rdfs:seeAlso <http://composing-the-semantic-web.blogspot.com/2007/11/xmap-mapping-arbitrary-xml-documents-to.html> ;
  rdfs:seeAlso sml:ConvertRDFToXML ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:CopyFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:newFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path for the target file." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:oldFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the source file." ;
    ] ;
  rdfs:comment "Creates a copy of a given file within the workspace." ;
  rdfs:label "Copy file" ;
  rdfs:subClassOf sml:FileProcessingModules ;
.
sml:CreateMatrix
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The variable that will contain the resulting matrix as an xsd:string literal. Default: text." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:cellQuery ;
      rdfs:comment "A SPARQL Select query that is executed for each cell in the matrix. The query should reference the result variables of column and row queries (these will be bound automatically by the engine)." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:columnQuery ;
      rdfs:comment "A SPARQL Select query that delivers the resources or literals that define the columns. The query should have a single result variable, and this variable should be used in the cell query." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:rowQuery ;
      rdfs:comment "A SPARQL Select query that delivers the resources or literals that define the rows. The query should have a single result variable, and this variable should be used in the cell query." ;
    ] ;
  rdfs:comment """Creates a matrix (spreadsheet) and binds it as a text value to a given output variable.

The rows and columns of the matrix are specified by two SPARQL queries. These queries must deliver variable bindings to enumerate the resources that shall be used as rows and columns. The cell values are then computed using a third query (cellQuery) that should reference the bound variable names from the row and column queries.""" ;
  rdfs:label "Create matrix" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:CreateSPINResultSet
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "table" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will point to the new spr:Table resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:selectQuery ;
      rdfs:comment "The SELECT query to evaluate." ;
    ] ;
  rdfs:comment "Converts the result set of a given SPARQL SELECT query (sml:selectQuery) to an SPIN result set (SPR table resource). The resulting resource can then be queried using the SPR functions. The output graph of this module contains only table triples." ;
  rdfs:label "Create SPIN Result Set" ;
  rdfs:seeAlso <http://spinrdf.org/spr.html> ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:CreateSWPDocument
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "doc" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will contain the resulting document (as a string)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:snippet ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only create a UISPIN snippet, e.g. without head/body." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:view ;
      spl:valueType ui:Node ;
      rdfs:comment "The UISPIN snippet to evaluate." ;
    ] ;
  rdfs:comment """Evaluates a given SWP document (sml:view) and assigns the resulting document to a given string variable (sm:outputVariable). The new variable can then be saved to a file or processed otherwise. All incoming variables of this SM module will be bound in the SWP expression.

Note that in order to insert an SWP view for a given resource (using ui:instanceView etc), you can use the snippet <ui:resourceView ui:resource=\"{= ?varName }\" />.

Also note that in order to use HTML or SVG tags in the sml:view, you will need to import the html.ttl or svg.ttl from the SWP ontologies into the script.""" ;
  rdfs:label "Create SWP document" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:CreateSpreadsheet
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the variable that will hold the resulting spreadsheet string. Default: text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:separator ;
      spl:valueType xsd:string ;
      rdfs:comment "The separator between each column. Default is the tab character, but a typical alternative is \",\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "The SPARQL Select query that delivers the rows of the spreadsheet. The columns will be the result variables of the query." ;
    ] ;
  rdfs:comment "Creates a spreadsheet text from all bindings of a SPARQL SELECT query. The resulting text will be bound to a variable and can then be saved to a file or further processed." ;
  rdfs:label "Create spreadsheet" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:CreateTDB
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to overwrite any pre-existing database at this location." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI for the TDB repository." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the TDB database." ;
    ] ;
  rdfs:comment "Create a new TDB graph from the input RDF triples to a given Jena TDB database. Also loads and registers the new graph." ;
  rdfs:label "Create TDB" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:CreateWekaClassifier
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:key ;
      spl:valueType xsd:string ;
      rdfs:comment "The identifier under which the resulting classifier can be accessed later." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:path ;
      spl:valueType xsd:string ;
      rdfs:comment "A string representation of the rdf:Property or property path that shall be classified, i.e. for which the classifier can suggest values. This must be exactly in the same syntax as the path string in the shape, e.g. needs to use the same prefixes for abbreviated property URIs. This can only be used for property paths that are marked as sh:maxCount 1 in the shape, because these are the only ones that are mapped to a single attribute in Weka." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:shape ;
      spl:valueType sh:NodeShape ;
      rdfs:comment "The shape holding the definition of the properties and paths to define the attributes for weka. Use sh:maxCount 1 where possible." ;
    ] ;
  rdfs:comment "Creates a new Weka classifier (based on a shape definition) that is trained using the focus nodes of the shape and which can be used to \"classify\" the values of a given new instance using weka:classify." ;
  rdfs:label "Create Weka classifier" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:DatabaseType
  a rdfs:Class ;
  rdfs:comment "The class of database configurations used by Jena SDB (and possibly other databases)." ;
  rdfs:label "Database type" ;
  rdfs:subClassOf rdfs:Resource ;
.
sml:DeleteFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:filePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The file to delete." ;
    ] ;
  rdfs:label "Delete file" ;
  rdfs:subClassOf sml:FileProcessingModules ;
.
sml:DeleteSampleData
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:sampleCount ;
      spl:valueType xsd:integer ;
    ] ;
  rdfs:comment "Deletes sample data extracted by a JDBC schema import." ;
  rdfs:label "Delete sample data" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:DeleteWekaClassifier
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:key ;
      spl:valueType xsd:string ;
      rdfs:comment "The identifier under which the resulting classifier was created." ;
    ] ;
  rdfs:comment "Deletes a Weka classifier from the Maui server. This should be called whenever the classifiers produced by sml:CreateWekaClassifier are no longer needed." ;
  rdfs:label "Delete Weka classifier" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:Diff
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:ignoreBlankNodes ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to bypass comparison of blank nodes - which may take up a lot of time." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:newGraph ;
      spl:valueType sm:Modules ;
      rdfs:comment "The module representing the new graph. Must be a predecessor of the current module to ensure that the module has been executed before." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:oldGraph ;
      spl:valueType sm:Modules ;
      rdfs:comment "The module representing the old graph. Must be a predecessor of the current module to ensure that the module has been executed before." ;
    ] ;
  rdfs:comment "This module exposes the functionality known from TopBraid Composer under Model > Compare current RDF Model with... It returns a diff graph between an old graph and a new graph. This module is related to the old graph with sml:oldGraph and the new graph with sml:newGraph properties. The output is a collection of instances from the http://topbraid.org/diff namespace." ;
  rdfs:label "Diff" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ExportBatch
  a sml:OracleExportMode ;
  rdfs:label "ExportBatch" ;
.
sml:ExportBulk
  a sml:OracleExportMode ;
  rdfs:label "ExportBulk" ;
.
sml:ExportIncremental
  a sml:OracleExportMode ;
  rdfs:label "ExportIncremental" ;
.
sml:ExportModules
  a sm:Module ;
  spin:abstract true ;
  composite:index "2"^^xsd:int ;
  rdfs:comment "Modules that create some output, such as files or UI components." ;
  rdfs:label "Export" ;
  rdfs:subClassOf sm:Modules ;
.
sml:ExportToJMS
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "ConnectionFactory" ;
      spl:optional true ;
      spl:predicate sml:jmsConnectionFactory ;
      spl:valueType xsd:string ;
      rdfs:comment "Connection Factory name for the JMS Queue" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "JMS broker username." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:className ;
      spl:valueType xsd:string ;
      rdfs:comment "Fully qualified class name of JNDI Initial Context Factory for the JMS Queue." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:jmsDestination ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the JMS queue to send the message to." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The text to be submitted to the JMS queue." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the JMS broker." ;
    ] ;
  rdfs:comment "Exports a string to a JMS queue.  The text to export must be specified as value of the argument sml:text." ;
  rdfs:label "Export to JMS" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ExportToLocalModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "Export to Local" ;
  rdfs:subClassOf sml:ExportModules ;
.
sml:ExportToRDFFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:targetFilePath ;
      rdfs:comment "The path of the file to create. The path can be relative to the current script's folder (e.g., myFolder/test.rdf) or absolute to the workspace root /myProject/myFolder/test.rdf. Can be left blank if the base URI already has a representation in the workspace. In that case, the primary file in the workspace will be overwritten." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:baseURI ;
      rdfs:comment "The base URI under which the resulting file will be registered in the workspace." ;
    ] ;
  rdfs:comment """Creates a new RDF file at the specified path inside the workspace and with the specified base URI. The serialization is derived from the file name according to TopBraid's conventions, e.g. files ending with .ttl will be written in Turtle format.

Note that if an existing file is overwritten (with matching base URI), and the graph of this file has already been loaded, then the system will not reload the new graph. I.e. if the URI specified in sml:baseURI is the same baseURI of a graph currently open in TBC or TBL, the old graph will remain open and the export will only have an effect after closing the other copies.  A consequence of this is that you cannot overwrite a file and reload its new content within the same session, e.g. sml:ImportRDFFromWorkspace will still deliver the old graph. In order to modify an existing graph, the recommended approach is to use sml:PerformUpdate.""" ;
  rdfs:label "Export to RDF file" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExportToRemoteModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "Export to Remote" ;
  rdfs:subClassOf sml:ExportModules ;
.
sml:ExportToSDB
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:predicate sml:initialize ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates that the SDB database shall be initialized." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates whether all existing content of the SDB shall be overwritten." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:createGraph ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true the exported graph will be output from the module. Otherwise the output graph remains unchanged from the input." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:graphName ;
      spl:valueType xsd:string ;
      rdfs:comment "the named graph URI" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password to log in with. Can be left empty if the built-in security mechanism (of Eclipse) shall be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) path to a .sdb file that can later be opened from within TopBraid." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name to log in with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI of the target SDB database. This will serve as a unique identifier of the triple store in TopBraid, and is typically also represented by an owl:Ontology." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:databaseType ;
      spl:valueType sml:DatabaseType ;
      rdfs:comment "The database type, e.g. Oracle." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the database." ;
    ] ;
  rdfs:comment """Writes the input triples to a specified Jena SDB database.

Note: This is a low-level system module. The preferred way of writing to databases is using sml:PerformUpdate.""" ;
  rdfs:label "Export to SDB" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ExportToSesameRemoteRepository
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:baseURI ;
      rdfs:comment "The base URI of the target repository. Must be specified if a connection file (*.s2r) shall be created." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:graphName ;
      spl:valueType xsd:string ;
      rdfs:comment "the graph name URI" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:modelName ;
      rdfs:comment "The id of the model on the server, if necessary." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      rdfs:comment "The password if required to log into the repository. Can be left empty if the built-in security mechanism (of Eclipse) shall be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      rdfs:comment "true clears the repository before writing into it." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:targetFilePath ;
      rdfs:comment "An (optional) path to a connection metadata file that will be created so that tools can connect to the repository later. This path is relative to the workspace root, e.g. \"/myProject/myFolder/myFile.s2r\". Must be used in conjunction with sml:baseURI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      rdfs:comment "The user name if required to log into the repository." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL of the Sesame server." ;
    ] ;
  rdfs:comment """Writes the input triples into a Sesame remote repository.

Note: This is a low-level system module. The preferred way of writing to databases is using sml:PerformUpdate.""" ;
  rdfs:label "Export to Sesame remote repository" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ExportToSolrFields
  a sm:Module ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "http://localhost:8983/solr" ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the Solr server." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "Password for authentication at the Solr server (if needed). If left blank and a user name is provided, then the system will look up a password from TopBraid's secure storage." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to clear out the Solr index before adding the fields." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "An optional SELECT query that returns all resources that shall be exported. If not specified, then the module will export all subjects." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:useURIs ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to use full URIs for field names - the system will try to use qnames otherwise and this may lead to problems if either no prefixes exist or names clash." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "User name for authentication at the Solr server (if needed)." ;
    ] ;
  rdfs:comment """DEPRECATED: As of TopBraid 6.1 this feature is marked for deletion and should no longer be used.

Exports documents and their fields derived from the current input graph to a given Solr instance. The algorithm iterates over a set of subjects, which can be specified by a given selectQuery. It turns each subject into a Solr document, and each property of the subject by default is mapped to a dynamic field, based on the types of the values. For example, a single-valued xsd:string property ex:myProperty is mapped to a Solr field \"ex_myProperty_s\" (if the qname option has been selected). Each document also has an \"id\" field which contains the URI of the subject, and a \"name\" field which contains the human-readable label of the subject. In contrast, rdfs:label and its sub-properties are not exported unless explicitly overridden. It is possible to override the property naming convention by attaching the solr:fieldName values to the properties in the RDF graph. If the value of solr:fieldName is \"-\" then the property will not be exported at all.""" ;
  rdfs:label "Export to Solr fields" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ExportToTDB
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:createGraph ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true the exported graph will be output from the module. Otherwise the output graph remains unchanged from the input." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to overwrite any pre-existing database at this location." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI for the TDB repository." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the TDB database." ;
    ] ;
  rdfs:comment """Export the input RDF triples to a given Jena TDB database.

Note: This is a low-level system module. The preferred way of writing to databases is using sml:PerformUpdate.""" ;
  rdfs:label "Export to TDB" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExportToTextFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:encoding ;
      spl:valueType xsd:string ;
      rdfs:comment "The file encoding such as UTF-8. If left blank, then the platform's default encoding will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replace ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Specifies whether this will overwrite a file with the same name (true) or whether it will append to an existing file (false)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:targetFilePath ;
      rdfs:comment "The path to the file that shall be created. The path can be relative to the current script's folder (e.g., myFolder/test.txt) or absolute to the workspace root /myProject/myFolder/test.txt." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:text ;
      rdfs:comment "The text that shall be written into the file." ;
    ] ;
  rdfs:comment "Saves text to a file. The text must be the value of the specified input variable." ;
  rdfs:label "Export to text file" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExportToXMLFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:targetFilePath ;
      rdfs:comment "The path to the output file. The path can be relative to the current script's folder (e.g., myFolder/test.xml) or absolute to the workspace root /myProject/myFolder/test.xml." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document that shall be written to the file." ;
    ] ;
  rdfs:comment "Creates an XML file from the value of the input variable." ;
  rdfs:label "Export to XML file" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExportToZIPFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The sourceFilePath can be relative to the current script's folder (e.g. pathDir/data).  Or it can be multiple absolute or relative workspace paths separated by comma. (e.g. /myProject/myFolder/data, pathDir/data)" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the file that shall be created. The path can be relative to the current script's folder (e.g. test.zip) or absolute to the workspace root (e.g. /myProject/myFolder/test.zip)." ;
    ] ;
  rdfs:comment "Saves files in sourceFilePath to a zip file in targetFilePath." ;
  rdfs:label "Export to ZIP file" ;
  rdfs:subClassOf sml:ExportToLocalModules ;
.
sml:ExtractJDBCSchema
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue true ;
      spl:optional true ;
      spl:predicate sml:withDatatypeLinks ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), triples connecting columns to their datatypes are generated." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue true ;
      spl:optional true ;
      spl:predicate sml:withDatatypes ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), datatypes are imported." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue true ;
      spl:optional true ;
      spl:predicate sml:withSchema ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true (the default), schema elements such as tables and columns are imported." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional false ;
      spl:predicate sml:datatypesBaseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "If specified, URIs for datatype definitions will be breated from this base URI instead of the sml:baseURI." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:baseURI ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "URIs for schema elements such as tables, columns, etc. will be created from this base URI. If not present, an example URI will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:databaseName ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional database name or catalog name that will be used as a prefix for schema elements when generating URIs and labels" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:sampleCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of sample rows to be stored for profile" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:withSamples ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:withStats ;
      spl:valueType xsd:boolean ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
    ] ;
  rdfs:comment "Creates a JDBC connection to the specifed database to extract schema. The output will use classes and properties from the EDG Data Models schema." ;
  rdfs:label "Extract JDBC Schema" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:FileProcessingModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "File Processing" ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:FilterByConstruct
  a sm:Module ;
  spin:constraint [
      a spl:Attribute ;
      spl:minCount "1"^^xsd:int ;
      spl:predicate sml:constructQuery ;
      rdfs:comment "A SPARQL Construct query delivering the triples that shall be dropped." ;
    ] ;
  rdfs:comment "Uses SPARQL CONSTRUCT queries to enumerate triples that shall be dropped from the input triple stream. The output triples of this module contain all input triples except those enumerated by the construct query. For example, if you want to drop all rdfs:comment triples from the input graph, then use a query such as CONSTRUCT {?s rdfs:comment ?o} WHERE {?s rdfs:comment ?o}." ;
  rdfs:label "Filter by construct" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:FilterByFilterGraph
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:filterGraph ;
      spl:valueType sm:Modules ;
      rdfs:comment "The module that contains the triples that shall be filtered out. Must be one of the predecessors of this module, to make sure that it has been executed before." ;
    ] ;
  rdfs:comment "Filters input graphs with filter graphs. This module is linked to filter graph modules by sml:filterGraph property." ;
  rdfs:label "Filter by filter graph" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:GenerateRandomData
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:namespace ;
      spl:valueType xsd:string ;
      rdfs:comment "The default namespace to use for newly created instances." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:replaceInvalidValues ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to post-process the values of the generated properties using SHACL, attempting to replace values that violate constraints. Activating this feature may cause significant performance degradation." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:targetGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional target graph to write the triples to. If unspecified, the new triples will be added into a newly created in-memory graph." ;
    ] ;
  rdfs:comment "Generates random instances of classes as defined by the input triples using the datagen namespace (TopBraid/SHACL/datagen.ttl). The output graph of the module is the graph containing the generated triples." ;
  rdfs:label "Generate random data" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:GenerateReport
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:focusNode ;
      rdfs:comment "An optional focus node. If specified then only results related to that focus node will be produced." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:ids ;
      spl:valueType xsd:string ;
      rdfs:comment "A comma-separated list of IDs of individual result generators that shall be executed. By default, all generators are called." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:ignoreImports ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only run this on resources that appear as subject in a triple from the base graph. In other words, focus nodes defined only in imported graphs will be skipped." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:result ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource that shall hold the sh:result triples in the results graph." ;
    ] ;
  rdfs:comment "Generates a report for a given focus node or the whole input graph. This module provides access to an extension mechanism of TopBraid, including a growing number of individual result generators. Each of these result generators has a unique ID that can be used by this module to select which generators to execute. The output graph of this module is a new graph consisting of the union of all individual results. The results are represented by subclasses of sh:AbstractResult." ;
  rdfs:label "Generate report" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ImportAndSplitTextFile
  a spin:SelectTemplate ;
  a sm:Module ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "segment" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "sourceFilePath" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "divider" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?2" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "startIndex" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?3" ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?2" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "endIndex" ;
              ] ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?3" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "segment" ;
              ] ;
            sp:predicate smf:splitTextFile ;
            sp:subject [
                sp:varName "?0" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:endIndex ;
      spl:valueType xsd:integer ;
      rdfs:comment "The segment index to end with (first matching segment has index 1)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:startIndex ;
      spl:valueType xsd:integer ;
      rdfs:comment "The segment index to start with (first matching segment has index 1)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:divider ;
      spl:valueType xsd:string ;
      rdfs:comment "The string dividing the segments in the text file, for example \",\" for comma-separated snippets." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The absolute path to the text file in the workspace (e.g., /myProject/myFolder/test.txt)." ;
    ] ;
  rdfs:comment """Performs a streaming load over a text file and iterates over a selection of segments (divided by a given separator) inside of that text file. The body of this module will be executed for each matching segment, and the variable ?segment will be bound in each iteration.

This module uses the magic property smf:splitTextfile for the bulk of the work, and you can also use that magic property for finer-grained control of the iteration.""" ;
  rdfs:label "Import and split text file" ;
  rdfs:subClassOf sm:SelectTemplates ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportCurrentRDF
  a sm:Module ;
  rdfs:comment """Depending on the context, this module delivers different results.

When called from TBC, this will return the RDF graph of the currently open file. In many use cases this will include the script itself, unless the script is a background service such as an sml:TrackChanges script.

When called from a user-defined SPARQLMotion/SPIN Function, this module will return the context graph, which is the graph that the surrounding SPARQL query will currently operate on.

When called as a TopBraid Live (stand-alone) web service, this module will throw an exception because there is no current graph available.""" ;
  rdfs:label "Import current RDF" ;
  rdfs:subClassOf sml:ImportFromVariousModules ;
.
sml:ImportDirectoryWithTika
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate sml:html ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, attempt to extract content as HTML markup instead of plain text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:recursive ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to walk the path recursively." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:path ;
      spl:valueType xsd:string ;
      rdfs:comment "The source path." ;
    ] ;
  rdfs:comment "Each file in the specified directory (and sub-directories if 'recursive' is true) is parsed with Apache Tika. The path can be an absolute path in the workspace, an absolute path in the general file system, or a relative path in relation to the script's location. A graph is generated from the results in the namespace 'http://topbraid.org/document#'. This graph will contain all available metadata, and all parseable text." ;
  rdfs:label "Import directory with Tika" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportExcelCellInstances
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the Excel source file in the workspace. The path can be relative to the current script's folder (e.g., myFolder/test.xls) or absolute to the workspace root /myProject/myFolder/test.xls." ;
    ] ;
  rdfs:comment """Loads an Excel file into instances of the TopBraid spreadsheets ontology - each non-empty cell becomes an instance of ss:Cell. In a typical scenario, the resulting cell instances are passed into other modules (such as sml:ApplyConstruct) to convert the raw data into a more useful format. This module provides the functionality that is accessible from TBC, as described in Help > Import > Import Excel File into Spreadsheet Ontology.

This module is distinct from the Semantic Tables importer, which can be used with sml:ImportRDFFormWorkspace to also import Excel files. The latter is better suited for spreadsheets consisting of regular tables, while this module here is optimized for cases in which the Excel file is not well-structured and each individual cell has a different meaning or role.""" ;
  rdfs:label "Import Excel cell instances" ;
  rdfs:seeAlso sml:ConvertSpreadsheetToRDF ;
  rdfs:seeAlso sml:ImportRDFFromWorkspace ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportFileFromURL
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:targetFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path the file will be downloaded to" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to download the file from" ;
    ] ;
  rdfs:comment "Downloads any file from a given URL and saves it to a location indicated by the targetFilePath argument. The destination directory is created if it does not exist. If the destination file exists, then this method will overwrite it." ;
  rdfs:label "Import file from URL" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportFileWithTika
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate sml:html ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If set to true, attempt to extract content as HTML markup instead of plain text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:overrideFileName ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional file name that Tika may use to determine what parser to use, etc." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:resultURI ;
      rdfs:comment "The URI to use for the document in the output graph. If unspecified, the sourceURL or a file:/// URI representing sourceFilePath will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The file to be imported. The path can be an absolute path in the workspace, or a relative path in relation to the script's location." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:sourceURL ;
    ] ;
  rdfs:comment "Imports a document from a workspace file (sourceFilePath) or from the web (sourceURL), and parses it with Apache Tika. The output graph will contain all available metadata, and all parseable text." ;
  rdfs:label "Import file with Tika" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportFromLocalModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:comment "Modules that import data from a data source on the user's local machine." ;
  rdfs:label "Import from Local" ;
  rdfs:subClassOf sml:ImportModules ;
.
sml:ImportFromRemoteModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "Import from Remote" ;
  rdfs:subClassOf sml:ImportModules ;
.
sml:ImportFromVariousModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "Import from Various" ;
  rdfs:subClassOf sml:ImportModules ;
.
sml:ImportJSONFromGraphQLService
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "json" ;
      spl:optional true ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable, defaulting to \"json\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:arguments ;
      spl:valueType xsd:string ;
      rdfs:comment "A JSON object with name-value pairs for the arguments." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password to use for authentication - leave empty to rely on the password stored in secure storage. Only used if sml:userName is set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name for authentication." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:query ;
      spl:valueType xsd:string ;
      rdfs:comment "The GraphQL query string." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the GraphQL service." ;
    ] ;
  rdfs:comment "Executes a GraphQL query against a given service, possibly including variable bindings. The resulting JSON is then bound to a variable downstream." ;
  rdfs:label "Import JSON from GraphQL service" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportModules
  a sm:Module ;
  spin:abstract true ;
  composite:index "0"^^xsd:int ;
  rdfs:comment "Modules that import information from some data source. Examples include modules to load files, to get XML from web sources and to take user input." ;
  rdfs:label "Import" ;
  rdfs:subClassOf sm:Modules ;
.
sml:ImportRDFFromURL
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "Password for basic authentication, if specified this module will make a BASIC auth HTTP call to the server" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:serialization ;
      spl:valueType sml:RDFSerialization ;
      rdfs:comment "The serialization type expected from the server. Defaults to RDF/XML if not specified." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "User name for BASIC Authentication, if specified this module will make a BASIC auth HTTP call to the server" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL of the RDF source. May contain variable bindings such as {?varName}." ;
    ] ;
  rdfs:comment "Gets RDF data from a given URL. The URL may just point to an RDF file on the web, or call a web service with REST-style parameters to receive RDF back. No other format beside RDF/XML or Turtle is supported by this module - use sml:ImportRDFFromWorkspace for other file types." ;
  rdfs:label "Import RDF from URL" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportRDFFromWorkspace
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate sml:ignoreImports ;
      spl:valueType xsd:boolean ;
      rdfs:comment "Indicates whether owl:imports shall be ignored. If false, then the union of the base graph plus its (transitive) imports will be returned." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) base URI of the model to open. Either this baseURI must be specified or the sourceFilePath. If both are present then the baseURI has priority." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "An (optional) file path pointing to the file that shall be opened. The system will look up the base URI of that file and then open that base URI. This means that if the workspace contains multiple copies of that base URI then it may actually load a different file than the one specified here (it will always use the primary file)." ;
    ] ;
  rdfs:comment "Loads an RDF file from the workspace, based on its base URI (or a path to the file). If the file is already open, it will reuse the currently open model (including any changes that it has compared to the persistent version). The system will use which ever physical file has been registered for the given base URI.  This is the recommended module to load any file type supported by TopBraid, including file serializations (Turtle, RDF/XML and N-TRIPLE), data connectors, XML files (Semantic XML), Excel .xls or .xlsx files (Semantic Tables), etc.  If the file being opened is a file, the file is loaded into memory.  If it is a data connector (RDF or relational back-end), the data source is opened, but no data is loaded into memory. The output graph of this module is the loaded graph only, i.e. other input modules are not passed on." ;
  rdfs:label "Import RDF from workspace" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportSDB
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:graphName ;
      spl:valueType xsd:string ;
      rdfs:comment "the named graph URI" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password of the connection. Can be left empty if the built-in security mechanism (of Eclipse) shall be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name of the connection." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:databaseType ;
      spl:valueType sml:DatabaseType ;
      rdfs:comment "The database type, such as Oracle." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The database URL." ;
    ] ;
  rdfs:comment """Connects to an existing Jena SDB database.

Note: This is a low-level system module. The preferred way of operating on existing SDBs is using sml:ImportRDFFromWorkspace.""" ;
  rdfs:label "Import SDB" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportSesameRemoteRepository
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:graphName ;
      spl:valueType xsd:string ;
      rdfs:comment "the named graph URI" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:modelName ;
      rdfs:comment "The id of the model on the server, if necessary." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      rdfs:comment "The password if required to log into the repository. Can be left empty if the built-in security mechanism (of Eclipse) shall be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      rdfs:comment "The user name if required to log into the repository." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL of the Sesame server." ;
    ] ;
  rdfs:comment """Connects to a remote Sesame 2 repository.

Note: This is a low-level system module. The preferred way of operating on existing databases is using sml:ImportRDFFromWorkspace.""" ;
  rdfs:label "Import Sesame remote repository" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportSystemTriples
  a sm:Module ;
  rdfs:comment "Imports the RDF Schema and OWL system triples, including the definitions of owl:Class, rdf:type, rdfs:label, rdfs:seeAlso etc. An example use case where this is needed is if you want to query for the rdfs:label of any property including system properties. Another use case is if you want to walk the class hierarchy (using rdfs:subClassOf) including metaclasses and other system classes." ;
  rdfs:label "Import system triples" ;
  rdfs:subClassOf sml:ImportFromVariousModules ;
.
sml:ImportTDB
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:dataPath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the TBD data files. This is usually the .tdb connector file name plus .data." ;
    ] ;
  rdfs:comment """Opens a Jena TDB database stored in the workspace at a given path.

Note: This is a low-level system module. The preferred way of operating on existing TDBs is using sml:ImportRDFFromWorkspace.""" ;
  rdfs:label "Import TDB" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportTextFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable that will contain the text of the file as an xsd:string literal. Default: text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:encoding ;
      spl:valueType xsd:string ;
      rdfs:comment "The file encoding such as UTF-8. If left blank, then the platform's default encoding will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to a text file. The path can be relative to the current script's folder (e.g., myFolder/test.txt) or absolute to the workspace root /myProject/myFolder/test.txt." ;
    ] ;
  rdfs:comment "Imports a text file into the xsd:string variable sm:outputVariable." ;
  rdfs:label "Import text file" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportTextFromURL
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The output variable to contain the text." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:securePasswordURL ;
      spl:valueType xsd:string ;
      rdfs:comment "If this argument has a value and no sml:password has been provided then the system will look for a secure storage password for the given user name/URL combination." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to load from." ;
    ] ;
  rdfs:comment "Imports a text stream from a URL and writes the result string into a given output variable. Among others, this module can be used to read JSON from REST-based web services." ;
  rdfs:label "Import text from URL" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportXHTML
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The name of the variable that will contain the XHTML as an XML document. Default: xml." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL of the HTML page. May contain variables such as {?varName}." ;
    ] ;
  rdfs:comment "Opens an HTML document from a URI, using Tidy to convert it to XHTML (XML). The url must point to the URL of the file. The URL may contain variables from the input modules. The resulting XML will be assigned to the specified output variable." ;
  rdfs:label "Import XHTML" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:ImportXMLFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate sml:ignoreDoctype ;
      spl:valueType xsd:boolean ;
      rdfs:comment "An (optional) indicator to ignore the XML document type.  This will allow for opening documents offline where the DTD or schema may not be available." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable containing the XML data. Default: xml." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:sourceFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the XML file in the workspace. The path can be relative to the current script's folder (e.g., myFolder/test.xml) or absolute to the workspace root /myProject/myFolder/test.xml." ;
    ] ;
  rdfs:comment "Loads an XML file, specified by a file path and binds the resulting document as an XML DOM tree to the specified output variable. This module is often the starting point of XML processing steps such as XSLT transformations or XPath queries." ;
  rdfs:label "Import XML file" ;
  rdfs:seeAlso sml:ExportToXMLFile ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ImportXMLFromURL
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate sml:ignoreDoctype ;
      spl:valueType xsd:boolean ;
      rdfs:comment "An (optional) indicator to ignore the XML document type.  This will allow for opening documents where the DTD or schema may not be available." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      rdfs:comment "The output variable that will hold the loaded XML. Default: xml." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password if using BASIC authentication. If specified this module will attempt to make an HTTP basic auth call before pulling the XML from the source. Leave empty if calling a server without authentication." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The username if using BASIC authentication. If specified this module will attempt to make an HTTP basic auth call before pulling the XML from the source. Leave empty if calling a server without authentication." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      rdfs:comment "The URL to the XML file. May contain variables such as {?varName}." ;
    ] ;
  rdfs:comment "Gets XML from a given URL and binds the resulting XML document to a specified output variable. Note that this could either be used to load static XML files from the web, or to call web services that return XML." ;
  rdfs:label "Import XML from URL" ;
  rdfs:subClassOf sml:ImportFromRemoteModules ;
.
sml:IterateOverArguments
  a sm:Module ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body to execute with the two variable bindings (?argName and ?argValue)." ;
    ] ;
  rdfs:comment "In scripts that are called as web service, this module can be used to iterate over all arguments of the web service. In each iteration, the body will be executed with two variable bindings: the argument name (?argName) and argument value (?argValue), both as xsd:string literals. The result of the module itself will be the union of the results of all body iterations, comparable to sml:IterateOverSelect. In a typical scenario, the body would consist of sml:ApplyConstruct modules that turn the raw arguments into some more meaningful data structure, that is then further processed by the rest of the script." ;
  rdfs:label "Iterate over arguments" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:IterateOverSQL
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The (optional) password to log into the database. Can be left empty if the built-in security storage mechanism (of Eclipse/Equinox) shall be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name for the database." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:databaseType ;
      spl:valueType sml:DatabaseType ;
      rdfs:comment "The type of the database." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:sql ;
      spl:valueType xsd:string ;
      rdfs:comment "The SQL SELECT query to send to the database." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL of the database." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body of the iteration loop." ;
    ] ;
  rdfs:comment """Repeats a given sub-script for each matching result set of a given SQL Select query. The system will do a mapping of SQL values to suitable XSD datatypes.

The start of the sub-script is specified by the body property, and the input RDF of the body is the same as the input of the iteration module itself. The result variables of the Select query will be bound in each iteration of the loop.

The result of this module are the accumulated triples from the end nodes of the body scripts. No internal variable bindings of the body will be used outside of the body.""" ;
  rdfs:label "Iterate over SQL" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:IterateOverSelect
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:iterationVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a variable which will contain the iteration index in each loop, starting with 0." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:maxThreadCount ;
      spl:valueType xsd:integer ;
      rdfs:comment "Can be used to have the engine execute multiple iterations in parallel threads. The values should be between 2 and a reasonable max value such as 10. If set > 1, the engine will spawn off a new thread for each iteration. Note that some features of SPARQLMotion may not be available in this mode, and that care should be taken when using this feature. In particular, sml:ImportCurrentRDF (when used from TBE) will not work." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body of the iteration loop." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:selectQuery ;
      rdfs:comment "A SPARQL Select query that determines the variable bindings for the body in each iteration." ;
    ] ;
  rdfs:comment """Repeats a given sub-script for each matching result set for the SPARQL Select query in the module's selectQuery property.

The start of the sub-script is specified by the body property. There can only be one body property that invokes a single sub-script.  The sub-script must have one target module -- that is, the sub-script cannot have multiple termination points.

The input RDF for each iteration is the same as the input of the iteration module itself. The result variables of the Select query will be bound inside the body in each iteration of the sub-script. Also, if the sml:IterateOverSelect module itself receives input variable bindings, and the value of these variables are changed inside the body sub-script (e.g. using sml:AppendText or sml:BindLiteralVariable), then the end value of each iteration will be used in the sub-script itself, and thus also passed into the next iteration's body. This allows scripts to incrementally modify variables.  The property sml:iterationVariable can be used to name a variable that will keep an iteration count.

The result of this module are the accumulated triples from the end node of the body sub-script. No internal variable bindings of the body will be used outside of the body, unless they have had values before (see above).

In many cases, a better alternative to creating \"loops\" is to use SPARQL directly, and embed some of the control logic into the WHERE clause, possibly through a CONSTRUCT or UPDATE query.

It is possible to run the iterations in separate threads, e.g. to reduce the amount of time spent waiting on external network resources. This mode, activated by setting sml:maxThreadCount > 2, has some limitations (see description of sml:maxThreadCount) and should be considered by experienced users only.""" ;
  rdfs:label "Iterate over select" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:IterateOverXPath
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "xml" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable that will be bound in each iteration." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML node (document or element) to operate on." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xpath ;
      spl:valueType xsd:string ;
      rdfs:comment "The XPath to evaluate." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The body to execute in each iteration." ;
    ] ;
  rdfs:comment "Evaluates an XPath on a given XML document (or node) and executes a given body for each binding. The outputVariable will be bound in each iteration of the loop, bound to the XML node. The main use case of this module is in combination with sml:BindByXPath: IterateOverXPath walks through a list of top-level nodes and sml:BindByXPath is then used to extract individual values in each iteration." ;
  rdfs:label "Iterate over XPath" ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:IterateWhile
  a sm:Module ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sm:body ;
      rdfs:comment "The start of the script that shall be executed as body in each iteration. The body must end with a single target module." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:askQuery ;
      rdfs:comment "An ASK query that is executed prior to each iteration. If the query returns false, the iteration stops and the most recent result graph will be returned." ;
    ] ;
  rdfs:comment "Repeats a sub-script (specified as body) as long as a SPARQL ASK query returns true. The output of each iteration is the input to the next. The output of the whole module is the result of the last iteration. No variable bindings are passed into or out of the body." ;
  rdfs:label "Iterate while" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:JSONLD
  a sml:RDFSerialization ;
  rdfs:label "JSON-LD" ;
.
sml:Merge
  a sm:Module ;
  rdfs:comment "This module type can be used to merge the variables and RDF triples from multiple input modules. The same is done by any other SPARQLMotion script that has multiple input modules. So while the sml:Merge module basically does not do anything at all, it can be useful to create a clean structure in your script, particularly if you have a case when you want to merge multiple graphs and then have multiple outgoing sm:next links from the merged graph." ;
  rdfs:label "Merge" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:ModifyPrefixes
  a sm:Module ;
  spin:constraint [
      a spl:Attribute ;
      spl:minCount "0"^^xsd:int ;
      spl:predicate sml:addedPrefix ;
      rdfs:comment "Namespaces to add, in the format \"prefix namespace\", i.e. the prefix must be followed by a space. Example: \"my http://my.com#\"." ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:minCount "0"^^xsd:int ;
      spl:predicate sml:deletedPrefix ;
      rdfs:comment "The prefix(es) to delete, e.g. \"my\"." ;
    ] ;
  rdfs:comment "Can be used to add or delete namespace prefix declarations from the input RDF stream so that these new prefixes are visible down stream of this module." ;
  rdfs:label "Modify prefixes" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:MySQL
  a sml:DatabaseType ;
  rdfs:label "MySQL" ;
.
sml:N3
  a sml:RDFSerialization ;
  rdfs:comment "The N3 serialization format. In TopBraid this is only supported as the equivalent of Turtle and may be deleted in future versions." ;
  rdfs:label "N3" ;
.
sml:NTriple
  a sml:RDFSerialization ;
  rdfs:label "NTriple" ;
.
sml:Oracle
  a sml:DatabaseType ;
  rdfs:label "Oracle" ;
.
sml:OracleExportMode
  a rdfs:Class ;
  rdfs:comment "The export modes supported by Oracle RDF." ;
  rdfs:label "Oracle export mode" ;
  rdfs:subClassOf rdfs:Resource ;
  owl:equivalentClass [
      a owl:Class ;
      owl:oneOf (
          sml:ExportBatch
          sml:ExportBulk
          sml:ExportIncremental
        ) ;
    ] ;
.
sml:PerformFacetedSearch
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:search ;
      spl:valueType search:Search ;
      rdfs:comment "The Search to execute." ;
    ] ;
  rdfs:comment """Executes a faceted search. The main input to this module is a search:Search object that describes the search:Facets that shall be delivered and search:FacetValues used for filtering. The module will issue this search to the target specified in the Search and add the resulting counts to the search:Search object. By default, the Search will be executed against the RDF graph mentioned in search:queryGraph. However, if the Search is an instance of solr:Search, then it will be sent to a Solr server.

Note that the input resource will be modified and in a typical use case this should be in a temporary graph, such as one created with ui:createSessionGraph().""" ;
  rdfs:label "Perform faceted search" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:PerformUpdate
  a sm:Module ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount "1"^^xsd:int ;
      spl:minCount "1"^^xsd:int ;
      spl:predicate sml:updateQuery ;
      spl:valueType sp:Update ;
      rdfs:comment "The SPARQL 1.1 UPDATE request to perform.  Only one instance of this property will be executed." ;
    ] ;
  rdfs:comment """Performs a SPARQL UPDATE call to insert and/or delete triples.  This module differs from sml:ApplyConstruct (and other module types) by making persistent changes when the script runs.  Therefore this module should be used carefully.

The default graph of the WHERE clause is the input graph of the module, i.e. the result of its predecessors. However, these cannot be modified using INSERT or DELETE. Instead, a named graph needs to be provided there, e.g. using the GRAPH keyword in the INSERT or DELETE clauses.

Only one instance of sml:updateQuery will be executed.  For multiple SPARQL UPDATE statements use multiple PerformUpdate instances.

EVN/EDG users note that performing an update on a graph under teamwork control (urn:x-evn-...) does not execute EVN-specific side effects: no edit rules will fire and no change history entry may be created. You should always use ui:update in conjunction with sml:CreateSWPDocument to modify such graphs.""" ;
  rdfs:label "Perform update" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:PostRequest
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "response" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable to bind the result with." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:content ;
      spl:valueType xsd:string ;
      rdfs:comment "The content to send." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:contentType ;
      spl:valueType xsd:string ;
      rdfs:comment "The type of the content to be sent." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:encoding ;
      spl:valueType xsd:string ;
      rdfs:comment "The file encoding such as UTF-8. If left blank, the HTTP default (ISO-8859-1) will be used." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:password ;
      spl:valueType xsd:string ;
      rdfs:comment "The password to use for authentication - leave empty to rely on the password stored in secure storage. Only used if sml:userName is set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:userName ;
      spl:valueType xsd:string ;
      rdfs:comment "The user name for authentication." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:url ;
      spl:valueType xsd:string ;
      rdfs:comment "The URL to post to." ;
    ] ;
  rdfs:comment "Sends a POST request to a web server and binds the result stream with the outputVariable. The request will include variable bindings for all non-system properties of this module. For example, you can set arg:test to some value that will be mapped to the name-value-pair \\\"test\\\". The recommended way of doing this is to subclass the sml:PostRequest class and declare the additional arguments as spin:constraints. The user is allowed to send either the arguments or the content through the variable sml:content. If a variable starts with \"httpHeader_\" then the value will be used as HTTP request header with the partial name after the _." ;
  rdfs:label "Post request" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:PostgreSQL
  a sml:DatabaseType ;
  rdfs:label "PostgreSQL" ;
.
sml:ProcessingModules
  a sm:Module ;
  spin:abstract true ;
  composite:index "1"^^xsd:int ;
  rdfs:comment "Modules that process data, e.g. to transform, filter and map it." ;
  rdfs:label "Processing" ;
  rdfs:subClassOf sm:Modules ;
.
sml:RDFProcessingModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "RDF Processing" ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:RDFSerialization
  a rdfs:Class ;
  rdfs:comment "The various serialization formats of RDF/OWL files, including RDF/XML and Turtle." ;
  rdfs:label "RDF Serialization" ;
  rdfs:subClassOf sm:ValueType ;
.
sml:RDFXML
  a sml:RDFSerialization ;
  rdfs:label "RDF/XML" ;
.
sml:RDFXMLAbbrev
  a sml:RDFSerialization ;
  rdfs:label "RDF/XML-ABBREV" ;
.
sml:RefreshWorkspace
  a sm:Module ;
  rdfs:comment "Refreshes the TopBraid workspace so that changes to files made outside of TopBraid's control become known to the system, and all registries are updated. This is a low-level operation that should be used with care, ideally when no other processes are running." ;
  rdfs:label "Refresh workspace" ;
  rdfs:subClassOf sml:ImportFromLocalModules ;
.
sml:ReleaseLock
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "http://topbraid.org/sparqlmotionlib#DefaultLock" ;
      spl:predicate sml:uri ;
      rdfs:comment "the lock URI (either xsd:string or resource)" ;
    ] ;
  rdfs:comment "Releases any exclusive system lock that was identified by the URI given as an argument and received previously using sml:RequestLock." ;
  rdfs:label "Release lock" ;
  rdfs:seeAlso sml:RequestLock ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:RemoveUserDictionaryWord
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:word ;
      spl:valueType xsd:string ;
      rdfs:comment "The word to remove." ;
    ] ;
  rdfs:comment "Removed a given word from the user dictionary used for spell-checking (see sml:CheckSpelling)." ;
  rdfs:label "Remove user dictionary word" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:RenameFile
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:filePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to the file that shall be renamed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:newFileName ;
      spl:valueType xsd:string ;
      rdfs:comment "The new name of the file (excluding the path)." ;
    ] ;
  rdfs:label "Rename file" ;
  rdfs:subClassOf sml:FileProcessingModules ;
.
sml:RenameResources
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "A SELECT query with two result variables, \"new\" and \"old\"." ;
    ] ;
  rdfs:comment """\"Renames\" a given set of resources so that all the triples they appear in are changed to a use a different URI to downstream modules. Old and new resources are specified by a SELECT query that has two result variables: \"old\" (the resources to rename) and \"new\" to specify a new URI (either as a literal or URI resource).

Note that this module does not change the actual input graph, but only installs a filter above it. This filter may slow down succeeding operations, and you may want to \"assert\" the new graph (e.g., with a sml:ApplyConstruct) following this module.""" ;
  rdfs:label "Rename resources" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:RequestLock
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "http://topbraid.org/sparqlmotionlib#DefaultLock" ;
      spl:predicate sml:uri ;
      rdfs:comment "the lock URI (either xsd:string or resource)" ;
    ] ;
  rdfs:comment """Requests an exclusive system lock identified by the URI given as an argument. This will make sure that the following modules in the script can proceed without risking interrupts or concurrent modification exceptions for the duration of the lock. When another thread attempts to request a lock with the same URI, the module will wait until the lock is released and then continue execution. The lock will be released if the script terminates or sml:ReleaseLock is reached.

Please use this module with care and release the lock as quickly as possible to avoid contention issues. Other concurrent requests may need to wait until the script has been finished.""" ;
  rdfs:label "Request lock" ;
  rdfs:seeAlso sml:ReleaseLock ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:ResetSPINCaches
  a sm:Module ;
  rdfs:comment "Clears any cached results from SPIN functions marked as spin:cachable. This can be used to reset the cache after \"background data\" has been changed by a script. If such updates only happen periodically, spin:cachable can improve overall performance." ;
  rdfs:label "Reset SPIN caches" ;
  rdfs:subClassOf sml:ControlFlowModules ;
.
sml:ReturnNode
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:result ;
      rdfs:comment "the result, usually passed in from a previous module" ;
    ] ;
  rdfs:comment "Returns an RDF node as a result of a script. This module is typically used as exit point of a user-defined SPIN function and web service. The sm:returnModule of the function will point to this." ;
  rdfs:label "Return node" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnRDF
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue sml:RDFXML ;
      spl:predicate sml:serialization ;
      spl:valueType sm:ValueType ;
      rdfs:comment "The serialization format - must be sml:JSONLD, sml:RDFXML or sml:Turtle." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:baseURI ;
      spl:valueType xsd:string ;
      rdfs:comment "The base URI of the graph to serialize." ;
    ] ;
  rdfs:comment "Represents the exit point of a function that returns RDF. The function can be referenced from the outside (e.g., as a web service) by its URI or local name. The RDF triples will be serialized into Turtle, JSON-LD or RDF/XML." ;
  rdfs:label "Return RDF" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnSPARQLResults
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue sm:XML ;
      spl:optional true ;
      spl:predicate sml:serialization ;
      spl:valueType sm:ValueType ;
      rdfs:comment "the serialization format such as XML or JSON" ;
    ] ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:selectQuery ;
      rdfs:comment "The SELECT query to execute." ;
    ] ;
  rdfs:comment "Runs a SPARQL Select query and returns its result in the standard SPARQL output formats XML, JSON, CSV or TSV." ;
  rdfs:label "Return SPARQL results" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnSWPDocument
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:mimeType ;
      spl:valueType xsd:string ;
      rdfs:comment "Overrides the default mime type returned by the UISPIN engine." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:snippet ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only create a UISPIN snippet, e.g. without head/body." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:view ;
      spl:valueType ui:Node ;
      rdfs:comment "A UISPIN document to render. This document may reference the bound variables of this module." ;
    ] ;
  rdfs:comment """Creates an SWP document using the current variable bindings and returns the resulting document as HTML, XML, SVG or text to the caller of the web service.

Note that in order to insert a SWP view for a given resource (using ui:instanceView etc), you can use the snippet <ui:resourceView ui:resource=\"{= ?varName }\" />.

Also note that in order to use HTML or SVG tags in the sml:view, you will need to import the html.ttl or svg.ttl from the SWP ontologies into the script.""" ;
  rdfs:label "Return SWP document" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnText
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:optional true ;
      spl:predicate sml:mimeType ;
      rdfs:comment "The (optional) mime type of the result stream." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:fileName ;
      rdfs:comment "The (optional) file name of the result stream." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:text ;
      rdfs:comment "The text that shall be returned." ;
    ] ;
  rdfs:comment "Represents the exit point of a function that returns text (mimetype: text). The function can be referenced from the outside (e.g., as a web service) by its URI or local name." ;
  rdfs:label "Return text" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:ReturnXML
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text/xml" ;
      spl:optional true ;
      spl:predicate sml:mimeType ;
      rdfs:comment "The (optional) mime type of the result stream." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document that shall be returned." ;
    ] ;
  rdfs:comment "Represents the exit point of a function that returns XML. The function can be referenced from the outside (e.g., as a web service) by its URI or local name." ;
  rdfs:label "Return XML" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:SQLServer
  a sml:DatabaseType ;
  rdfs:label "Microsoft SQL Server" ;
.
sml:SelectedResourceArgument
  a spin:Template ;
  spin:labelTemplate "Selected Resource {?predicate}" ;
  rdfs:comment """A system argument representing the \"selected\" resource. This can be used to implement services that operate on the currently selected resource in TopBraid Composer or Ensemble. The value of this argument will be set automatically by the engine in TBC. In TBE the selected resource's URI needs to be passed in.
Note: this replaces sml:BindWithSelectedResource from older TBC versions.""" ;
  rdfs:label "Selected resource argument" ;
  rdfs:subClassOf spl:Argument ;
.
sml:SendEMails
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "A SPARQL Select query that binds instances of email:Message to send out. If left blank, all instances of email:Message in the input graph will be sent." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:smtpServer ;
      spl:valueType email:Server ;
      rdfs:comment "The SMTP server that shall be used to send the emails from. If no server has been specified, the default SMTP server from the TBL server configuration will be used." ;
    ] ;
  rdfs:comment "Sends one or more emails. In a typical scenario, previous steps such as sml:ApplyConstruct have created instances of email:Message. The body of the emails could be created using sml:CreateUISPINDocument. A SPARQL Select query is then used to select those messages that shall be sent out, based on the given server parameters." ;
  rdfs:label "Send emails" ;
  rdfs:subClassOf sml:ExportToRemoteModules ;
.
sml:SerializeSPARQLResults
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue sm:XML ;
      spl:optional true ;
      spl:predicate sml:serialization ;
      spl:valueType sm:ValueType ;
      rdfs:comment "The serialization format." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "text" ;
      spl:predicate sm:outputVariable ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the output variable that will contain the result." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "The SELECT query to execute." ;
    ] ;
  rdfs:comment "Executes a SPARQL SELECT query and serializes its result to either XML or JSON format." ;
  rdfs:label "Serialize SPARQLResults" ;
  rdfs:subClassOf sml:TextProcessingModules ;
.
sml:TextProcessingModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "Text Processing" ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:Turtle
  a sml:RDFSerialization ;
  rdfs:label "Turtle" ;
.
sml:UpdateUserWordDictionary
  a sm:Module ;
  a owl:DeprecatedClass ;
  spin:constraint [
      a spl:Attribute ;
      spl:maxCount 1 ;
      spl:minCount 1 ;
      spl:predicate sml:selectQuery ;
      spl:valueType sp:Select ;
      rdfs:comment "The SELECT query that delivers action (remove / add) and the literal that shall be removed / added from / to the dictionary of user specified words. <http://topbraid.org/spellcheckresults#removeWord> is used to specify remove action and <http://topbraid.org/spellcheckresults#addWord> is used to specify add action." ;
    ] ;
  rdfs:comment """SM Module for adding and removing words from the dictionary of user specified words. Words in the dictionary of user specified words are ignored by the CheckSpelling module.

Deprecated: Use sml:AddUserDictionaryWord and sml:RemoveUserDictionaryWord instead.""" ;
  rdfs:label "Update user word dictionary" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
  owl:deprecated true ;
.
sml:ValidateGraph
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:focusNode ;
      rdfs:comment "The focus node that should be validated - no other resource will be validated if present." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:generateSuggestions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to include dash:suggestions into the output graph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:ignoreImports ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to only validate the resources that appear as subject in a triple from the base graph. In other words, focus nodes defined only in imported graphs will be skipped by the SHACL engine." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:ignoreSPLConstraints ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to skip checking spl:Argument and spl:Attribute constraints. This can sometimes boost performance." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sml:shapesGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The shapes graph to use. Defaults to the data graph." ;
    ] ;
  rdfs:comment "Performs validation of the given input graph using SHACL shapes. Also includes SPIN constraints, although this may change in the future. The result graph consists of SHACL result instances such as sh:ValidationResult." ;
  rdfs:label "Validate graph" ;
  rdfs:subClassOf sml:RDFProcessingModules ;
.
sml:ValidateXMLAgainstXSD
  a sm:Module ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:schemaFilePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path to an XSD file. The path can be relative to the current script's folder (e.g., myFolder/test.xsd) or absolute to the workspace root /myProject/myFolder/test.xsd." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sml:xml ;
      rdfs:comment "The XML document that shall be validated. If this is represented as a string, then the errors will contain line numbers. Note that the output of modules such as sml:ImportXMLFromFile is not a string but an XML DOM, producing no line numbers." ;
    ] ;
  rdfs:comment "Validates an existing XML document against a given XML Schema. The XML Schema must be present in the workspace. The output of this module is a new graph containing instances of sxml:XSDValidationError or sxml:XSDValidationWarning. The rdfs:labels of those will contain more information on the error." ;
  rdfs:label "Validate XML against XSD" ;
  rdfs:subClassOf sml:XMLProcessingModules ;
.
sml:XMLProcessingModules
  a sm:Module ;
  spin:abstract true ;
  rdfs:label "XML Processing" ;
  rdfs:subClassOf sml:ProcessingModules ;
.
sml:addedPrefix
  a rdf:Property ;
  rdfs:label "addedPrefix" ;
  rdfs:range xsd:string ;
.
sml:arguments
  a rdf:Property ;
  rdfs:label "arguments" ;
.
sml:askQuery
  a rdf:Property ;
  rdfs:label "askQuery" ;
  rdfs:range sp:Ask ;
  rdfs:subPropertyOf spin:query ;
.
sml:baseURI
  a rdf:Property ;
  rdfs:comment "The base URI of an RDF model." ;
  rdfs:label "baseURI" ;
  rdfs:range xsd:string ;
.
sml:bindVariables
  a rdf:Property ;
  rdfs:label "bind variables" ;
  rdfs:range xsd:boolean ;
.
sml:buttonLabel
  a rdf:Property ;
  rdfs:label "button label" ;
  rdfs:range xsd:string ;
.
sml:cached
  a rdf:Property ;
  rdfs:label "cached" ;
  rdfs:range xsd:boolean ;
.
sml:cellQuery
  a rdf:Property ;
  rdfs:label "cellQuery" ;
  rdfs:range sp:Select ;
  rdfs:subPropertyOf spin:query ;
.
sml:class
  a rdf:Property ;
  rdfs:label "class" ;
  rdfs:range rdfs:Class ;
.
sml:className
  a rdf:Property ;
  rdfs:label "className" ;
  rdfs:range xsd:string ;
.
sml:columnQuery
  a rdf:Property ;
  rdfs:label "columnQuery" ;
  rdfs:range sp:Select ;
  rdfs:subPropertyOf spin:query ;
.
sml:constructQuery
  a rdf:Property ;
  rdfs:label "constructQuery" ;
  rdfs:range sp:Construct ;
  rdfs:subPropertyOf spin:query ;
.
sml:content
  a rdf:Property ;
  rdfs:label "content" ;
.
sml:contentType
  a rdf:Property ;
  rdfs:label "content type" ;
.
sml:createGraph
  a rdf:Property ;
  rdfs:label "create graph" ;
  rdfs:range xsd:boolean ;
.
sml:dataPath
  a rdf:Property ;
  rdfs:label "data path" ;
.
sml:databaseName
  a rdf:Property ;
  rdfs:label "database name" ;
  rdfs:range xsd:string ;
.
sml:databaseType
  a rdf:Property ;
  rdfs:label "database type" ;
  rdfs:range sml:DatabaseType ;
.
sml:datatype
  a rdf:Property ;
  rdfs:label "datatype" ;
  rdfs:range rdfs:Datatype ;
.
sml:datatypesBaseURI
  a rdf:Property ;
  rdfs:label "datatypes base URI" ;
  rdfs:range xsd:string ;
.
sml:deletedPrefix
  a rdf:Property ;
  rdfs:label "deletedPrefix" ;
  rdfs:range xsd:string ;
.
sml:document
  a rdf:Property ;
  rdfs:label "document" ;
.
sml:emailAccount
  a rdf:Property ;
  rdfs:label "emailAccount" ;
  rdfs:range email:Address ;
.
sml:encoding
  a rdf:Property ;
  rdfs:label "encoding" ;
  rdfs:range xsd:string ;
.
sml:fileName
  a rdf:Property ;
  rdfs:label "file name" ;
  rdfs:range xsd:string ;
.
sml:filePath
  a rdf:Property ;
  rdfs:label "file path" ;
  rdfs:range xsd:string ;
.
sml:filterGraph
  a rdf:Property ;
  rdfs:comment "Links a filter module with a predecessor module to mark the predecessor module graph to be used for filtering in the filter module." ;
  rdfs:label "filterGraph" ;
  rdfs:range spin:Modules ;
.
sml:flatten
  a rdf:Property ;
  rdfs:label "flatten" ;
.
sml:focusNode
  a rdf:Property ;
  rdfs:label "focus node" ;
.
sml:fullNamespaces
  a rdf:Property ;
  rdfs:label "full namespaces" ;
  rdfs:range xsd:boolean ;
.
sml:generateSuggestions
  a rdf:Property ;
  rdfs:label "generate suggestions" ;
  rdfs:range xsd:boolean ;
.
sml:graphName
  a rdf:Property ;
  rdfs:label "graph name" ;
  rdfs:range xsd:string ;
.
sml:hidden
  a rdf:Property ;
  rdfs:label "hidden" ;
  rdfs:range xsd:boolean ;
.
sml:html
  a rdf:Property ;
  rdfs:label "html" ;
  rdfs:range xsd:boolean ;
.
sml:ids
  a rdf:Property ;
  rdfs:label "IDs" ;
.
sml:ignoreBlankNodes
  a rdf:Property ;
  rdfs:label "ignore blank nodes" ;
  rdfs:range xsd:boolean ;
.
sml:ignoreDoctype
  a rdf:Property ;
  rdfs:label "ignore document type" ;
  rdfs:range xsd:boolean ;
.
sml:ignoreImports
  a rdf:Property ;
  rdfs:label "ignore imports" ;
  rdfs:range xsd:boolean ;
.
sml:ignoreSPLConstraints
  a rdf:Property ;
  rdfs:label "ignore SPL constraints" ;
  rdfs:range xsd:boolean ;
.
sml:importToInputGraph
  a rdf:Property ;
  rdfs:label "import to input graph" ;
  rdfs:range xsd:boolean ;
.
sml:initialize
  a rdf:Property ;
  rdfs:comment "Specifies that a module shall uncondionally initialize the triple store (SDB) it is writing to. If set to true (default is false), then all triples contained in the triple store will be permanently lost." ;
  rdfs:label "initialize" ;
  rdfs:range xsd:boolean ;
.
sml:inputVariable
  a rdf:Property ;
  rdfs:label "input variable" ;
  rdfs:range xsd:string ;
.
sml:instancePattern
  a rdf:Property ;
  rdfs:label "instancePattern" ;
  rdfs:range xsd:string ;
.
sml:iterationVariable
  a rdf:Property ;
  rdfs:comment "The name of a variable that shall contain the iteration index in a loop, starting at zero." ;
  rdfs:label "iteration variable" ;
  rdfs:range xsd:string ;
.
sml:jmsConnectionFactory
  a rdf:Property ;
.
sml:jmsDestination
  a rdf:Property ;
  rdfs:comment "The name of the JMS queue to send the message to." ;
  rdfs:label "jmssubject" ;
  rdfs:range xsd:string ;
.
sml:keepRootObject
  a rdf:Property ;
  rdfs:label "keep root object" ;
.
sml:key
  a rdf:Property ;
  rdfs:label "key" ;
  rdfs:range xsd:string ;
.
sml:maxThreadCount
  a rdf:Property ;
  rdfs:label "max thread count" ;
.
sml:mimeType
  a rdf:Property ;
  rdfs:comment "(Reserved for future use.)" ;
  rdfs:label "mimeType" ;
  rdfs:range xsd:string ;
.
sml:modelName
  a rdf:Property ;
  rdfs:label "modelName" ;
  rdfs:range xsd:string ;
.
sml:namespace
  a rdf:Property ;
  rdfs:label "namespace" ;
.
sml:needsTidy
  a rdf:Property ;
  rdfs:label "needs tidy" ;
.
sml:newFileName
  a rdf:Property ;
  rdfs:label "new file name" ;
  rdfs:range xsd:string ;
.
sml:newFilePath
  a rdf:Property ;
  rdfs:label "new file path" ;
  rdfs:range xsd:string ;
.
sml:newGraph
  a rdf:Property ;
  rdfs:label "new graph" ;
  rdfs:range spin:Modules ;
.
sml:noStringSubstitution
  a rdf:Property ;
  rdfs:label "no string substitution" ;
.
sml:oldFilePath
  a rdf:Property ;
  rdfs:label "old file path" ;
  rdfs:range xsd:string ;
.
sml:oldGraph
  a rdf:Property ;
  rdfs:label "old graph" ;
  rdfs:range spin:Modules ;
.
sml:onCommit
  a rdf:Property ;
  rdfs:label "on commit" ;
  rdfs:range xsd:boolean ;
.
sml:overrideFileName
  a rdf:Property ;
  rdfs:label "override file name" ;
.
sml:password
  a rdf:Property ;
  rdfs:label "password" ;
  rdfs:range xsd:string ;
.
sml:path
  a rdf:Property ;
  rdfs:comment "Can be used to represent path expressions such as /INBOX/TBC-MailingList" ;
  rdfs:label "path" ;
  rdfs:range xsd:string ;
.
sml:predicate
  a rdf:Property ;
  rdfs:label "predicate" ;
  rdfs:range rdf:Property ;
.
sml:propertyPrefix
  a rdf:Property ;
  rdfs:label "propertyPrefix" ;
  rdfs:range xsd:string ;
.
sml:query
  a rdf:Property ;
  rdfs:label "query" ;
.
sml:recursive
  a rdf:Property ;
  rdfs:label "recursive" ;
.
sml:replace
  a rdf:Property ;
  rdfs:comment "Specifies whether a module shall overwrite all triples from its predecessors. If set to true (default is false), then the triples from the predecessors shall not be passed through." ;
  rdfs:label "replace" ;
  rdfs:range xsd:boolean ;
.
sml:replaceInvalidValues
  a rdf:Property ;
  rdfs:label "replace invalid values" ;
  rdfs:range xsd:boolean ;
.
sml:result
  a rdf:Property ;
  rdfs:label "result" ;
.
sml:resultURI
  a rdf:Property ;
  rdfs:label "result URI" ;
.
sml:rowQuery
  a rdf:Property ;
  rdfs:label "rowQuery" ;
  rdfs:range sp:Select ;
  rdfs:subPropertyOf spin:query ;
.
sml:ruleBaseName
  a rdf:Property ;
  rdfs:label "ruleBaseName" ;
  rdfs:range xsd:string ;
.
sml:sampleCount
  a rdf:Property ;
  rdfs:label "sample count" ;
  rdfs:range xsd:integer ;
.
sml:schemaFilePath
  a rdf:Property ;
  rdfs:label "schema file path" ;
  rdfs:range xsd:string ;
.
sml:schemaNamespace
  a rdf:Property ;
  rdfs:label "schemaNamespace" ;
  rdfs:range xsd:string ;
.
sml:search
  a rdf:Property ;
  rdfs:label "search" ;
.
sml:securePasswordURL
  a rdf:Property ;
  rdfs:label "secure password URL" ;
  rdfs:range xsd:string ;
.
sml:selectQuery
  a rdf:Property ;
  rdfs:label "select query" ;
  rdfs:range sp:Select ;
  rdfs:subPropertyOf spin:query ;
.
sml:selectedResource
  a rdf:Property ;
  rdfs:comment "The suggested default property to use in conjunction with sml:SelectedResourceArgument." ;
  rdfs:label "selected resource" ;
.
sml:separator
  a rdf:Property ;
  rdfs:label "separator" ;
  rdfs:range xsd:string ;
.
sml:serialization
  a rdf:Property ;
  rdfs:label "serialization" ;
  rdfs:range sml:RDFSerialization ;
.
sml:service
  a rdf:Property ;
  rdfs:label "service" ;
.
sml:shape
  a rdf:Property ;
  rdfs:label "shape" ;
.
sml:shapesGraph
  a rdf:Property ;
  rdfs:label "shapes graph" ;
  rdfs:range rdfs:Resource ;
.
sml:singlePass
  a rdf:Property ;
  rdfs:label "single pass" ;
  rdfs:range xsd:boolean ;
.
sml:smtpServer
  a rdf:Property ;
  rdfs:label "smtpServer" ;
  rdfs:range email:Server ;
.
sml:snippet
  a rdf:Property ;
  rdfs:label "snippet" ;
.
sml:sourceFilePath
  a rdf:Property ;
  rdfs:comment "The path to a file relative in the execution context (workspace). Values can be relative to the currently executing script (e.g., subFolder/file.txt) or absolute to the workspace root (starting with /)." ;
  rdfs:label "sourceFilePath" ;
  rdfs:range xsd:string ;
.
sml:sourceURL
  a rdf:Property ;
  rdfs:label "source URL" ;
.
sml:sql
  a rdf:Property ;
  rdfs:label "sql" ;
.
sml:stackTraceVariable
  a rdf:Property ;
  rdfs:label "stack trace variable" ;
  rdfs:range xsd:string ;
.
sml:targetFilePath
  a rdf:Property ;
  rdfs:label "targetFilePath" ;
  rdfs:range xsd:string ;
.
sml:targetGraph
  a rdf:Property ;
  rdfs:label "target graph" ;
.
sml:template
  a rdf:Property ;
  rdfs:label "template" ;
  rdfs:range xsd:string ;
.
sml:text
  a rdf:Property ;
  rdfs:label "text" ;
  rdfs:range xsd:string ;
.
sml:title
  a rdf:Property ;
  rdfs:label "title" ;
  rdfs:range xsd:string ;
.
sml:updateQuery
  a rdf:Property ;
  rdfs:comment "A SPARQL UPDATE query (can be used to insert or delete triples from a graph)." ;
  rdfs:label "update query" ;
  rdfs:range sp:Update ;
.
sml:uri
  a rdf:Property ;
  rdfs:label "uri" ;
  rdfs:range xsd:string ;
.
sml:url
  a rdf:Property ;
  rdfs:label "url" ;
  rdfs:range xsd:string ;
.
sml:useURIs
  a rdf:Property ;
  rdfs:label "use URIs" ;
.
sml:useUnderscore
  a rdf:Property ;
  rdfs:label "useUnderscore" ;
  rdfs:range xsd:boolean ;
.
sml:useVerbatim
  a rdf:Property ;
  rdfs:label "useVerbatim" ;
  rdfs:range xsd:boolean ;
.
sml:userName
  a rdf:Property ;
  rdfs:label "userName" ;
  rdfs:range xsd:string ;
.
sml:value
  a rdf:Property ;
  rdfs:label "value" ;
.
sml:variable
  a rdf:Property ;
  rdfs:label "variable" ;
  rdfs:range xsd:string ;
.
sml:view
  a rdf:Property ;
  rdfs:label "view" ;
.
sml:withDatatypeLinks
  a rdf:Property ;
  rdfs:label "with datatype links" ;
  rdfs:range xsd:boolean ;
.
sml:withDatatypes
  a rdf:Property ;
  rdfs:label "with datatypes" ;
  rdfs:range xsd:boolean ;
.
sml:withSamples
  a rdf:Property ;
  rdfs:label "with data samples" ;
  rdfs:range xsd:boolean ;
.
sml:withSchema
  a rdf:Property ;
  rdfs:label "with schema" ;
  rdfs:range xsd:boolean ;
.
sml:withStats
  a rdf:Property ;
  rdfs:label "with data statistics" ;
  rdfs:range xsd:boolean ;
.
sml:word
  a rdf:Property ;
  rdfs:label "word" ;
  rdfs:range xsd:string ;
.
sml:xml
  a rdf:Property ;
  rdfs:label "xml" ;
  rdfs:range rdf:XMLLiteral ;
.
sml:xmlType
  a rdf:Property ;
  rdfs:label "xmlType" ;
  rdfs:range [] ;
.
sml:xpath
  a rdf:Property ;
  rdfs:comment "An XPath expression." ;
  rdfs:label "xpath" ;
  rdfs:range xsd:string ;
.
<http://topbraid.org/sparqlmotionlib-core>
  a owl:Ontology ;
  rdfs:comment "The library of SPARQLMotion core modules that are available in any SPARQLMotion-compliant engine, including the TopBraid platform and the TopBraid API." ;
  owl:imports <http://spinrdf.org/spif> ;
  owl:imports <http://spinrdf.org/spr> ;
  owl:imports <http://topbraid.org/sparqlmotion> ;
  owl:imports <http://www.topbraid.org/2007/05/composite.owl> ;
.
<http://topbraid.org/sparqlmotionlib-tb>
  a owl:Ontology ;
  rdfs:comment "A library of SPARQLMotion modules that are supported by the TopBraid platform, including TopBraid Live and Composer." ;
  owl:imports <http://datashapes.org/graphql> ;
  owl:imports <http://topbraid.org/email> ;
  owl:imports <http://topbraid.org/search> ;
  owl:imports <http://topbraid.org/sparqlmotionfunctions> ;
  owl:imports <http://topbraid.org/sparqlmotionlib-core> ;
  owl:imports <http://uispin.org/ui> ;
.
<http://topbraid.org/tosh>
  a owl:Ontology ;
  rdfs:comment """A collection of SHACL features that are used whenever SHACL graphs are used within TopBraid Suite products. This includes things like suggested PropertyGroups and Shapes that control the layout of forms. Some of these may be of general use outside of TopBraid too.

This namespace also includes the function tosh:hasShape, which can be used to implement some advanced constraint components using SPARQL only.""" ;
  rdfs:label "TopBraid Data Shapes Library" ;
  owl:imports <http://datashapes.org/dash> ;
  sh:declare [
      a sh:PrefixDeclaration ;
      sh:namespace "http://jena.hpl.hp.com/ARQ/function#"^^xsd:anyURI ;
      sh:prefix "afn" ;
    ] ;
  sh:declare [
      a sh:PrefixDeclaration ;
      sh:namespace "http://spinrdf.org/spif#"^^xsd:anyURI ;
      sh:prefix "spif" ;
    ] ;
  sh:declare [
      a sh:PrefixDeclaration ;
      sh:namespace "http://topbraid.org/sparqlmotionfunctions#"^^xsd:anyURI ;
      sh:prefix "smf" ;
    ] ;
  sh:declare [
      a sh:PrefixDeclaration ;
      sh:namespace "http://topbraid.org/tosh#"^^xsd:anyURI ;
      sh:prefix "tosh" ;
    ] ;
.
tosh:
  tosh:systemNamespace true ;
.
tosh:AboutPropertyGroup
  a sh:PropertyGroup ;
  rdfs:label "This Shape" ;
  sh:order 0 ;
.
tosh:CardinalityConstraintPropertyGroup
  a sh:PropertyGroup ;
  rdfs:label "Number of Values" ;
  sh:order 2 ;
.
tosh:ComplexConstraintPropertyGroup
  a sh:PropertyGroup ;
  tosh:editGroupDescription "Most edit fields in this section currently require Turtle source code, esp to enter blank node expressions. To reference existing shapes via their URI, enter them as <URI>." ;
  tosh:openable true ;
  rdfs:label "Complex Constraint Expressions" ;
  sh:order 9 ;
.
tosh:ConstraintMetadataPropertyGroup
  a sh:PropertyGroup ;
  rdfs:label "Constraint Metadata" ;
.
tosh:DeleteTripleSuggestionGenerator
  a dash:SPARQLUpdateSuggestionGenerator ;
  rdfs:comment "Produces a suggestion that would delete the offending value in the validation result from the focus node." ;
  rdfs:label "Delete triple suggestion generator" ;
  sh:message "Delete the invalid statement" ;
  sh:order 100 ;
  sh:update """DELETE {
	$focusNode $predicate $value .
}
WHERE {
	$focusNode $predicate $value .
}""" ;
.
tosh:DisplayPropertyGroup
  a sh:PropertyGroup ;
  rdfs:comment "A group for properties that are primarily for display purposes (names, ordering etc)." ;
  rdfs:label "Display Settings" ;
  sh:order 1 ;
.
tosh:InferencesPropertyGroup
  a sh:PropertyGroup ;
  tosh:openable true ;
  rdfs:label "Inferences" ;
  sh:order "11"^^xsd:decimal ;
.
tosh:MemberShapeConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "Can be used to specify constraints on the members of a given list, assuming that the given sh:property has rdf:Lists as values. A violation is reported for each member of the list that does not comply with the constraints specified by the given shape." ;
  rdfs:label "Member shape constraint component" ;
  sh:parameter tosh:MemberShapeConstraintComponent-memberShape ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "List member {?member} does not have the shape {$memberShape}" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT DISTINCT $this ?value ?failure ?member
		WHERE {
			$this $PATH ?value .
			?value rdf:rest*/rdf:first ?member .
			BIND (tosh:hasShape(?member, $memberShape) AS ?hasShape) .
			BIND (!bound(?hasShape) AS ?failure) .
			FILTER (?failure || !?hasShape) .
		}
""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
tosh:MemberShapeConstraintComponent-memberShape
  a sh:Parameter ;
  sh:path tosh:memberShape ;
  sh:class sh:Shape ;
  sh:description "The shape that the list members must have." ;
  sh:name "member shape" ;
.
tosh:OtherConstraintPropertyGroup
  a sh:PropertyGroup ;
  tosh:openable true ;
  rdfs:label "Other Constraints" ;
  sh:order 10 ;
.
tosh:PrimaryKeyPropertyGroup
  a sh:PropertyGroup ;
  tosh:openable true ;
  rdfs:label "Primary Key" ;
  sh:order 6.5 ;
.
tosh:PropertyGroupShape
  a sh:NodeShape ;
  rdfs:label "Property group shape" ;
  sh:property [
      sh:path sh:order ;
      sh:maxCount 1 ;
    ] ;
  sh:targetClass sh:PropertyGroup ;
.
tosh:PropertyPairConstraintPropertyGroup
  a sh:PropertyGroup ;
  tosh:openable true ;
  rdfs:label "Relationship to Other Properties" ;
  sh:order 6 ;
.
tosh:PropertyShapeShape
  a sh:NodeShape ;
  rdfs:label "Property shape shape" ;
  sh:property tosh:PropertyShapeShape-name ;
  sh:property [
      a sh:PropertyShape ;
      sh:path sh:values ;
      tosh:editWidget swa:SourceCodeEditor ;
      tosh:viewWidget <http://topbraid.org/tosh.ui#ValuesExpressionDiagramViewer> ;
      sh:group tosh:InferencesPropertyGroup ;
      sh:name "values" ;
      sh:order "1"^^xsd:decimal ;
      sh:sparql [
          sh:message "sh:values must be accompanied by a sh:path that is an IRI." ;
          sh:prefixes <http://topbraid.org/tosh> ;
          sh:select """SELECT $this ?value
WHERE {
	$this $PATH ?value .
    FILTER NOT EXISTS {
		$this sh:path ?path .
		FILTER isIRI(?path)
	}
}""" ;
        ] ;
    ] ;
  sh:property [
      sh:path tosh:editWidget ;
      tosh:editWidget swa:WidgetDropDownEditor ;
      tosh:viewWidget swa:ResourceInUIGraphViewer ;
      sh:description "The swa:ObjectEditorClass that shall be used to edit values of this predicate." ;
      sh:group tosh:DisplayPropertyGroup ;
      sh:maxCount 1 ;
      sh:name "edit widget" ;
      sh:nodeKind sh:IRI ;
      sh:order 21 ;
    ] ;
  sh:property [
      sh:path tosh:searchWidget ;
      tosh:editWidget swa:WidgetDropDownEditor ;
      tosh:viewWidget swa:ResourceInUIGraphViewer ;
      sh:description "The swa:ObjectFacetClass that shall be used to search for values of this predicate." ;
      sh:group tosh:DisplayPropertyGroup ;
      sh:maxCount 1 ;
      sh:name "search widget" ;
      sh:nodeKind sh:IRI ;
      sh:order 22 ;
    ] ;
  sh:property [
      sh:path tosh:viewWidget ;
      tosh:editWidget swa:WidgetDropDownEditor ;
      tosh:viewWidget swa:ResourceInUIGraphViewer ;
      sh:description "The swa:ObjectViewerClass that shall be used to view values of this predicate." ;
      sh:group tosh:DisplayPropertyGroup ;
      sh:maxCount 1 ;
      sh:name "view widget" ;
      sh:nodeKind sh:IRI ;
      sh:order 20 ;
    ] ;
  sh:property [
      sh:path sh:defaultValue ;
      tosh:editWidget <http://topbraid.org/tosh.ui#UseDeclaredDatatypeEditor> ;
      tosh:useDeclaredDatatype true ;
      tosh:viewWidget <http://topbraid.org/tosh.ui#DefaultValueViewer> ;
      sh:description "The default value to be used for this property if no other value has been asserted. This may be a constant value or a SHACL node expression, in which case the values can be derived from other values. Default values are typically inferred and not stored as RDF statements." ;
      sh:group tosh:ValueTypeConstraintPropertyGroup ;
    ] ;
  sh:property [
      sh:path sh:description ;
      tosh:editWidget swa:TextAreaEditor ;
      sh:description "A human-readable description of the role of the property in the constraint." ;
      sh:group tosh:DisplayPropertyGroup ;
      sh:name "description" ;
      sh:order 2 ;
    ] ;
  sh:property [
      sh:path sh:disjoint ;
      sh:group tosh:PropertyPairConstraintPropertyGroup ;
      sh:order 1 ;
    ] ;
  sh:property [
      sh:path sh:equals ;
      sh:group tosh:PropertyPairConstraintPropertyGroup ;
      sh:order 0 ;
    ] ;
  sh:property [
      sh:path sh:group ;
      sh:description "The sh:PropertyGroup that the property belongs to." ;
      sh:group tosh:DisplayPropertyGroup ;
      sh:maxCount 1 ;
      sh:name "group" ;
      sh:order 10 ;
    ] ;
  sh:property [
      sh:path sh:lessThan ;
      sh:group tosh:PropertyPairConstraintPropertyGroup ;
      sh:order 2 ;
    ] ;
  sh:property [
      sh:path sh:lessThanOrEquals ;
      sh:group tosh:PropertyPairConstraintPropertyGroup ;
      sh:order 3 ;
    ] ;
  sh:property [
      sh:path sh:name ;
      tosh:editWidget swa:TextFieldEditorWithLang ;
      sh:description "The display name of the property." ;
      sh:group tosh:DisplayPropertyGroup ;
      sh:name "name" ;
      sh:order 1 ;
    ] ;
  sh:property [
      sh:path sh:order ;
      sh:description "The relative position of the property among its peers, e.g. a property with order 5 shows up before one with order 6." ;
      sh:group tosh:DisplayPropertyGroup ;
      sh:maxCount 1 ;
      sh:name "order" ;
      sh:order 11 ;
    ] ;
  sh:property [
      sh:path sh:path ;
      tosh:editWidget <http://topbraid.org/tosh.ui#PathEditor> ;
      tosh:viewWidget <http://topbraid.org/tosh.ui#PathViewer> ;
      sh:group tosh:AboutPropertyGroup ;
      sh:maxCount 1 ;
      sh:minCount 1 ;
      sh:name "on property" ;
      sh:order 0 ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
tosh:PropertyShapeShape-name
  a sh:PropertyShape ;
  sh:path graphql:name ;
  tosh:editWidget swa:PlainTextFieldEditor ;
  sh:description "The name of the associated GraphQL field, must follow GraphQL naming syntax." ;
  sh:group tosh:AboutPropertyGroup ;
  sh:name "GraphQL field name" ;
  sh:order 0.5 ;
.
tosh:RelationshipPropertyGroup
  a sh:PropertyGroup ;
  tosh:openable true ;
  rdfs:label "Relationship" ;
  sh:order 8 ;
.
tosh:ReplaceWithDefaultValueSuggestionGenerator
  a dash:SPARQLUpdateSuggestionGenerator ;
  rdfs:comment "Produces a suggestion to replace all values of the given predicate (which must exist) at the focus node to the default value declared at the shape that has caused the violation. Does nothing if the shape does not declare a sh:defaultValue. Deletes any old value of the property." ;
  rdfs:label "Replace with default value suggestion generator" ;
  sh:message "Replace with default value" ;
  sh:prefixes <http://topbraid.org/tosh> ;
  sh:select """SELECT ?defaultValue
WHERE {
	GRAPH $shapesGraph {
		$sourceShape sh:defaultValue ?defaultValue .
	}
}""" ;
  sh:update """DELETE {
	$focusNode $predicate ?oldValue .
}
INSERT {
	$focusNode $predicate ?defaultValue .
}
WHERE {
	$focusNode $predicate ?oldValue .
}""" ;
.
tosh:SetToDefaultValueSuggestionGenerator
  a dash:SPARQLUpdateSuggestionGenerator ;
  rdfs:comment "Produces a suggestion to set the given predicate at the focus node to the default value declared at the shape that has caused the violation. Does nothing if the shape does not declare a sh:defaultValue. Deletes any old value of the property." ;
  rdfs:label "Set to default value suggestion generator" ;
  sh:message "Set to default value" ;
  sh:prefixes <http://topbraid.org/tosh> ;
  sh:select """SELECT ?defaultValue
WHERE {
	GRAPH $shapesGraph {
		$sourceShape sh:defaultValue ?defaultValue .
	}
}""" ;
  sh:update """DELETE {
	$focusNode $predicate ?oldValue .
}
INSERT {
	$focusNode $predicate ?defaultValue .
}
WHERE {
	OPTIONAL {
		$focusNode $predicate ?oldValue .
	}
}""" ;
.
tosh:ShapeInGraphConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  rdfs:comment "A constraint component that can be used to verify that the value nodes have a given shape, where the shape validation is executed in a given graph. This can, for example, be used to verify that a given value is declared as an instance of a given class in some specified (not imported) graph." ;
  rdfs:label "Shape in graph constraint component" ;
  sh:labelTemplate "Values must have shape {$shapeInGraph} defined in graph {$graph}" ;
  sh:message "Value does not have shape {$shapeInGraph} defined in graph {$graph}" ;
  sh:parameter [
      sh:path tosh:graph ;
      sh:nodeKind sh:IRI ;
    ] ;
  sh:parameter [
      sh:path tosh:shapeInGraph ;
      sh:nodeKind sh:BlankNodeOrIRI ;
    ] ;
  sh:validator [
      a sh:SPARQLAskValidator ;
      sh:ask """ASK {
    GRAPH $graph {
		FILTER tosh:hasShape($value, $shapeInGraph)
	}
}""" ;
      sh:prefixes <http://topbraid.org/tosh> ;
    ] ;
.
tosh:ShapeShape
  a sh:NodeShape ;
  rdfs:label "Shape of shapes" ;
  sh:property tosh:ShapeShape-deactivated ;
  sh:property tosh:ShapeShape-severity ;
  sh:targetClass sh:Shape ;
.
tosh:ShapeShape-deactivated
  a sh:PropertyShape ;
  sh:path sh:deactivated ;
  sh:description "Can be used to deactivate the whole constraint." ;
  sh:group tosh:AboutPropertyGroup ;
  sh:maxCount 1 ;
  sh:name "deactivated" ;
  sh:order "1"^^xsd:decimal ;
.
tosh:ShapeShape-severity
  a sh:PropertyShape ;
  sh:path sh:severity ;
  tosh:editWidget swa:InstancesSelectEditor ;
  sh:class sh:Severity ;
  sh:description "The severity to be used for validation results produced by the associated constraint." ;
  sh:group tosh:AboutPropertyGroup ;
  sh:maxCount 1 ;
  sh:name "severity" ;
  sh:order "2"^^xsd:decimal ;
.
tosh:StringBasedConstraintPropertyGroup
  a sh:PropertyGroup ;
  tosh:openable true ;
  rdfs:label "Constraints for Strings and Text" ;
  sh:order 7 ;
.
tosh:SystemNamespaceShape
  a sh:NodeShape ;
  rdfs:comment "A shape that detects whether the focus node is a URI that has a namespace from one of the system namespaces - RDF, RDFS, OWL etc. The list of actual system namespaces is represented via tosh:systemNamespace true triples." ;
  rdfs:label "System namespace shape" ;
  sh:sparql [
      a sh:SPARQLConstraint ;
      sh:message "Not a IRI from a system namespace" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """SELECT $this
WHERE {
    FILTER (!isIRI($this) ||
			(isIRI($this) && EXISTS {
				BIND (IRI(afn:namespace($this)) AS ?ns) .
				FILTER NOT EXISTS { ?ns tosh:systemNamespace true } .
			} )) .
}""" ;
    ] ;
.
tosh:TeamworkPlatform
  a dash:ExecutionPlatform ;
  dash:includedExecutionPlatform tosh:TopBraidPlatform ;
  rdfs:comment "The platform consisting of TopBraid plus any teamwork features used by TopBraid EDG." ;
  rdfs:label "Teamwork platform" ;
.
tosh:TopBraidPlatform
  a dash:ExecutionPlatform ;
  rdfs:comment "The platform consisting of TopBraid." ;
  rdfs:label "TopBraid platform" ;
.
tosh:UseDeclaredDatatypeConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Change datatype of the invalid value to the specified sh:datatype" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:update """DELETE {
	$subject $predicate $object .
}
INSERT {
	$subject $predicate ?newObject .
}
WHERE {
	$subject sh:datatype ?datatype .
	BIND (spif:cast(?object, ?datatype) AS ?newObject) .
}""" ;
    ] ;
  rdfs:comment "Constrains the value nodes to be either non-literals or literals that have the same datatype as the declared sh:datatype for the given constraint node. This is used, among others, in properties such as sh:hasValue and sh:minExclusive." ;
  rdfs:label "Use declared datatype constraint component" ;
  sh:parameter [
      sh:path tosh:useDeclaredDatatype ;
      sh:datatype xsd:boolean ;
      sh:description "True to state that the datatype of literal values must be the same as the declared sh:datatype." ;
      sh:name "use declared datatype" ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Datatype must match the declared datatype {?datatype}" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT DISTINCT $this ?value ?datatype
		WHERE {
			{
				FILTER ($useDeclaredDatatype)
			}
			$this sh:datatype ?datatype .
			$this $PATH ?value .
			FILTER (isLiteral(?value) && datatype(?value) != ?datatype) .
		}""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
tosh:ValueRangeConstraintPropertyGroup
  a sh:PropertyGroup ;
  tosh:openable true ;
  rdfs:label "Min/Max Values" ;
  sh:order 5 ;
.
tosh:ValueTypeConstraintPropertyGroup
  a sh:PropertyGroup ;
  tosh:editGroupDescription "Hint: Use \"or\" under Complex Constraints to represent choices between multiple value types." ;
  rdfs:comment "A property group for constraint parameters that restrict the value types of values." ;
  rdfs:label "Type of Values" ;
  sh:order 3 ;
.
tosh:component
  a rdf:Property ;
.
tosh:context
  a rdf:Property ;
.
tosh:countShapesWithMatchResult
  a sh:SPARQLFunction ;
  rdfs:comment "Counts the number of shapes from a given rdf:List (?arg2) defined in a given shapes graph (?arg3) where tosh:hasShape returns the provided match value (true or false, ?arg4) for a given focus node (?arg1). The function produces a failure if one of the shapes validated to a failure." ;
  rdfs:label "count shapes with match result" ;
  sh:parameter [
      sh:path sh:expectedValue ;
      sh:datatype xsd:boolean ;
      sh:description "The expected value of tosh:hasShape to count." ;
      sh:order 3 ;
    ] ;
  sh:parameter [
      sh:path sh:focusNode ;
      sh:class rdfs:Resource ;
      sh:description "The focus node." ;
      sh:order 0 ;
    ] ;
  sh:parameter [
      sh:path sh:shapes ;
      sh:class rdf:List ;
      sh:description "The list of shapes to walk through." ;
      sh:order 1 ;
    ] ;
  sh:parameter [
      sh:path sh:shapesGraph ;
      sh:class rdfs:Resource ;
      sh:description "The shapes graph." ;
      sh:order 2 ;
    ] ;
  sh:prefixes <http://topbraid.org/tosh> ;
  sh:returnType xsd:integer ;
  sh:select """
		# The SUM will fail with an error if one of the operands is not a number
		# (this mechanism is used to propagate errors from tosh:hasShape calls)
		SELECT (SUM(?s) AS ?result)
		WHERE {
			GRAPH $shapesGraph {
				$shapes rdf:rest*/rdf:first ?shape .
			}
			BIND (tosh:hasShape($focusNode, ?shape, true) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(?hasShape = $expectedValue, 1, 0), 'error') AS ?s) .
		}
		""" ;
.
tosh:editGroupDescription
  a rdf:Property ;
  rdfs:comment "A description of the property group when in \"edit\" mode." ;
  rdfs:domain sh:PropertyGroup ;
  rdfs:label "edit group description" ;
  rdfs:range xsd:string ;
.
tosh:editWidget
  a rdf:Property ;
  rdfs:label "edit widget" ;
  rdfs:range swa:ObjectEditorClass ;
.
tosh:graph
  a rdf:Property ;
  rdfs:comment "The graph that the shape is validated in." ;
  rdfs:label "graph" ;
.
tosh:hasDatatype
  a sh:SPARQLAskValidator ;
  rdfs:comment "Checks whether a given node ($value) is a literal with a given datatype ($datatype), and that the literal is well-formed." ;
  rdfs:label "has datatype" ;
  sh:ask """
		ASK {
			FILTER (datatype($value) = $datatype && spif:isValidForDatatype($value, $datatype)) .
		}
		""" ;
  sh:prefixes <http://topbraid.org/tosh> ;
.
tosh:hasShape
  a sh:Function ;
  rdfs:comment """A built-in function of the TopBraid SHACL implementation.
		Can be used to validate a given (focus) node against a given shape,
		returning <code>true</code> if the node is valid.
		
		If executed within a SHACL validation engine, this uses the shapes graph that was provided when the engine started.
		If executed in other contexts, e.g. in a stand-alone SPARQL query, the function attempts to use the URI of the current
		default graph as the shapes graph. This may not always be supported. If called from within an SWP engine, the
		shapes graph is the current query graph."""^^rdf:HTML ;
  rdfs:label "has shape" ;
  sh:parameter [
      sh:path tosh:node ;
      sh:description "The node to validate." ;
    ] ;
  sh:parameter [
      sh:path tosh:shape ;
      sh:description "The shape that the node is supposed to have." ;
    ] ;
  sh:returnType xsd:boolean ;
.
tosh:isInTargetOf
  a sh:Function ;
  rdfs:comment "Checks whether a given node is in the target of a given shape." ;
  rdfs:label "is in target of" ;
  sh:parameter [
      sh:path tosh:node ;
      sh:description "The node to check." ;
      sh:name "node" ;
    ] ;
  sh:parameter [
      sh:path tosh:shape ;
      sh:class sh:Shape ;
      sh:description "The shape that the node is supposed to be in the target of." ;
      sh:name "shape" ;
    ] ;
  sh:returnType xsd:boolean ;
.
tosh:memberShape
  a rdf:Property ;
.
tosh:node
  a rdf:Property ;
.
tosh:open
  a rdf:Property ;
  rdfs:comment "If set to true, then the corresponding form section will be open by default. This only has an effect if sh:openable is set to true as well." ;
  rdfs:domain sh:PropertyGroup ;
  rdfs:label "open" ;
  rdfs:range xsd:boolean ;
.
tosh:openable
  a rdf:Property ;
  rdfs:comment "If set to true, then the corresponding form section shall be openable/closable (and show up closed)." ;
  rdfs:domain sh:PropertyGroup ;
  rdfs:label "openable" ;
  rdfs:range xsd:boolean ;
.
tosh:searchWidget
  a rdf:Property ;
  rdfs:label "search widget" ;
  rdfs:range swa:ObjectFacetClass ;
.
tosh:shaclExists
  a sh:Function ;
  rdfs:comment "Checks whether the current query graph has SHACL activated, i.e. imports the triples typically found in the SHACL namespace. This is currently relying on an approximation, only certain triples, and is natively implemented for TopBraid. Future versions may expose the actual logic as a SPARQL query." ;
  rdfs:label "SHACL exists" ;
  sh:returnType xsd:boolean ;
.
tosh:shape
  a rdf:Property ;
.
tosh:shapeInGraph
  a rdf:Property ;
  rdfs:comment "The shape that the value nodes must have." ;
  rdfs:label "shape in graph" ;
.
tosh:systemNamespace
  a rdf:Property ;
  rdfs:comment "Can be used to mark namespace resources (subjects) to count as \"system namespace\" that should be filtered by tosh:SystemNamespaceShape. Search for the usage of this predicate for examples. Anyone can add their own namespaces to their graphs." ;
  rdfs:label "system namespace" ;
  rdfs:range xsd:boolean ;
.
tosh:useDeclaredDatatype
  a rdf:Property ;
.
tosh:validatorForContext
  a sh:SPARQLFunction ;
  rdfs:comment "Gets a suitable validator for a given context, following the resolution rules from the spec." ;
  rdfs:label "validator for context" ;
  sh:parameter [
      sh:path tosh:component ;
      sh:class sh:ConstraintComponent ;
      sh:description "The constraint component." ;
      sh:name "component" ;
    ] ;
  sh:parameter [
      sh:path tosh:context ;
      sh:class rdfs:Class ;
      sh:description "The context, e.g. sh:PropertyShape." ;
      sh:name "context" ;
    ] ;
  sh:prefixes <http://topbraid.org/tosh> ;
  sh:returnType sh:Validator ;
  sh:select """
  		SELECT ?validator
		WHERE {
			{
				BIND (IF($context = sh:PropertyShape, sh:propertyValidator, sh:nodeValidator) AS ?predicate) .
			}
			OPTIONAL {
				$component ?predicate ?specialized .
			}
			OPTIONAL {
				$component sh:validator ?default .
			}
			BIND (COALESCE(?specialized, ?default) AS ?validator) .
		}""" ;
.
tosh:valuesWithShapeCount
  a sh:SPARQLFunction ;
  rdfs:comment "Counts the number of values from a given subject (?arg1) / predicate (?arg2) combination that do not produce any error-level constraint violations for a given shape (?arg3) in a given shapes graph (?arg4). The function produces an error if one of the shapes validated to a fatal error." ;
  rdfs:label "values with shape count" ;
  sh:parameter [
      sh:path dash:arg1 ;
      sh:class rdfs:Resource ;
      sh:description "The subject to count the values of." ;
    ] ;
  sh:parameter [
      sh:path dash:arg2 ;
      sh:class rdf:Property ;
      sh:description "The property to count the values of." ;
    ] ;
  sh:parameter [
      sh:path dash:arg3 ;
      sh:class sh:Shape ;
      sh:description "The shape to validate." ;
    ] ;
  sh:prefixes <http://topbraid.org/tosh> ;
  sh:returnType xsd:integer ;
  sh:select """
		# The SUM will fail with an error if one of the operands is not a number
		# (this mechanism is used to propagate errors from tosh:hasShape calls)
		SELECT (SUM(?s) AS ?result)
		WHERE {
			{
				FILTER NOT EXISTS { $arg1 $arg2 ?value }
				BIND (0 AS ?s)
			}
			UNION {
				FILTER EXISTS { $arg1 $arg2 ?value }
				$arg1 $arg2 ?value .
				BIND (tosh:hasShape(?value, $arg3, true) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
		""" ;
.
tosh:viewGadget
  a rdf:Property ;
  rdfs:comment """Can link a property shape with a UI gadget that shall be used to render property values on forms (in viewing mode). In contrast to tosh:viewWidget which is about individual values only, a gadget is expected to take full control, i.e. it needs to make all necessary decisions to render the values appropriately. The gadget is parameterized with the focus node and the path.

This property is currently only supported at property groups and then applies to all properties in that group.""" ;
  rdfs:label "view gadget" ;
  rdfs:range rdfs:Resource ;
.
tosh:viewGroupDescription
  a rdf:Property ;
  rdfs:comment "A description of the property group when in \"view\" mode." ;
  rdfs:domain sh:PropertyGroup ;
  rdfs:label "view group description" ;
  rdfs:range xsd:string ;
.
tosh:viewWidget
  a rdf:Property ;
  rdfs:label "view widget" ;
  rdfs:range swa:ObjectViewerClass ;
.
<http://uispin.org/ui>
  a owl:Ontology ;
  rdfs:comment "The core model of SPARQL Web Pages (aka UISPIN), a SPARQL-based user interface description framework. SWP can be used to describe how RDF resources should be rendered on the screen. More generally, SWP can be used to generate just about any textual output, including XML or JSON." ;
  rdfs:seeAlso <http://uispin.org> ;
  owl:imports <http://spinrdf.org/spra> ;
  owl:imports sh: ;
  owl:versionInfo "1.4.3" ;
.
ui:Asset
  a rdfs:Class ;
  rdfs:label "Asset" ;
  rdfs:subClassOf ui:ViewElement ;
.
ui:Assets
  a ui:Asset ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of \"assets\" such as JavaScript and CSS files. Assets may depend on each other, defining a load sequence. These dependencies can be expressed via ui:dependsOn." ;
  rdfs:label "Assets" ;
  rdfs:subClassOf ui:ViewElements ;
.
ui:CDATA
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:data ;
      spl:valueType xsd:string ;
      rdfs:comment "The CDATA to insert." ;
    ] ;
  rdfs:comment "Creates a new CDATA section from the value of ui:data as content. If the CDATA is supposed to contain nested HTML/XML elements, then this data may be created in conjunction with ui:bind." ;
  rdfs:label "CDATA" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:ChildProperty
  a rdfs:Class ;
  rdfs:comment "Metaclass for properties that represent a parent-child relationship between UI nodes. This can be used as marker so that editing tools can display child relationships in an ordered fashion." ;
  rdfs:label "Child property" ;
  rdfs:subClassOf rdf:Property ;
.
ui:CommaSeparatedLabelList
  a spr:Aggregator ;
  spr:startValue "" ;
  spr:stepFunction ui:CommaSeparatedLabelListAggregatorStepFunction ;
  rdfs:label "Comma separated label list" ;
.
ui:CommaSeparatedLabelListAggregatorStepFunction
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression [
                a ui:label ;
                sp:arg1 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "label" ;
              ] ;
          ]
          [
            a sp:Bind ;
            sp:expression [
                a sp:if ;
                sp:arg1 [
                    a sp:gt ;
                    sp:arg1 [
                        a fn:string-length ;
                        sp:arg1 spin:_arg1 ;
                      ] ;
                    sp:arg2 0 ;
                  ] ;
                sp:arg2 [
                    a fn:concat ;
                    sp:arg1 spin:_arg1 ;
                    sp:arg2 "," ;
                    sp:arg3 [
                        sp:varName "label" ;
                      ] ;
                  ] ;
                sp:arg3 [
                    sp:varName "label" ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:private true ;
  spin:returnType xsd:string ;
  rdfs:label "Comma separated label list aggregator step function" ;
  rdfs:subClassOf spr:AggregatorStepFunctions ;
.
ui:CommentNode
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate rdfs:comment ;
      spl:valueType xsd:string ;
      rdfs:comment "The text of this comment." ;
    ] ;
  rdfs:comment "A node representing a comment. Comments are ignored by the display engine, but are useful for documenting code or (temporarily) disabling certain sections without deleting them." ;
  rdfs:label "Comment node" ;
  rdfs:subClassOf ui:Node ;
.
ui:ControlElement
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "Abstract base class for SWP control elements such as ui:forEach and ui:if." ;
  rdfs:label "Control element" ;
  rdfs:subClassOf ui:Element ;
.
ui:DataViews
  a ui:ViewElement ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:condition ;
      spl:valueType xsd:boolean ;
      rdfs:comment "A SPARQL expression that is evaluated with ?this prebound to the current context resource. Must return true to tell the surrounding system that this view is suitable for the current resource." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:dataProvider ;
      spl:valueType spin:TableDataProvider ;
      rdfs:comment "The object providing the data to display." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of views that can display tabular data based on a spin:TableDataProvider (e.g. spin:SelectTemplate)." ;
  rdfs:label "Data views" ;
  rdfs:subClassOf ui:ViewElements ;
.
ui:Element
  a ui:NodeClass ;
  spin:constraint [
      a spl:Attribute ;
      spl:predicate ui:child ;
      spl:valueType ui:Node ;
      rdfs:comment "The children of this panel." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "Abstract base class for all UISPIN elements, which are nodes that can contain other nodes. The child nodes are represented using ui:child. Children can be ordered using ui:childIndex." ;
  rdfs:label "Element" ;
  rdfs:subClassOf ui:Node ;
.
ui:FindVariableClashes
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "element" ;
          ]
          [
            sp:varName "varName" ;
          ]
          [
            sp:varName "other" ;
          ]
        ) ;
      sp:where (
          (
            (
              [
                sp:object [
                    sp:varName "expr" ;
                  ] ;
                sp:predicate [
                    sp:varName "pred" ;
                  ] ;
                sp:subject [
                    sp:varName "element" ;
                  ] ;
              ]
              [
                a sp:Filter ;
                sp:expression [
                    a sp:eq ;
                    sp:arg1 [
                        a afn:namespace ;
                        sp:arg1 [
                            sp:varName "pred" ;
                          ] ;
                      ] ;
                    sp:arg2 "http://uispin.org/let#" ;
                  ] ;
              ]
              [
                a sp:Bind ;
                sp:expression [
                    a afn:localname ;
                    sp:arg1 [
                        sp:varName "pred" ;
                      ] ;
                  ] ;
                sp:variable [
                    sp:varName "varName" ;
                  ] ;
              ]
            )
            [
              sp:object [
                  sp:varName "e" ;
                ] ;
              sp:predicate [
                  sp:varName "other" ;
                ] ;
              sp:subject [
                  sp:varName "element" ;
                ] ;
            ]
            [
              a sp:Filter ;
              sp:expression [
                  a sp:and ;
                  sp:arg1 [
                      a sp:and ;
                      sp:arg1 [
                          a sp:ne ;
                          sp:arg1 [
                              sp:varName "other" ;
                            ] ;
                          sp:arg2 [
                              sp:varName "pred" ;
                            ] ;
                        ] ;
                      sp:arg2 [
                          a sp:ne ;
                          sp:arg1 [
                              sp:varName "other" ;
                            ] ;
                          sp:arg2 ui:child ;
                        ] ;
                    ] ;
                  sp:arg2 [
                      a sp:isBlank ;
                      sp:arg1 [
                          sp:varName "e" ;
                        ] ;
                    ] ;
                ] ;
            ]
          )
          [
            sp:object [
                sp:varName "varName" ;
              ] ;
            sp:predicate spif:referencedVar ;
            sp:subject [
                sp:varName "e" ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Can be used to find all elements where a let assignment produces a variable that is also referenced by some other expression at the same element. This situation is an anti-pattern that should be avoided." ;
  rdfs:label "Find variable clashes" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
ui:FindViewByName
  a spin:SelectTemplate ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "view" ;
          ]
          [
            sp:varName "class" ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "name" ;
              ] ;
            sp:predicate ui:name ;
            sp:subject [
                sp:varName "view" ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "class" ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "view" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:name ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the view to find." ;
    ] ;
  rdfs:comment "Can be used to find a view by its name (ui:name), e.g. to support quick navigation." ;
  rdfs:label "Find view by name" ;
  rdfs:subClassOf spin:SelectTemplates ;
.
ui:Function
  a rdfs:Class ;
  rdfs:comment """A SPIN function that has an SWP expression as its body. The body must be defined as ui:prototype. Each execution of the function's prototype should terminate with a ui:return, which should specify the return value ui:result (which may be unbound).

Like all SPARQL functions, ui:Functions must not have side effects to the RDF data, i.e. no ui:update etc allowed. However, control elements such as ui:if and ui:forEach can readily be used.

Deprecated semantics: The result of the function is based on the string rendering of the evaluated prototype. The string will be cast into the declared spin:returnType (default: xsd:string). The result can be a URI resource of the spin:returnType is a (non-datatype) class such as rdfs:Resource.

Note that in order to globally use ui:Functions from anywhere within TopBraid, they should be either defined in a file ending with .spin.* or be imported by a file ending with .spin.* so that the global functions registry can pick the function declarations up at startup time.""" ;
  rdfs:label "SWP Function" ;
  rdfs:subClassOf spin:Function ;
  rdfs:subClassOf ui:NodeClass ;
.
ui:Functions
  a ui:Function ;
  spin:abstract true ;
  rdfs:comment "Abstract base class to group all instances of the ui:Function metaclass." ;
  rdfs:label "Functions" ;
  rdfs:subClassOf spin:Functions ;
  rdfs:subClassOf ui:Methods ;
.
ui:GlobalVars
  a rdfs:Resource ;
  rdfs:comment "The subject holding the global variable values." ;
  rdfs:label "Global vars" ;
.
ui:HTML
  a ui:ResponseType ;
  ui:mimeType "text/html" ;
  rdfs:comment "The HTML response type." ;
  rdfs:label "HTML" ;
.
ui:JSON
  a ui:ResponseType ;
  ui:mimeType "application/json" ;
  rdfs:comment "The JSON response type." ;
  rdfs:label "JSON" ;
.
ui:JSONService
  a rdfs:Class ;
  spin:constructor [
      a sp:Construct ;
      sp:templates (
          [
            sp:object ui:JSONServices ;
            sp:predicate rdfs:subClassOf ;
            sp:subject spin:_this ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "any" ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:label "JSON service" ;
  rdfs:subClassOf ui:Service ;
.
ui:JSONServices
  a ui:Service ;
  ui:abstract true ;
  ui:responseType ui:JSON ;
  rdfs:comment "Abstract superclass of services that return JSON." ;
  rdfs:label "JSON services" ;
  rdfs:subClassOf ui:Services ;
.
ui:Method
  a rdfs:Class ;
  spin:constructor [
      a sp:Construct ;
      sp:templates (
          [
            sp:object ui:Methods ;
            sp:predicate rdfs:subClassOf ;
            sp:subject spin:_this ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "any" ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Metaclass of ui:Methods. Instances of this metaclass (i.e. the element classes) should start with a lower-case letter." ;
  rdfs:label "Method" ;
  rdfs:subClassOf ui:Operation ;
.
ui:Methods
  a ui:Method ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass of operations that may be attached to a class, similar to how object-oriented systems work. Methods can be attached to classes to clarify that they are meant to be called for instances of that class (or its subclasses) only. In those cases, the argument ui:this (?this) needs to point to the context instance, similar to how SPIN rules work. In order to attach an operation to a class, the property ui:method or ui:rule can be used." ;
  rdfs:label "Methods" ;
  rdfs:subClassOf ui:Operations ;
.
ui:Node
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "The base class of all user interface objects, i.e. objects that represent a visual area on the screen or represent scripts, events or any other part of a DOM-like model." ;
  rdfs:label "Node" ;
  rdfs:subClassOf rdfs:Resource ;
.
ui:NodeClass
  a rdfs:Class ;
  rdfs:comment "Metaclass of ui:Node classes." ;
  rdfs:label "Node class" ;
  rdfs:subClassOf rdfs:Class ;
.
ui:Operation
  a rdfs:Class ;
  rdfs:comment "Metaclass of operations that have side effects only. See ui:Operations." ;
  rdfs:label "Operation" ;
  rdfs:subClassOf ui:NodeClass ;
.
ui:Operations
  a ui:NodeClass ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass of SWP elements that have only side effects and do not produce output. Examples include helper elements that perform ui:updates." ;
  rdfs:label "Operations" ;
  rdfs:subClassOf ui:Element ;
.
ui:ResourceViewClass
  a rdfs:Class ;
  rdfs:comment "Metaclass to distinguish resource views from others." ;
  rdfs:label "Resource view class" ;
  rdfs:subClassOf ui:ViewElement ;
.
ui:ResourceViews
  a ui:ResourceViewClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to display. This is optional because for example a form definition may also be used in search mode." ;
    ] ;
  ui:abstract true ;
  rdfs:comment "A base class for elements that display a single resource, specified via the argument arg:resource. It is a good practice to subclass this and to instantiate those user-defined classes in ui:instanceViews etc." ;
  rdfs:label "Resource views" ;
  rdfs:subClassOf ui:ViewElements ;
.
ui:ResponseType
  a rdfs:Class ;
  rdfs:comment "Instances of this class can be associated with ui:NodeClasses to declare that they can be called as web services, and what mime type should be returned in those cases. Notable instances are ui:HTML and ui:JSON. The property ui:responseType is used to link the view classes with ui:ResponseTypes." ;
  rdfs:label "Response type" ;
  rdfs:subClassOf rdfs:Resource ;
.
ui:Rule
  a rdfs:Class ;
  spin:constructor [
      a sp:Construct ;
      sp:templates (
          [
            sp:object ui:Rules ;
            sp:predicate rdfs:subClassOf ;
            sp:subject spin:_this ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "any" ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "An Event-Condition-Action rule based on SWP expressions. A rule is defined by its ui:prototype which can perform queries (e.g. using ui:forEach) and then perform changes (ui:update), call SPARQLMotion modules etc. If the rules have been triggered by edits, then inside of the prototype the special named graphs ui:addedGraph and ui:deletedGraph contain the changes that have triggered the rule." ;
  rdfs:label "Rule" ;
  rdfs:subClassOf ui:Operation ;
.
ui:Rules
  a ui:Rule ;
  ui:abstract true ;
  rdfs:comment "Abstract base class of all ui:Rule instances." ;
  rdfs:label "Rules" ;
  rdfs:subClassOf ui:Operations ;
.
ui:Script
  a rdfs:Class ;
  rdfs:label "Script" ;
  rdfs:subClassOf ui:Asset ;
.
ui:Scripts
  a ui:Script ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass of assets representing <script> tags. Scripts may depend on each other using ui:dependsOn." ;
  rdfs:label "Scripts" ;
  rdfs:subClassOf ui:Assets ;
.
ui:Service
  a rdfs:Class ;
  rdfs:comment "Metaclass for SWP elements that act as services - \"Ajax\" callbacks that are used during the execution of other views or services. All ui:Services need to declare or inherit a ui:responseType, typically ui:JSON." ;
  rdfs:label "Service" ;
  rdfs:subClassOf ui:NodeClass ;
.
ui:Services
  a ui:Service ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass of SWP elements that provide web services that are callable via GET or POST requests. Services must have or inherit a response type." ;
  rdfs:label "Services" ;
  rdfs:subClassOf ui:Element ;
.
ui:Style
  a rdfs:Class ;
  rdfs:label "Style" ;
  rdfs:subClassOf ui:Asset ;
.
ui:StyleProperty
  a rdfs:Class ;
  rdfs:comment "Metaclass of properties that represent a (CSS) style." ;
  rdfs:label "Style property" ;
  rdfs:subClassOf rdf:Property ;
.
ui:Styles
  a ui:Style ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass of assets representing <style> tags. Styles may depend on each other using ui:dependsOn." ;
  rdfs:label "Styles" ;
  rdfs:subClassOf ui:Assets ;
.
ui:TEXT
  a ui:ResponseType ;
  ui:mimeType "text/plain" ;
  rdfs:comment "The plain text response type." ;
  rdfs:label "TEXT" ;
.
ui:Test-functionCall-1
  a spl:TestCase ;
  spl:testExpression [
      a ui:functionCall ;
      sp:arg1 "test" ;
      sp:arg2 "Hello \"" ;
      sp:arg3 42 ;
      sp:arg4 false ;
      sp:arg5 owl:Thing ;
    ] ;
  spl:testResult "test(\"Hello \\\"\", 42, false, \"http:\\/\\/www.w3.org\\/2002\\/07\\/owl#Thing\")" ;
  rdfs:label "Test-function call-1" ;
.
ui:TestCase
  a rdfs:Class ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate dash:expectedResult ;
      spl:valueType ui:Node ;
      rdfs:comment "The expected result, represented as SWP." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate dash:expectedResultIsJSON ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to compare the actual and expected results as JSON, ignoring white space." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:testUserName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the user to activate for this test case." ;
    ] ;
  rdfs:comment """Instances of this metaclass can be used to define test cases. If stored in files containing .test. then TopBraid's Test Cases framework will execute them. The test fails if 
- a ui:assert in the prototype of the test case fails, or
- if the test case defines a dash:expectedResult and the actual result does not match the expected result, or
- if the test case has values for ui:expectedResultContains but the actual result does not contains these strings.""" ;
  rdfs:label "Test case" ;
  rdfs:subClassOf ui:NodeClass ;
.
ui:TestCases
  a ui:TestCase ;
  ui:abstract true ;
  rdfs:comment "Abstract superclass of test cases." ;
  rdfs:label "Test cases" ;
  rdfs:subClassOf ui:Element ;
.
ui:TextNode
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:text ;
      spl:valueType xsd:string ;
      rdfs:comment "The text of this TextNode." ;
    ] ;
  rdfs:comment "A text node in a UISPIN document. Will be mapped to XML text nodes." ;
  rdfs:label "Text node" ;
  rdfs:subClassOf ui:Node ;
.
ui:Turtle
  a ui:ResponseType ;
  ui:mimeType "text/turtle" ;
  rdfs:comment "The Turtle response type, to be used in conjunction with ui:return." ;
  rdfs:label "Turtle" ;
.
ui:TurtleServices
  a ui:Service ;
  ui:abstract true ;
  ui:responseType ui:Turtle ;
  rdfs:comment "Abstract superclass of services that return RDF triples in Turtle format, using ui:return." ;
  rdfs:label "Turtle services" ;
  rdfs:subClassOf ui:Services ;
.
ui:ViewElement
  a rdfs:Class ;
  spin:constructor [
      a sp:Construct ;
      sp:templates (
          [
            sp:object ui:ViewElements ;
            sp:predicate rdfs:subClassOf ;
            sp:subject spin:_this ;
          ]
        ) ;
      sp:where (
          [
            a sp:Filter ;
            sp:expression [
                a sp:notExists ;
                sp:elements (
                    [
                      sp:object [
                          sp:varName "any" ;
                        ] ;
                      sp:predicate rdfs:subClassOf ;
                      sp:subject spin:_this ;
                    ]
                  ) ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "Recommended metaclass of ui:ViewElements - SWP views that produce HTML/SVG output." ;
  rdfs:label "View element" ;
  rdfs:subClassOf ui:NodeClass ;
.
ui:ViewElements
  a ui:ViewElement ;
  ui:abstract true ;
  rdfs:comment "The recommended base class of ui:Elements that produce HTML output." ;
  rdfs:label "View elements" ;
  rdfs:subClassOf ui:Element ;
.
ui:ViewProperty
  a rdfs:Class ;
  rdfs:comment "Metaclass of properties that link a class with a view, e.g. ui:view. Can be used by user interface engines to distinguish views from other properties." ;
  rdfs:label "View property" ;
  rdfs:subClassOf rdf:Property ;
.
ui:XML
  a ui:ResponseType ;
  ui:mimeType "text/xml" ;
  rdfs:comment "The XML response type." ;
  rdfs:label "XML" ;
.
ui:absolute
  a rdf:Property ;
  rdfs:comment "Indicates whether a URL should be relative or absolute." ;
  rdfs:domain ui:createLink ;
  rdfs:label "absolute" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:abstract
  a rdf:Property ;
  rdfs:comment "Indicates that elements of this type should not be instantiated directly. This is comparable to the notion of abstract classes in object-oriented languages like UML." ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "abstract" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:addNamespace
  a rdf:Property ;
  rdfs:comment "Adds a global namespace declaration for the given resource to the root element. Has no other side effects, i.e. it will not become an attribute in the target document." ;
  rdfs:label "add namespace" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:addPropertyValue
  a ui:Method ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:value ;
      rdfs:comment "The value to add to the property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to add a value for." ;
    ] ;
  ui:prototype [
      a ui:if ;
      ui:child [
          a ui:transaction ;
          ui:child [
              a ui:update ;
              ui:childIndex 0 ;
              ui:updateQuery [
                  a sp:Modify ;
                  sp:insertPattern (
                      [
                        sp:object [
                            sp:varName "value" ;
                          ] ;
                        sp:predicate [
                            sp:varName "property" ;
                          ] ;
                        sp:subject spin:_this ;
                      ]
                    ) ;
                  sp:where () ;
                ] ;
            ] ;
          ui:childIndex 0 ;
        ] ;
      ui:condition [
          a sp:bound ;
          sp:arg1 [
              sp:varName "value" ;
            ] ;
        ] ;
    ] ;
  rdfs:comment "A generic operation that adds a certain value (arg:value) to a given property (arg:property) at a subject (ui:this)." ;
  rdfs:label "add property value" ;
  rdfs:subClassOf ui:Methods ;
.
ui:addToResultSet
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:resultSet ;
      spl:valueType spr:Table ;
      rdfs:comment "The result set to add." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the result set to add to." ;
    ] ;
  rdfs:comment """Adds rows to an existing result set. The existing result set (which may have been produced using ui:call) must have exactly the same columns, in the same order, as the new results.

Note that this element SHOULD not be called inside of an iteration (such as ui:forEach) that traverses the modified result set.""" ;
  rdfs:label "add to result set" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:addedGraph
  a rdfs:Resource ;
  rdfs:comment "A special named graph available during the execution of a ui:Rule, containing the triples that were added before the rule was triggered." ;
  rdfs:label "added graph" ;
.
ui:arg
  a spin:MagicProperty ;
  spin:returnType ui:Node ;
  rdfs:comment "Makes it possible to query for the arguments of the current UISPIN element of a user-defined class. The argument on the left side must be an rdf:Property or a variable. The right side must be an unbound variable, that will contain the value of the argument at the current context node." ;
  rdfs:label "arg" ;
  rdfs:subClassOf spin:MagicProperties ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:args
  a rdf:Property ;
  rdfs:comment """Can be used on elements that represent calls of user-defined elements that have a ui:prototype and declared spl:Arguments. If set to \"*\", this will pass all matching variable bindings from the surrounding scope into the element call. For example if my:Element declares an spl:Argument arg:subject and you have

<ui:group let:subject=\"owl:Thing\">
    <ex:MyElement ui:args=\"*\" />
</ui:group>

then the outcome will be equivalent with

<ui:group let:subject=\"owl:Thing\">
    <ex:MyElement arg:subject=\"{= ?subject }\" />
</ui:group>

The names of the outer variable must be the local names of the spl:predicate of the spl:Argument, e.g. ?subject matches arg:subject.""" ;
  rdfs:label "args" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:assert
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:message ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional message to report if the assertion fails." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:condition ;
      spl:valueType xsd:boolean ;
      rdfs:comment "The condition that must be true for the assertion to pass." ;
    ] ;
  rdfs:comment "Checks a condition and throws an exception if the condition fails." ;
  rdfs:label "assert" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:baseGraph
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:unionGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The union graph to get the base graph of." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the URI of the base graph of a graph previously created with ui:unionOfGraphs." ;
  rdfs:label "base graph" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
ui:bind
  a ui:NodeClass ;
  rdfs:comment """Executes any child elements of type ui:string and serializes their children into strings, which become a bound variables in the remaining children. For example:

<ui:bind>
	<ui:stringify ui:varName=\"text\">
		<div>Hello World</div>
	</ui:stringify>
	<span>The text is {= ?text }</span>
</ui:bind>

would produce: <span>The text is &lt;div&gt;Hello World&lt;/div&gt;</span>.""" ;
  rdfs:label "bind" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:bindVars
  a rdf:Property ;
  rdfs:label "bind vars" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:br
  a ui:NodeClass ;
  rdfs:comment "Inserts a line break (\\n) into the output stream. This is usually only sensible for text-based output formats such as spreadsheets." ;
  rdfs:label "br" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:cache
  a rdf:Property ;
  rdfs:label "cache" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:cacheKey
  a rdf:Property ;
  rdfs:label "cache key" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:call
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "rs" ;
      spl:optional true ;
      spl:predicate ui:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable to hold the result set. Defaults to \"rs\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:limit ;
      spl:valueType xsd:integer ;
      rdfs:comment "An optional maximum number of rows to iterate over the SELECT query. This will be inserted as a LIMIT clause into the query." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:offset ;
      spl:valueType xsd:integer ;
      rdfs:comment "An optional starting row for the iteration of the SELECT query. This will be inserted as an OFFSET clause into the query." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:queryString ;
      spl:valueType xsd:string ;
      rdfs:comment "The SELECT query string to execute. Either ui:template or ui:queryString need to be specified." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:template ;
      spl:valueType spin:Template ;
      rdfs:comment "The template to call. Either ui:template or ui:queryString need to be specified." ;
    ] ;
  rdfs:comment """Invokes a SPIN template (ui:template) that has a SELECT query or an UPDATE command as its body. For SELECT queries, it binds the result set to the result variable (ui:varName, default: \"rs\"). All other arguments of this element will be used as arguments of the template. UPDATE commands will be treated like ui:update, i.e. execute a change directly. For UPDATE commands, please read the comment about transactions at ui:update.

If the ui:call has the argument ui:args=\"template\" then the system will try to pass variables values from the current scope into the template.

ui:queryString can be used as an alternative to ui:template, to execute a query specified using a SELECT string.""" ;
  rdfs:label "call" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:canParse
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:xml ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to do the parsing in XML only, while the default is to do permissive HTML parsing." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:node ;
      rdfs:comment "The RDF node to test. Must be a literal that can be parsed as HTML or XML." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks whether a given literal can be parsed using ui:parse. Returns false if the given literal cannot be parsed as HTML (default) or XML (if second argument is true)." ;
  rdfs:label "can parse" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:catch
  a ui:NodeClass ;
  rdfs:comment "Not executed by default, but will be executed if the associated <ui:try> block failed with an exception. The variable ?exception will contain the exception string and the variable ?stackTrace will contain the full stack trace." ;
  rdfs:label "catch" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:checkConstraints
  a rdf:Property ;
  rdfs:label "check constraints" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:child
  a ui:ChildProperty ;
  rdfs:comment "Points from a parent element to a child node." ;
  rdfs:label "child" ;
  rdfs:range ui:Node ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:childIndex
  a rdf:Property ;
  a owl:FunctionalProperty ;
  rdfs:comment "The index of a child among its siblings, starting at 0." ;
  rdfs:domain ui:Node ;
  rdfs:label "child index" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:class
  a rdf:Property ;
  rdfs:domain ui:dynamicView ;
  rdfs:label "class" ;
  rdfs:range ui:NodeClass ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:classView
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:cacheKey ;
      spl:valueType xsd:string ;
      rdfs:comment "A globally unique key for this element to enable ontology-based caching (if supported by the platform)" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:matchIds ;
      spl:valueType xsd:string ;
      rdfs:comment "The match ids." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The value that shall be bound to ?this." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to insert the view for." ;
    ] ;
  rdfs:comment "Inserts the most suitable view associated with a given class, using ui:instanceView. ?this will be unbound unless the ui:resource argument is bound." ;
  rdfs:label "class view" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:classViewElement
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:matchIds ;
      spl:valueType xsd:string ;
      rdfs:comment "Optional match IDs." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:class ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to get the view element of." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the SWP element that will be used by a ui:classView element for a given class and optional matchIds. The result is the SWP node (often a blank node) or unbound. More information about that SWP node can be queried in the ui:graph." ;
  rdfs:label "class view element" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:concat
  a spin:Function ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates a string by concatenating the string representation of its arguments from left to right. This is basically identical to the SPARQL built-in CONCAT, with the important difference that unbound variables will be ignored without failure. The function is also used by the SWP parser if a user enters mixed attribute values such as arg=\"Hello, {= ?name }\" which is mapped to ui:concat('Hello, ', ?name)." ;
  rdfs:label "concat" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:condition
  a rdf:Property ;
  rdfs:comment "The condition of an ui:If element. Must evaluate to a literal with the lexical form \"true\"." ;
  rdfs:label "condition" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:contextValue
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable to get." ;
    ] ;
  rdfs:comment "Gets the value of a given context variable that was set before using ui:setContext. For example, <ui:setContext ui:varName=\"test\" ui:value=\"Hello\">...</ui:setContext> makes the name-value-pair test=\"Hello\" visible for all children of the setContext element." ;
  rdfs:label "context value" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:convertHTMLToText
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:treatAnyLiteral ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to convert any literal. By default (or false), only literals that have datatype rdf:HTML will be converted." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:html ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The HTML text to convert." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Take a literal containing HTML mark-up and removes any HTML elements (tags), while preserving some of the formatting using regular text. Note that by default this function returns the input node unless the datatype of the literal is rdf:HTML or the second argument is set to true." ;
  rdfs:label "convert HTML to text" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:createLink
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue false ;
      spl:optional true ;
      spl:predicate ui:absolute ;
      spl:valueType xsd:boolean ;
      rdfs:comment "If true, creates an absolute URL instead of a relative one, or throws an error if the appropriate configuration is not present." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "link" ;
      spl:optional true ;
      spl:predicate ui:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the link variable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "uispin" ;
      spl:optional true ;
      spl:predicate ui:servlet ;
      spl:valueType xsd:string ;
      rdfs:comment "The servlet part of the link (before ?). Can be set to \"none\" to suppress the servlet part." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:format ;
      spl:valueType xsd:string ;
      rdfs:comment "The format instruction to the servlet." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:fragment ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional URL fragment that will be appended to the end of the URL, after a # character." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:queryGraph ;
      spl:valueType owl:Ontology ;
      rdfs:comment "See ui:setContext. Specifying a value will be similar to ui:sendQueryGraph, but with the specific query graph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:sendContext ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "Can be used to also send the current values of the context variables. If true then it will send all context values. If a string, then it will include all variables starting with the given name part." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:sendEditGraphs ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to also include the currently editable graphs." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:sendQueryGraph ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to encode the current query graph so that the resulting page will use it as a starting point." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:snippet ;
      spl:valueType xsd:string ;
      rdfs:comment "The snippet instruction to the servlet." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:viewClass ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "Must points to a view class that has a prototype, creates a link that will return a view based on this prototype and the other arguments." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:viewName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the target page." ;
    ] ;
  rdfs:comment "Creates a hyperlink to a named page on the SWP server. This element can take any number of arguments: they will be passed by their local name to the server. The resulting link will be bound to a variable with the name of the provided variable (ui:varName) in the child scope of this module." ;
  rdfs:label "create link" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:createSessionGraph
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:baseGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "An optional graph that should be included as subgraph into the session graph." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Creates a (temporary) graph that can be accessed across multiple server call-backs, as long as a client session is active. The new graph is initially empty but can be populated using ui:update. Optionally, you can specify a base graph that will be a sub-graph of the new graph. The life cycle of a session graph ends if ui:deleteSessionGraph is called or a time out happens (after idle time)." ;
  rdfs:label "create session graph" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
ui:currentQueryGraph
  a spin:Function ;
  spin:returnType owl:Ontology ;
  rdfs:comment "Gets the URI resource of the currently active query graph." ;
  rdfs:label "current query graph" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
ui:data
  a rdf:Property ;
  rdfs:comment "The data of a ui:CDATA element." ;
  rdfs:label "data" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:dataView
  a ui:ViewProperty ;
  rdfs:comment "Links a class with elements that can be used to display data taken from spin:TableDataProviders with instances of that class. In those elements, the variable ?this points to the instance being displayed. The values of this property should be blank nodes with no further children, i.e. exactly an instance of a subclass of ui:DataViews with its arguments filled in, especially arg:dataProvider." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "data view" ;
  rdfs:range ui:DataViews ;
.
ui:debug
  a ui:NodeClass ;
  a rdf:Property ;
  rdfs:comment "Executes its child elements only if SWP is in debug mode. Debug mode can be activated in TBC's SWP Preferences page, or by setting a context variable \"debug\" to true. It can be activated for each web service call by passing in the HTTP parameter _contextdebug=true." ;
  rdfs:label "debug" ;
  rdfs:subClassOf ui:ControlElement ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:decodeNode
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the RDF node to decode." ;
    ] ;
  rdfs:comment "Creates an RDF node from a string representation created with ui:encodeNode. This basically turns a qname back into a URI etc." ;
  rdfs:label "decode node" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:defaultBaseURI
  a rdf:Property ;
  rdfs:comment "Can be used in conjunction with ui:name to specify a base URI that shall be used for a global page unless a different one has been specific in the servlet request." ;
  rdfs:label "default base URI" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:defaultContextClass
  a rdf:Property ;
  rdfs:label "default context class" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:deleteSessionGraph
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:sessionGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to delete." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Deletes a session graph that was previously created using ui:createSessionGraph. The function has side effects to the state of the SWP engine, but returns a dummy boolean (true) if the operation is succesful." ;
  rdfs:label "delete session graph" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
ui:deletedGraph
  a rdfs:Resource ;
  rdfs:comment "A special named graph available during the execution of a ui:Rule, containing the triples that were deleted before the rule was triggered." ;
  rdfs:label "deleted graph" ;
.
ui:dependsOn
  a rdf:Property ;
  rdfs:comment "Links an asset (such as a JavaScript library) with another asset that must be loaded before this asset." ;
  rdfs:domain ui:Asset ;
  rdfs:label "depends on" ;
  rdfs:range ui:Asset ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:dumpGraph
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:filePath ;
      spl:valueType xsd:string ;
      rdfs:comment "The path of the file to create, relative to the workspace root. For example, \"/myProject/myFolder/myFile.ttl\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:graph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The URI of the graph to dump, e.g. ui:tempGraph." ;
    ] ;
  rdfs:comment "If in debug mode, this dumps a given graph to a file with a given name, so that it can be browsed, queried etc." ;
  rdfs:label "dump graph" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:dumpResultSet
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:message ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional message to print with the result set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set to dump, defaults to the variable \"rs\" from the scope." ;
    ] ;
  rdfs:comment "If in debug mode, this dumps a given result set, e.g. specified using an inline SELECT query. In TBC, when a file is open, this will open a new (Eclipse) view to display the tabular results. In other environments including TBL this will print the results to standard out, which will end up in a server log." ;
  rdfs:label "dump result set" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:dumpScope
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:message ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional message to print with the scope." ;
    ] ;
  rdfs:comment "If in debug mode, this dumps the currently visible SWP variables. In TBC, when a file is open, this will open a new (Eclipse) view to display the variables. In other environments including TBL this will print the results to standard out, which will end up in a server log." ;
  rdfs:label "dump scope" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:dynamicView
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:class ;
      spl:valueType ui:NodeClass ;
      rdfs:comment "The view class to use." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:instance ;
      spl:valueType ui:Element ;
      rdfs:comment "The view instance to insert." ;
    ] ;
  rdfs:comment "Makes it possible to insert a element that has a flexible type, i.e. the element name does not need to be known at compile time. If ui:class is provided, then the element will instantiate that class of the ui:Element. For example, if you have a ui:Element class ex:Widget, with subclasses ex:StringWidget and ex:DateWidget, then you can bind ?uiClass in a previous step before using <ui:dynamicView ui:class=\"{= ?uiClass }\" arg:subject=\"{= ?subject }\" ... /> to insert the right instance. All other arguments will be passed into the view. The other use case is to provide the argument ui:instance which must point to an actual instance of a view, e.g. a value of the ui:dataView property." ;
  rdfs:label "dynamic view" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:element
  a rdf:Property ;
  rdfs:comment "Super-property of ui:operation and ui:viewElement." ;
  rdfs:label "element" ;
  rdfs:range ui:NodeClass ;
.
ui:elementType
  a rdf:Property ;
  rdfs:label "element type" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:else
  a ui:NodeClass ;
  rdfs:comment "Defines an else statement. Must have a matching ui:if element as previous sibling. If the if was false, then the children of this element will be inserted." ;
  rdfs:label "else" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:elseif
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:condition ;
      rdfs:comment "The value that must be true." ;
    ] ;
  rdfs:comment "Defines an else-if statement. Must have a matching ui:if or ui:elseif element as previous sibling. If the previous step was false, then the children of this element will be inserted." ;
  rdfs:label "elseif" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:encodeContext
  a spin:Function ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates a URL-encoded string consisting of name-value pairs based on the current SWP context variable bindings, that the SWP servlet can use to initialize context variables for its current request. This can be used to hand-code context-sensitive Ajax loading similar to how ui:loadable does it. In a typical scenario, the result of this function would be stored as a \"hidden\" attribute in the DOM tree, and then added to the request URL (parameters) when needed." ;
  rdfs:label "encode context" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:encodeNode
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have round-trippable blank nodes. Will encode them as <@ID>." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:boolean ;
      rdfs:comment "true to not use qnames for URI nodes." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The node to encode." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates a string representation of a given RDF node (?arg1). By default this is using qnames where possible, unless the optional third argument is set to true." ;
  rdfs:label "encode node" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:encodeURL
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The string or URI resource to encode." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Encodes a given string so that it can be made part of a well-formed URL, e.g. in server callbacks." ;
  rdfs:label "encode URL" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:error
  a rdf:Property ;
  rdfs:label "error" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:errorMessage
  a rdf:Property ;
  rdfs:label "error message" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:errorPrototype
  a rdf:Property ;
  rdfs:comment """Can be used to link a ui:NodeClass with one or more views that can be used to check pre-conditions. If a view class is instantiated, then the engine will check for any defined ui:errorPrototypes for the types of the view, including the superclasses. If any of them returns a non-empty node, then that node will be inserted instead of the prototype.

A typical use case of this is security, so that certain pages are only visible if the current user has certain privileges. You can define an abstract base class that all your view classes inherit from. On that base class, define an error prototype that checks the pre-conditions. The error prototype might use ui:if and other control elements for its operational logic.""" ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "error prototype" ;
  rdfs:range ui:Node ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:escapeJSON
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The string to escape." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Converts a given string to a JSON-friendly string that can be sent across the wire. In particular, this replaces \" with \\\" so that string literals can be put between matching \" braces." ;
  rdfs:label "escape JSON" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:event
  a rdf:Property ;
  rdfs:label "event" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:expectedResultContains
  a rdf:Property ;
  rdfs:comment "Can be attached to ui:TestCases to verify that the result string contains the given string as a substring." ;
  rdfs:domain ui:TestCase ;
  rdfs:label "expected result contains" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:filePath
  a rdf:Property ;
  rdfs:label "file path" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:flattened
  a rdf:Property ;
  rdfs:label "flattened" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:forEach
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "index" ;
      spl:optional true ;
      spl:predicate ui:indexVar ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of an (optional) index variable that will be assigned with the current iteration index as an xsd:integer, starting at 0." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:bindVars ;
      spl:valueType xsd:string ;
      rdfs:comment """An optional comma-separated list of variable names that can be used to specify which variables shall be used from the given resultSet. If the resultSet is a variable (e.g. computed by a ui:call) then this has the side effect that the source code makes the expected variables visible. Example:

<ui:call ui:template=\"ex:GetNames\">
    <ui:forEach ui:resultSet=\"{= ?rs }\" ui:bindVars=\"?firstName, ?lastName\">
        ...
    </ui:forEach>
</ui:call>

If no value for ui:bindVars is present then all columns/variables from the result set will be used.""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:limit ;
      spl:valueType xsd:integer ;
      rdfs:comment "An optional maximum number of rows to iterate over, similar to LIMIT in SPARQL." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:offset ;
      spl:valueType xsd:integer ;
      rdfs:comment "An optional starting row for the iteration, similar to OFFSET in SPARQL." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:separator ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional string to place as text node between the nested elements." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:resultSet ;
      spl:valueType sp:Select ;
      rdfs:comment "The result set to iterate over, typically defined by a SELECT query (or SPIN template)." ;
    ] ;
  rdfs:comment "A control element representing a \"for\" loop that iterates over all results of a given SPARQL SELECT query (or SPIN template) and repeatedly inserts the child element(s) for each iteration. The result variables will be visible to the child elements in the scope, e.g. in nested SPARQL expressions." ;
  rdfs:label "forEach" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:format
  a rdf:Property ;
  rdfs:label "format" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:fragment
  a rdf:Property ;
  rdfs:label "fragment" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:full
  a rdf:Property ;
  rdfs:label "full" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:function
  a rdf:Property ;
  rdfs:label "function" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:functionCall
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The function name without the round brackets, e.g. \"$('#input').val\"." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates the source code of a JavaScript function call. The first argument is the function name, all others are rendered into comma-separated arguments. The function takes care of correct escaping. URI resources are turned into strings of their URI." ;
  rdfs:label "function call" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:getSessionAttribute
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the attribute to get." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets an attribute of the currently active client session." ;
  rdfs:label "get session attribute" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:globalVarValue
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "object" ;
          ]
        ) ;
      sp:where (
          [
            a sp:NamedGraph ;
            sp:elements (
                [
                  a sp:Bind ;
                  sp:expression ui:GlobalVars ;
                  sp:variable [
                      sp:varName "subject" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a sp:iri ;
                      sp:arg1 [
                          a sp:concat ;
                          sp:arg1 "urn:x-global-var:" ;
                          sp:arg2 [
                              sp:varName "name" ;
                            ] ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "predicate" ;
                    ] ;
                ]
                [
                  a sp:Bind ;
                  sp:expression [
                      a spl:object ;
                      sp:arg1 [
                          sp:varName "subject" ;
                        ] ;
                      sp:arg2 [
                          sp:varName "predicate" ;
                        ] ;
                    ] ;
                  sp:variable [
                      sp:varName "object" ;
                    ] ;
                ]
              ) ;
            sp:graphNameNode ui:tempGraphGlobalVars ;
          ]
        ) ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:name ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable to get." ;
    ] ;
  rdfs:comment "Gets the value of a global variable." ;
  rdfs:label "global var value" ;
  rdfs:subClassOf spin:Functions ;
.
ui:graph
  a rdf:Property ;
  rdfs:comment """The URI of the named graph containing the triples of the UI view definitions. This named graph can be accessed in SWP queries using GRAPH ui:graph { ... }, for example to query metadata associated with the current SWP node (?thisNode). It can also be used to query global metadata such as markers attached to properties.

Note that this graph does not include the current query graph. See also ui:unionGraph.""" ;
  rdfs:label "graph" ;
.
ui:graphWithImports
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph resource to cast." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Casts a given named graph resource to an encoded resource that instructs the engine to also include the owl:imports closure (and the system graph). Details of how to encode such resources are left to the engine but need to be consistent with the sibling function ui:graphWithoutImports. Returns the original graph unchanged if it already has the additional encoding." ;
  rdfs:label "graph with imports" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
ui:graphWithoutImports
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph resource to cast." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Opposite of ui:graphWithImports." ;
  rdfs:label "graph without imports" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
ui:group
  a ui:NodeClass ;
  rdfs:comment "A basically \"empty\" element that simply inserts its children. Can be used to host let: assignments, or to otherwise group multiple children. In previous beta versions of UISPIN, this was called ui:let." ;
  rdfs:label "group" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:handle
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:script ;
      spl:valueType xsd:string ;
      rdfs:comment "A client-side JS snippet that shall be executed before the server callback." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:thenLoadId ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional id of a ui:loadable then shall be loaded when the callback has been completed." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:event ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the event, e.g. \"onclick\"." ;
    ] ;
  ui:responseType ui:HTML ;
  rdfs:comment """Inserts an event handler into the surrounding DOM element, e.g. onclick if the parent is an <a ...> tag. The event handler will be executed via a separate server call, i.e. the children of ui:event will only be executed when the event happened. Behaves similar to ui:loadable in that all variables from the context will be visible. However, the content elements of the ui:handle should not create any (HTML) output, apart from possibly <script> tags. Instead the context may be a call of a ui:Method that has side effects such as updating a value.

The optional argument ui:script can be used to execute client-side JavaScript code immediately, and before the server call is made.

The optional argument ui:thenLoadId will load the ui:loadable with the given id after the server callback has finished.

Any other argument of this element will be passed into the children SWP elements as name-value pairs based on JavaScript expressions. The values of those other arguments must be parsable RDF values, e.g. xsd:string values need to be escaped with \"...\" and URI resources surronded with <...>. This makes is possible to execute client-side code (e.g. to query the state of a widget) and send it to the server as a pre-bound variable. Example: arg:expanded=\"$('#{= ?id }-body').css('display') != 'none'\" will execute the given JQuery expression and pass its result (here: true) to the server, as a pre-bound variable ?expanded.""" ;
  rdfs:label "handle" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:headIncludes
  a rdf:Property ;
  rdfs:comment "Can point to one or more elements that will be inserted into the head section of the target document. See also ui:includeScript and ui:includeStyleSheet for more specific alternatives." ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "head includes" ;
  rdfs:range ui:Element ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:headerName
  a rdf:Property ;
  rdfs:comment "The name of a response header to set in ui:setResponseHeader." ;
  rdfs:label "header name" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:headerValue
  a rdf:Property ;
  rdfs:comment "The value of a response header to set in ui:setResponseHeader." ;
  rdfs:label "header value" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:height
  a rdf:Property ;
  rdfs:comment "The height (in pixels) of an element on a page." ;
  rdfs:label "height" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:id
  a rdf:Property ;
  rdfs:comment "An identifier of ui:Nodes. Can be attached to ui:views and ui:instanceViews to mark them as specific types (see ui:matchIds)." ;
  rdfs:label "id" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:if
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:condition ;
      rdfs:comment "The value that must be true. This argument is optional because unbound is treated like false." ;
    ] ;
  rdfs:comment "Defines an if statement. If the ui:condition is \"true\", then the children of this element will be inserted." ;
  rdfs:label "if" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:includeScript
  a rdf:Property ;
  rdfs:comment "Points to ui:Scripts that shall be included whenever this element is used." ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "include script" ;
  rdfs:range ui:Script ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:includeStyle
  a rdf:Property ;
  rdfs:comment "Points to ui:Styles that shall be included whenever this element is used." ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "include style" ;
  rdfs:range ui:Style ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:indexVar
  a rdf:Property ;
  rdfs:label "index var" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:info
  a rdf:Property ;
  rdfs:label "info" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:insert
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:optional ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have this element fail silently if the given insertion point does not exist. By default, an exception will be thrown in that case." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:into ;
      spl:valueType xsd:string ;
      rdfs:comment "The id of the extension point to insert into." ;
    ] ;
  rdfs:comment "A control element that will insert its children into a given insertion point." ;
  rdfs:label "insert" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:insertionPoint
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:pointId ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the extension point. Must be a unique string within the current context." ;
    ] ;
  rdfs:comment "A marker that may be substituted by children that declare themselves to be extensions using ui:insert." ;
  rdfs:label "insertion point" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:instance
  a rdf:Property ;
  rdfs:label "instance" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:instanceView
  a ui:ViewProperty ;
  rdfs:comment "Links a class with elements that can be used to display instances of that class. In those elements, the variable ?this points to the instance being displayed." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "instance view" ;
  rdfs:range ui:Element ;
.
ui:into
  a rdf:Property ;
  rdfs:label "into" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:js
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "result" ;
      spl:optional true ;
      spl:predicate ui:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable to assign the result of the JS function to. Defaults to \"result\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:function ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the JS function to call." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:library ;
      spl:valueType sh:JSLibrary ;
      rdfs:comment "The JavaScript library to execute." ;
    ] ;
  rdfs:comment "Calls a JavaScript function from a given JSLibrary. Any other argument is turned into name-value pairs for the function call, matching the names of the declared variable names of the function. The variable $data will point at the current query graph." ;
  rdfs:label "js" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:json
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The variable to bind. Defaults to \"json\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:str ;
      spl:valueType xsd:string ;
      rdfs:comment "The JSON string to parse." ;
    ] ;
  rdfs:comment "Parses a given JSON string and binds it as a \"native\" JSON value to a given variable. The resulting variable can then be further processed using the other ui:jsonXY functions and magic properties." ;
  rdfs:label "json" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:jsonArrayMembers
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The JSON array." ;
    ] ;
  rdfs:comment "Iterates over a given \"native\" JSON array (left hand side) producing bindings for the variable on the right hand side." ;
  rdfs:label "json array members" ;
  rdfs:subClassOf spin:MagicProperties ;
.
ui:jsonKeys
  a spin:MagicProperty ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The JSON object." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Binds the keys of a JSON object on the left hand side to the variable on the right." ;
  rdfs:label "json keys" ;
  rdfs:subClassOf spin:MagicProperties ;
.
ui:jsonString
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:jsonValue ;
      rdfs:comment "The JSON value node." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Turns a \"native\" JSON value into an RDF string literal." ;
  rdfs:label "json string" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:jsonValue
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:jsonObject ;
      rdfs:comment "The \"native\" JSON object to get the value of." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:key ;
      spl:valueType xsd:string ;
      rdfs:comment "The key of the JSON value to get at the JSON object." ;
    ] ;
  rdfs:comment "Gets the value of a \"native\" JSON object, as another \"native\" JSON value." ;
  rdfs:label "JSON value" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:label
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional style that is used by the date/time literal types. Currently supported values are: \"short\", \"medium\", \"long\" and \"full\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The node to get the label of." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment """Computes the display label for a given RDF node (literal or resource).

For resources, this typically uses the rdfs:label (or sub-property thereof). However, this behavior can be customized with a global setting to redirect ui:label to a different string-producing function. Deeper sub-properties are preferred over their super-properties.

For some literal types such as xsd:date and xsd:float, this uses localization settings based on ui:lang(), e.g. \"4.2\"^^xsd:float is rendered as 4,2 when the current language is \"de\". For all other literal datatypes, the plain lexical form of the literal is put out.""" ;
  rdfs:label "label" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:lang
  a spin:Function ;
  a rdf:Property ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets the language that shall be used in the current request. The language is in the same format as the RDF language tags. It is usually specified by the system as part of the incoming client request. It is also possible to explicitly set the language for child element using ui:setContext." ;
  rdfs:label "lang" ;
  rdfs:subClassOf spl:StringFunctions ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:let
  a ui:NodeClass ;
  a owl:DeprecatedClass ;
  rdfs:comment "Deprecated for UISPIN 1.0: Use ui:group instead." ;
  rdfs:label "let" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:lib
  a spin:Function ;
  spin:body [
      a sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result" ;
          ]
        ) ;
      sp:where (
          [
            a sp:Bind ;
            sp:expression "lib" ;
            sp:variable [
                sp:varName "result" ;
              ] ;
          ]
        ) ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates the start of the \"lib\" servlet that is used to access static files within the SWP servlet. Instead of hard-coding this (e.g. \"lib/assets/js/swa.js\") you should always use this function to resolve the first segment, e.g. \"{= ui:lib() }/assets/js/swa.js\". This allows the engine to inject additional info such as the version number into the path." ;
  rdfs:label "lib" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:library
  a rdf:Property ;
  rdfs:label "library" ;
  rdfs:range sh:JSLibrary ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:limit
  a rdf:Property ;
  rdfs:label "limit" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:loadId
  a rdf:Property ;
  rdfs:label "load id" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:loadLater
  a rdf:Property ;
  rdfs:label "load later" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:loadOnDemand
  a rdf:Property ;
  rdfs:label "load on demand" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:loadable
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:cache ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to activate caching for this snippet, sending the _cache=true directive to the server." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:loadId ;
      spl:valueType xsd:string ;
      rdfs:comment "The unique id of the loadable. Will become the HTML id of the created div. Optional if ui:loadLater=\"true\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:loadLater ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to have the content loaded when the surrounding page has been loaded. The children will not be directly inserted, but only after the subsequent Ajax callback." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:loadOnDemand ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to indicate that the content shall not be loaded initially, but only if a manual load request has been issued (via Ajax)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:progressId ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional value for the _progressId servlet argument, linking the loadable with a progress dialog." ;
    ] ;
  ui:responseType ui:HTML ;
  rdfs:comment "Defines a part of a view that can be dynamically re-loaded at run-time, using Ajax callbacks. The element creates a div that has an attribute 'uistate' that contains the parameter part of the callback URL that would reload the snippet. Clients can take these parameters and add other parameters, depending on the surrounding state. The children of the ui:loadable will be inserted into the div." ;
  rdfs:label "loadable" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:log
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:debug ;
      spl:valueType xsd:string ;
      rdfs:comment "A log message at debug level. This will only be logged if debug logging is enabled." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:error ;
      spl:valueType xsd:string ;
      rdfs:comment "A message at error level. Error messages designate error events." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:info ;
      spl:valueType xsd:string ;
      rdfs:comment "A log message at info level. Info level messages highlight the progress of the application on a coarse-grained level." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:warn ;
      spl:valueType xsd:string ;
      rdfs:comment "A log level at warning level. Warning messages designate potentially harmful situations." ;
    ] ;
  rdfs:comment "Sends a log message to the main system log. The message is given in one of the arguments ui:debug, ui:info, ui:warn or ui:error, depending on the message's severity." ;
  rdfs:label "log" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:logMessage
  a rdf:Property ;
  rdfs:label "log message" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:matchIds
  a rdf:Property ;
  rdfs:comment "A comma-separated list of ids. Used by ui:ResourceView." ;
  rdfs:label "match ids" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:message
  a rdf:Property ;
  rdfs:label "message" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:metadata
  a rdf:Property ;
  rdfs:label "metadata" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:method
  a rdf:Property ;
  rdfs:domain rdfs:Class ;
  rdfs:label "method" ;
  rdfs:range ui:Method ;
  rdfs:subPropertyOf ui:operation ;
.
ui:mimeType
  a rdf:Property ;
  rdfs:domain ui:ResponseType ;
  rdfs:label "mime type" ;
  rdfs:range xsd:string ;
.
ui:name
  a rdf:Property ;
  rdfs:comment "A globally unique name to identify a view on a server. This is often used for global application pages, and may be used in conjunction with ui:defaultBaseURI." ;
  rdfs:label "name" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:namespace
  a rdf:Property ;
  rdfs:label "namespace" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:nearestViewWithType
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The type of the parent." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Walks up the hierarchy of parent views starting with the current view, and finds the first parent that has a given rdf:type." ;
  rdfs:label "nearest view with type" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:node
  a rdf:Property ;
  rdfs:comment "Can be used to point to a ui:Node. For example, ui:MoveNode uses this property." ;
  rdfs:label "node" ;
  rdfs:range ui:Node ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:offset
  a rdf:Property ;
  rdfs:label "offset" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:operation
  a rdf:Property ;
  rdfs:comment "Links a class with a ui:Operation that applies to the instances of that class. In those operations, the variable ?this (ui:this) would point to the instances. This property is \"abstract\" in a sense that developers should use sub-properties such as ui:rule or ui:method instead. In order to make sure the property doesn't show up on forms, the rdfs:domain has been left blank - it should be rdfs:Class." ;
  rdfs:label "operation" ;
  rdfs:range ui:Rule ;
  rdfs:subPropertyOf ui:element ;
.
ui:optional
  a rdf:Property ;
  rdfs:label "optional" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:overrides
  a rdf:Property ;
  rdfs:comment "Can be used to change the behavior of a user-defined element in a different class. For example, if you have a standard library with an element lib:Element and you would like to locally override the ui:prototype, then you can define an element class my:Element that ui:overrides lib:Element. Whenever lib:Element is used, the system will in fact use the prototype attached to my:Element. Overrides work for ui:prototype and ui:errorPrototype." ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "overrides" ;
  rdfs:range ui:NodeClass ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:param
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type to cast the string to (defaults to xsd:string)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:name ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the parameter." ;
    ] ;
  rdfs:comment "Gets the value of a parameter passed in as part of the current HTTP request. Optionally, the parameter can be cast into a given type. The returned value is escaped in SPARQL syntax." ;
  rdfs:label "param" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:params
  a spin:MagicProperty ;
  spin:returnType xsd:string ;
  rdfs:comment """Gets the names of all parameters to the current servlet request. See ui:param to access the actual value of each parameter. Usage:

SELECT ?key ?value
WHERE {
    () ui:params ?key .
    BIND (ui:param(?key) AS ?value) .
}""" ;
  rdfs:label "params" ;
  rdfs:subClassOf spin:MagicProperties ;
.
ui:parse
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:str ;
      spl:valueType xsd:string ;
      rdfs:comment "The source code of the HTML or XML snippet to insert." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:xml ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to do the parsing in XML only, while the default is to do permissive HTML parsing." ;
    ] ;
  rdfs:comment """Inserts an HTML or XML string snippet (ui:str) into the output DOM tree. The string may contain markup such as <br />. The engine will parse this string into a new DOM document and then insert the resulting nodes into the current position.

By default this element will use a permissive HTML parser. Set ui:xml=\"true\" to perform pure XML parsing; if the string is not a well-formed XML document fragment, the original string will be inserted unaltered (and no error given).

A typical use case of this module is to compute strings with SPARQL functions, and then pass the resulting string as a bound variable into this module, using ui:str=\"{= ?text }\".""" ;
  rdfs:label "parse" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:parseJSONLD
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:defaultContextClass ;
      spl:valueType rdfs:Class ;
      rdfs:comment "A class that shall be used to build a default @context element (if missing)." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:str ;
      spl:valueType xsd:string ;
      rdfs:comment "The JSON-LD source code." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:targetGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The graph to add the triples into, e.g. ui:tempGraph1." ;
    ] ;
  rdfs:comment "Parses a JSON-LD file represented as a string (ui:str) and adds the resulting triples into a given graph (ui:graph), which is often a temp graph." ;
  rdfs:label "parse" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:pointId
  a rdf:Property ;
  rdfs:label "point id" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:preCondition
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:errorMessage ;
      spl:valueType xsd:string ;
      rdfs:comment "The error message to return to the user. In a typical scenario this is computed with an expression (e.g. IF([condition], 'This edit is invalid', ?none)) or with a SELECT query." ;
    ] ;
  rdfs:comment """Can be used inside of ui:transactions to validate pre-conditions that need to be met if the transaction is to be performed. For example this can be used to check that a given resource that is being updated has not been deleted in the meantime. The actual check is implemented through the argument ui:errorMessage: if this has a value then the transaction will report back the value as an error. If ui:errorMessage does not have a value, then the children of this element will be executed.

Note that once a ui:update has been performed within a transaction, then no pre-condition can be evaluated.""" ;
  rdfs:label "pre-condition" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:prefix
  a rdf:Property ;
  rdfs:label "prefix" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:priority
  a rdf:Property ;
  rdfs:comment "A priority value that can be assigned to ui:instanceViews and ui:views to fine tune the selection of views if multiple choices are present for a given class. A typical use case is the SWA library, which defines some default instanceViews for rdfs:Resource. Those default ones have a low priority (-10) so that they are only used if no other views are defined. By default, if no value is specified then the value is assumed to be 0. The ui:priority may also be an expression such as in ui:priority=\"{= IF(ui:contextValue(...) = \"...\", 0, ?none) }\" which means that the priority will be 0 if the IF clause is met and the view will not be used otherwise. Formally, if an expression returns unbound then the view will not be used at all." ;
  rdfs:label "priority" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:private
  a rdf:Property ;
  rdfs:comment "Can be set to true for user-defined elements comparable to a private class in an object-oriented system. ui:private is not strictly enforced anywhere, but should be regarded as a recommendation only. A bit like saying this API is unstable and should not be used outside of the controlled use cases from the developer. For example some callbacks or internal elements may only be used by the Class/Property trees of an EVN application, and although they may be generally useful they are not intended for others to rely on them. Only stable components with a fixed URI and arguments should be non-private." ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "private" ;
  rdfs:range xsd:boolean ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:profile
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:message ;
      spl:valueType xsd:string ;
      rdfs:comment "A message that will be printed before the duration." ;
    ] ;
  rdfs:comment "Can be placed around other SWP elements to measure their execution time, for example to find performance bottlenecks. This element should only be used at development time, and removed before going into production. It prints the duration together with an optional string into the console." ;
  rdfs:label "profile" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:progressId
  a rdf:Property ;
  rdfs:label "progress id" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:progressMonitorStatus
  a spin:MagicProperty ;
  rdfs:comment """A property function that returns the current status of a long-running process, as reported by the process in the <ui:task> and <ui:subTask> control elements. Synax:

    ?progressId ui:progressMonitorStatus ( ?task ?subTask ?totalWork ?completedWork ) .

The subject must be a concrete URI or literal, or a variable bound to one. All members of the object list must be unbound variables.

    ?progressId - the identifier of the long-running process, e.g., the _progressId argument passed to the SWP servlet
    ?task - a label for the long-running task
    ?subTask - a label for the currently executing sub-task
    ?totalWork - an integer indicating the total number of work units in the task
    ?completedWork - an integer indicating the number of completed work units""" ;
  rdfs:label "progress monitor status" ;
  rdfs:subClassOf spin:MagicProperties ;
.
ui:prototype
  a rdf:Property ;
  a owl:FunctionalProperty ;
  rdfs:comment "Links a UI class with a prototype instance of itself. This instance will be taken as template for any instance being created of the class." ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "prototype" ;
  rdfs:range ui:Node ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:query
  a rdf:Property ;
  rdfs:comment "Represents a SPARQL SELECT query. Arguments of this property (or sub-properties thereof) are not evaluated immediately, but rather represent the query itself. These queries can be inserted into ui:resultSet properties for execution, e.g. ui:resultSet=\"{= ?query }\"." ;
  rdfs:label "query" ;
  rdfs:range sp:Select ;
  rdfs:subPropertyOf spin:query ;
.
ui:queryGraph
  a rdf:Property ;
  rdfs:label "query graph" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:queryLimit
  a rdf:Property ;
  rdfs:comment "If present, any SPARQL SELECT query executed as part of the surrounding element will be executed with a LIMIT. This is typically paired with ui:queryOffset to implement paging through a larger result set." ;
  rdfs:label "query limit" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:queryOffset
  a rdf:Property ;
  rdfs:comment "Must be used in conjunction with ui:queryLimit. If present, then any SELECT queries in the surrounding element will be executed with an extra OFFSET qualifier." ;
  rdfs:label "query offset" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:queryOrderBy
  a rdf:Property ;
  rdfs:comment "The name of a variable to use as ORDER BY in the SELECT queries of the surrounding element." ;
  rdfs:label "query order by" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:queryOrderByDir
  a rdf:Property ;
  rdfs:comment "Can be used to specify DESC or ASC to be used in conjunction with ui:queryOrderBy." ;
  rdfs:label "query order by dir" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:queryString
  a rdf:Property ;
  rdfs:label "query string" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:removePropertyValue
  a ui:Method ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:value ;
      rdfs:comment "The value to remove from the property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to remove a value for." ;
    ] ;
  ui:prototype [
      a ui:if ;
      ui:child [
          a ui:transaction ;
          ui:child [
              a ui:update ;
              ui:childIndex 0 ;
              ui:updateQuery [
                  a sp:Modify ;
                  sp:deletePattern (
                      [
                        sp:object [
                            sp:varName "value" ;
                          ] ;
                        sp:predicate [
                            sp:varName "property" ;
                          ] ;
                        sp:subject spin:_this ;
                      ]
                    ) ;
                  sp:where () ;
                ] ;
            ] ;
          ui:childIndex 0 ;
        ] ;
      ui:condition [
          a sp:bound ;
          sp:arg1 [
              sp:varName "value" ;
            ] ;
        ] ;
    ] ;
  rdfs:comment "A generic operation that removes a certain value (arg:value) from a given property (arg:property) at a subject (ui:this)." ;
  rdfs:label "remove property value" ;
  rdfs:subClassOf ui:Methods ;
.
ui:removePropertyValues
  a ui:Method ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to set." ;
    ] ;
  ui:prototype [
      a ui:transaction ;
      ui:child [
          a ui:update ;
          ui:childIndex 0 ;
          ui:updateQuery [
              a sp:DeleteWhere ;
              sp:where (
                  [
                    sp:object [
                        sp:varName "any" ;
                      ] ;
                    sp:predicate [
                        sp:varName "property" ;
                      ] ;
                    sp:subject spin:_this ;
                  ]
                ) ;
            ] ;
        ] ;
    ] ;
  rdfs:comment "A generic operation that removes any value for a given property (arg:property) at a subject (ui:this)." ;
  rdfs:label "remove property values" ;
  rdfs:subClassOf ui:Methods ;
.
ui:removeQueryGraphs
  a rdf:Property ;
  rdfs:label "remove query graphs" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:resource
  a rdf:Property ;
  rdfs:comment "Used by ui:ResourceView." ;
  rdfs:label "resource" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:resourceView
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:matchIds ;
      spl:valueType xsd:string ;
      rdfs:comment "Can be used to specify a preference of what kinds of views to render, if multiple are present. Will be compared against the ui:id of each view. Typical values are: \"summary\" (a short but informative display of about 1-5 rows) and \"label\" (a compact display occupying not more than 1 row). If left empty then it will be matched against views that have no id or the id \"full\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to insert a view for." ;
    ] ;
  rdfs:comment "Placeholder for the best suitable element to display a given resource. This will be inserted based on the link properties such as ui:view and ui:instanceView." ;
  rdfs:label "resourceView" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:resourceViewElement
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:matchIds ;
      spl:valueType xsd:string ;
      rdfs:comment "Optional match IDs." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resource ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The resource to get the view element of." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the SWP element that will be used by a ui:resourceView element for a given resource and optional matchIds. The result is the SWP node (often a blank node) or unbound. More information about that SWP node can be queried in the ui:graph." ;
  rdfs:label "resource view element" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:responseType
  a rdf:Property ;
  rdfs:comment "The ui:ResponseType that shall be used if the associated view is called as web service. As of SWP 1.3, only those view classes that have a response type can be called from the outside. The response type can be inherited from superclasses, i.e. the SWP engine will walk up the class hierarchy to find the closest declared ui:responseType." ;
  rdfs:domain ui:NodeClass ;
  rdfs:label "response type" ;
  rdfs:range ui:ResponseType ;
.
ui:result
  a rdf:Property ;
  rdfs:label "result" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:resultSet
  a rdf:Property ;
  rdfs:comment "Represents a SPARQL result set - typically derived from a SELECT query. Arguments of this property (or sub-property thereof) are executed in the context where they are declared." ;
  rdfs:label "result set" ;
  rdfs:range sp:Select ;
  rdfs:subPropertyOf spin:query ;
.
ui:return
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:result ;
      rdfs:comment "The (optional) value to return." ;
    ] ;
  rdfs:comment "Stops the execution of the current view (ui:prototype etc) and may return a result if used within the ui:prototype of a ui:Function. If this is called from a web service that returns ui:Turtle, then the current query graph will be returned to the client." ;
  rdfs:label "return" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:rule
  a rdf:Property ;
  rdfs:comment "Links a class with a ui:Rule that applies to the instances of that class. In those rules, the variable ?this (ui:this) would point to the instances. Rule engines can execute rules using <ui:dynamicView ui:class=\"[rule]\" ui:this=\"{= ?instance }\" />. Rules should be executed in ascending order of ui:ruleIndexes." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "rule" ;
  rdfs:range ui:Rule ;
  rdfs:subPropertyOf ui:operation ;
.
ui:ruleIndex
  a rdf:Property ;
  rdfs:comment "The relative index of a rule. The SWP rule engine will sort all applicable rules by their index and execute them in ascending order. Default value is 0. The recommended value space of those indexes is -100 to 100." ;
  rdfs:domain ui:Rule ;
  rdfs:label "rule index" ;
  rdfs:range xsd:integer ;
.
ui:script
  a rdf:Property ;
  rdfs:label "script" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:sendContext
  a rdf:Property ;
  rdfs:label "send context" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:sendEditGraphs
  a rdf:Property ;
  rdfs:label "send edit graphs" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:sendQueryGraph
  a rdf:Property ;
  rdfs:label "send query graph" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:separator
  a rdf:Property ;
  rdfs:label "separator" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:server
  a spin:Function ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the server as returned by the currently running SWP engine." ;
  rdfs:label "server" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:servlet
  a rdf:Property ;
  rdfs:label "servlet" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:setContext
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue "div" ;
      spl:optional true ;
      spl:predicate ui:elementType ;
      spl:valueType xsd:string ;
      rdfs:comment "An HTML element name, defaulting to \"div\"." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:flattened ;
      spl:valueType xsd:boolean ;
      rdfs:comment "See comment on ui:queryGraph." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:lang ;
      spl:valueType xsd:string ;
      rdfs:comment "The language to use in the children of this, via ui:lang()." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:queryGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The new graph to run queries against. Any SPARQL queries in the children of this will have the new graph as their default graph. If ui:flattened is set to true then this graph will first be copied into a single \"flat\" in-memory graph, potentially boosting performance of queries if the original graph had many subgraphs." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:removeQueryGraphs ;
      spl:valueType xsd:string ;
      rdfs:comment "A space-separated list of graph URIs. If present and the current query graph is a union graph (e.g. created using ui:graphWithImports) then the new query graph will be the union minus the enumerated graphs." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:shapesGraph ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "A default shapes graph for calls of tosh:hasShape." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:silentTransactions ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to suppress any JSON output from ui:transactions and ui:updates inside of this block." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a context variable that can be made visible for all children of this context, including calls into prototypes. Use ui:contextValue(?varName) to query that value later." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:varValue ;
      rdfs:comment "The new value for the context variable specified by the ui:varName argument. Can be unbound to overwrite any existing context variable." ;
    ] ;
  rdfs:comment "Changes the execution context of the children." ;
  rdfs:label "set context" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:setGlobalVar
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:value ;
      rdfs:comment "The value to set, may be unbound to delete the variable." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:name ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the variable." ;
    ] ;
  ui:prototype [
      a ui:setContext ;
      ui:child [
          a ui:update ;
          ui:childIndex 0 ;
          ui:updateQuery [
              a sp:Modify ;
              sp:deletePattern (
                  [
                    sp:object [
                        sp:varName "oldObject" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                ) ;
              sp:insertPattern (
                  [
                    sp:object [
                        sp:varName "value" ;
                      ] ;
                    sp:predicate [
                        sp:varName "predicate" ;
                      ] ;
                    sp:subject [
                        sp:varName "subject" ;
                      ] ;
                  ]
                ) ;
              sp:where (
                  [
                    a sp:Bind ;
                    sp:expression ui:GlobalVars ;
                    sp:variable [
                        sp:varName "subject" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a sp:iri ;
                        sp:arg1 [
                            a sp:concat ;
                            sp:arg1 "urn:x-global-var:" ;
                            sp:arg2 [
                                sp:varName "name" ;
                              ] ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "predicate" ;
                      ] ;
                  ]
                  [
                    a sp:Bind ;
                    sp:expression [
                        a spl:object ;
                        sp:arg1 [
                            sp:varName "subject" ;
                          ] ;
                        sp:arg2 [
                            sp:varName "predicate" ;
                          ] ;
                      ] ;
                    sp:variable [
                        sp:varName "oldObject" ;
                      ] ;
                  ]
                ) ;
            ] ;
        ] ;
      ui:queryGraph ui:tempGraphGlobalVars ;
    ] ;
  rdfs:comment "Sets a \"global\" variable as a triple in a dedicated ui:tempGraph." ;
  rdfs:label "set global var" ;
  rdfs:subClassOf ui:Operations ;
.
ui:setPrefix
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:namespace ;
      spl:valueType xsd:string ;
      rdfs:comment "The new namespace for the prefix. If left empty then the prefix will be deleted." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:prefix ;
      spl:valueType xsd:string ;
      rdfs:comment "The prefix to set, e.g. \"dct\"." ;
    ] ;
  rdfs:comment "Changes a namespace prefix in the current query graph. This is often applied to a temp graph by surrounding it with a ui:setContext call." ;
  rdfs:label "set prefix" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:setPropertyValue
  a ui:Method ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate arg:value ;
      rdfs:comment "The new value of the property." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:property ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to set." ;
    ] ;
  ui:prototype [
      a ui:transaction ;
      ui:child [
          a ui:addPropertyValue ;
          arg:property [
              sp:varName "property" ;
            ] ;
          arg:value [
              sp:varName "value" ;
            ] ;
          ui:childIndex 1 ;
        ] ;
      ui:child [
          a ui:removePropertyValues ;
          arg:property [
              sp:varName "property" ;
            ] ;
          ui:childIndex 0 ;
        ] ;
    ] ;
  rdfs:comment "A generic operation that \"sets\" a property (arg:property) at a subject (ui:this) to a certain value (arg:value). Any previous value of the property will be overwritten. This is basically a combination of ui:addPropertyValue and ui:removePropertyValues." ;
  rdfs:label "set property value" ;
  rdfs:subClassOf ui:Methods ;
.
ui:setResponseHeader
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue 200 ;
      spl:optional true ;
      spl:predicate ui:statusCode ;
      spl:valueType xsd:integer ;
      rdfs:comment "The status code for the HTTP response, e.g. 201." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:headerName ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of a response header to set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:headerValue ;
      spl:valueType xsd:string ;
      rdfs:comment "The value of a response header to set." ;
    ] ;
  rdfs:comment """Can be used to set the status code and other header of the HTTP response of the current SWP servlet request. Typical values for the status code are 201 or 404.

This is only supported for direct, uncached servlet calls (and not, for example, from within SPARQLMotion).""" ;
  rdfs:label "set response header" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:setSessionAttribute
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the attribute to set." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "The new value of the attribute." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Sets an attribute of the currently active client session. This makes it possible to maintain state while the user is clicking between multiple SWP pages in the browser. The result of the function itself is the empty string." ;
  rdfs:label "set session attribute" ;
  rdfs:subClassOf spl:MiscFunctions ;
.
ui:shapesGraph
  a rdf:Property ;
  rdfs:label "shapes graph" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:silentTransactions
  a rdf:Property ;
  rdfs:label "silent transactions" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:snippet
  a rdf:Property ;
  rdfs:label "snippet" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:statusCode
  a rdf:Property ;
  rdfs:label "status code" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:str
  a rdf:Property ;
  rdfs:label "str" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:stringify
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:defaultValue ui:HTML ;
      spl:optional true ;
      spl:predicate ui:format ;
      spl:valueType ui:ResponseType ;
      rdfs:comment "A response type (mime type) such as ui:JSON to render the nodes in." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:full ;
      spl:valueType xsd:boolean ;
      rdfs:comment "True to generate a \"full\" HTML file, including head." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:varName ;
      spl:valueType xsd:string ;
      rdfs:comment "The variable name." ;
    ] ;
  rdfs:comment "Can only be used in conjunction with ui:bind. Executes its child elements and turns them into a string variable of the name given as ui:varName." ;
  rdfs:label "stringify" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:subTask
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:subTaskName ;
      spl:valueType xsd:string ;
      rdfs:comment "The display label of the subtask, set when the task starts." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:work ;
      spl:valueType xsd:integer ;
      rdfs:comment "The amount of progress." ;
    ] ;
  rdfs:comment "Can be used inside of ui:task elements to mark progress in the task. For example, if the surrounding ui:task has declared to have a total work of 100, then ui:subTask elements can be placed inside of the task to increase by 1 if there are 100 steps. This element can also be used to change the label of the subtask to inform the user of what's currently being executed." ;
  rdfs:label "sub task" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:subTaskName
  a rdf:Property ;
  rdfs:label "sub task name" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:systemPreference
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The name of the preference to get." ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Gets a system preference set by the UISPIN execution environment. These are typically server-specific settings such as how to redirect hyperlinks, or Google API keys, that can be queried by UISPIN elements to adjust the page generation." ;
  rdfs:label "system preference" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:systemProperty
  a rdf:Property ;
  rdfs:label "system property" ;
.
ui:targetGraph
  a rdf:Property ;
  rdfs:label "target graph" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:task
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:taskName ;
      spl:valueType xsd:string ;
      rdfs:comment "The display label of the task." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:totalWork ;
      spl:valueType xsd:integer ;
      rdfs:comment "The total amount of steps needed to complete the task. Can be used to display a progress bar. Use ui:progressWorked to move progress further." ;
    ] ;
  rdfs:comment "Executes the child elements as a task that can be treated as a unit of work in progress monitors. This should be used for long-running operations such as complex report generation procedures, to allow the environment to provide intermediate feedback to the user." ;
  rdfs:label "task" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:taskName
  a rdf:Property ;
  rdfs:label "task name" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:tempGraph
  a rdfs:Resource ;
  rdfs:comment "The URI of a named graph that is accessible at run time as a place to write temporary triples to. This can be used during the execution of an SWP document to keep track of status changes. Use ui:update, e.g. with INSERT { GRAPH ui:tempGraph { ... } }, to modify those triples. Use GRAPH ui:tempGraph { ... } in WHERE clauses to query this graph. Note that any other URI starting with ui:tempGraph can also be used, and will create a different graph each (for example, ui:tempGraphInferences will also work)." ;
  rdfs:label "temp graph" ;
.
ui:tempGraphGlobalVars
  a rdfs:Resource ;
  rdfs:comment "The graph containing the global variables." ;
  rdfs:label "temp graph global vars" ;
.
ui:template
  a rdf:Property ;
  rdfs:label "template" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:testUserName
  a rdf:Property ;
  rdfs:label "test user name" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:text
  a rdf:Property ;
  rdfs:comment "The actual text in a ui:TextNode." ;
  rdfs:label "text" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:thenLoadId
  a rdf:Property ;
  rdfs:label "then load id" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:this
  a rdf:Property ;
  rdfs:comment "Can be used as an argument to change the value of ?this." ;
  rdfs:label "this" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:throw
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:message ;
      spl:valueType xsd:string ;
      rdfs:comment "A message to explain the error." ;
    ] ;
  rdfs:comment "Throws an error that will (by default) be reported back as a failure to the client. This can be used to implement pre-condition checking in services such as Ajax call-backs." ;
  rdfs:label "throw" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:totalWork
  a rdf:Property ;
  rdfs:label "total work" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:transaction
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:checkConstraints ;
      spl:valueType xsd:boolean ;
      rdfs:comment """True to perform constraint checking before the transaction is closed. If a constraint violation has been delected, an error will be produced. If set to true, the contained UPDATEs will be first applied to a temporary \"buffering\" graph, without affecting the underlying target graph.

THIS IS CURRENTLY ONLY SUPPORTED FOR GRAPHS UNDER EVN/EDG TEAMWORK CONTROL.""" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:logMessage ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional log message that serves as label for the transaction. This should describe the overall purpose of the encosed updates." ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate ui:metadata ;
      spl:valueType xsd:string ;
      rdfs:comment "An optional metadata string that can be included in the JSON object describing the change." ;
    ] ;
  rdfs:comment """Can be used to group together multiple updates, so that they are treated as a single atomic operation. The details of this element are platform and application specific. Some platforms may support ACID like transactions, but others may not.

Note that this element will produce JSON output to the response stream. To suppress this, wrap the transaction with <ui:setContext ui:silentTransactions=\"true\">...""" ;
  rdfs:label "transaction" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:try
  a ui:NodeClass ;
  rdfs:comment """Executes its children, catching any exceptions that may happen. If an exception happens, the associated <ui:catch> block will be executed. Syntax:

<ui:group>
	<ui:try>
		<do:something />
	</ui:try>
	<ui:catch>
		<handle:error arg:exception=\"{= ?exception }\" arg:stack=\"{= ?stackTrace }\" />
	</ui:catch>
</ui:group>""" ;
  rdfs:label "try" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:unionGraph
  a rdfs:Resource ;
  rdfs:comment "The URI of the union of the current query graph plus the ui:graph. This can be used to ask queries across both graphs at the same time." ;
  rdfs:label "union graph" ;
.
ui:unionOfGraphs
  a spin:Function ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Takes one or more URI resources of named graphs and produces a new URI resource describing a graph that will be recognized by the engine as the union of the named graphs. This can be used to construct temporary query graphs and pass them around with a well-defined URI. All arguments must be URI resources - there can be any number of them. Use ui:baseGraph() for the \"reverse\" of this operation." ;
  rdfs:label "union of graphs" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
ui:unionOfGraphsFromResultSet
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate arg:resultSet ;
      spl:valueType spr:Table ;
      rdfs:comment "The SPR result set to walk through." ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Takes a result set listing a collection of graph nodes (URI resources) and produces a new URI resource describing a graph that will be recognized by the engine as the union of those named graphs. This can be used to construct temporary query graphs and pass them around with a well-defined URI. This function can only be used inside of an executing SWP engine, because it needs to access the result set object. Use ui:baseGraph() for the \"reverse\" of this operation." ;
  rdfs:label "union of graphs from result set" ;
  rdfs:subClassOf spl:OntologyFunctions ;
.
ui:uniqueId
  a spin:Function ;
  spin:returnType xsd:string ;
  rdfs:comment "Generates a string identifier that is unique for the life time of the UISPIN execution engine." ;
  rdfs:label "unique id" ;
  rdfs:subClassOf spl:StringFunctions ;
.
ui:update
  a ui:NodeClass ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate ui:updateQuery ;
      spl:valueType sp:Update ;
      rdfs:comment "The UPDATE query to execute. May access the variables of the current scope using <urn:x-var:varName>." ;
    ] ;
  rdfs:comment """Executes a SPARQL UPDATE query on the server.

It is strongly recommended to wrap calls of this into a ui:transaction where the updated graph needs to be the default query graph before the transaction starts. So a typical pattern is

<ui:setContext ui:queryGraph=\"&lt;http://example.org/updateTest/targetGraph&gt;\">
    <ui:transaction>
        <ui:update ui:updateQuery=\"{! 
			INSERT { 
				... no GRAPH clause here ... 
			}
			WHERE {
				GRAPH ... {
				}
			} }\" />
		... other ui:updates or ui:calls with ui:template ... 
    </ui:transaction>
</ui:setContext>

Note that this element will produce JSON output to the response stream. To suppress this, wrap the transaction with <ui:setContext ui:silentTransactions=\"true\">...""" ;
  rdfs:label "update" ;
  rdfs:subClassOf ui:ControlElement ;
.
ui:updateQuery
  a rdf:Property ;
  rdfs:label "update query" ;
  rdfs:range sp:Update ;
  rdfs:subPropertyOf spin:query ;
.
ui:value
  a rdf:Property ;
  rdfs:label "value" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:varName
  a rdf:Property ;
  rdfs:label "var name" ;
  rdfs:range xsd:string ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:varValue
  a rdf:Property ;
  rdfs:label "value" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:view
  a rdf:Property ;
  rdfs:comment "Links a resource (instance) with an element that can be used to render the resource on the screen. Queries associated with the element can access the resource with the variable ?this." ;
  rdfs:domain rdfs:Resource ;
  rdfs:label "view" ;
  rdfs:range ui:Element ;
.
ui:viewClass
  a rdf:Property ;
  rdfs:label "view class" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:viewElement
  a rdf:Property ;
  rdfs:comment "Can be used to link a class with ui:ViewElements that render instances of that class. In those elements, the variable ?this (ui:this) would point to the current instance to display. Together with ui:method and ui:rule, the property ui:viewElement can be used to organize views in an object-oriented manner." ;
  rdfs:domain rdfs:Class ;
  rdfs:label "view element" ;
  rdfs:range ui:ViewElement ;
  rdfs:subPropertyOf ui:element ;
.
ui:viewName
  a rdf:Property ;
  rdfs:label "view name" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:warn
  a rdf:Property ;
  rdfs:label "warn" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:width
  a rdf:Property ;
  rdfs:comment "The width (in pixels) of an element on a page." ;
  rdfs:label "width" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:work
  a rdf:Property ;
  rdfs:label "work" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:x
  a rdf:Property ;
  rdfs:comment "The X-axis coordinate of an element on a page." ;
  rdfs:label "x" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:xml
  a rdf:Property ;
  rdfs:label "xml" ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:xmlns
  a rdf:Property ;
  rdfs:comment "Adds a local namespace declaration to the current XML element for the given resource. Assumes that a prefix for the namespace of the resource exists, and will result in an xmlns:... attribute." ;
  rdfs:label "xmlns" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf ui:systemProperty ;
.
ui:y
  a rdf:Property ;
  rdfs:comment "The Y-axis coordinate of an element on a page." ;
  rdfs:label "y" ;
  rdfs:range xsd:integer ;
  rdfs:subPropertyOf ui:systemProperty ;
.
<http://www.topbraid.org/2007/05/composite.owl>
  a owl:Ontology ;
  rdfs:comment "A simple ontology to help representing part-of (parent/child) relationships." ;
  owl:versionInfo "Created with TopBraid Composer by Holger Knublauch" ;
.
composite:child
  a owl:ObjectProperty ;
  rdfs:comment "The object is the child of the subject." ;
  owl:inverseOf composite:parent ;
.
composite:index
  a owl:DatatypeProperty ;
  rdfs:comment "The index of the subject among its siblings. Note that this could in principle take arbitrary numbers (including floats). We recommend using xsd:ints starting at 0." ;
  rdfs:range xsd:int ;
.
composite:parent
  a owl:ObjectProperty ;
  rdfs:comment "The object is the parent of the subject." ;
  owl:inverseOf composite:child ;
.
rdf:
  tosh:systemNamespace true ;
.
rdf:Alt
  a rdfs:Class ;
  rdfs:comment "The class of containers of alternatives." ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "Alt" ;
  rdfs:subClassOf rdfs:Container ;
.
rdf:Bag
  a rdfs:Class ;
  rdfs:comment "The class of unordered containers." ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "Bag" ;
  rdfs:subClassOf rdfs:Container ;
.
rdf:HTML
  a rdfs:Datatype ;
  rdfs:label "HTML" ;
  rdfs:subClassOf rdfs:Literal ;
.
rdf:List
  a rdfs:Class ;
  rdfs:comment "The class of RDF Lists." ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "List" ;
  rdfs:subClassOf rdfs:Resource ;
.
rdf:Property
  a rdfs:Class ;
  rdfs:comment "The class of RDF properties." ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "Property" ;
  rdfs:subClassOf rdfs:Resource ;
.
rdf:Seq
  a rdfs:Class ;
  rdfs:comment "The class of ordered containers." ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "Seq" ;
  rdfs:subClassOf rdfs:Container ;
.
rdf:Statement
  a rdfs:Class ;
  rdfs:comment "The class of RDF statements." ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "Statement" ;
  rdfs:subClassOf rdfs:Resource ;
.
rdf:XMLLiteral
  a rdfs:Datatype ;
  rdfs:comment "The class of XML literal values." ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "XMLLiteral" ;
  rdfs:subClassOf rdfs:Resource ;
.
rdf:first
  a rdf:Property ;
  rdfs:comment "The first item in the subject RDF list." ;
  rdfs:domain rdf:List ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "first" ;
  rdfs:range rdfs:Resource ;
.
rdf:langString
  a rdfs:Datatype ;
  rdfs:label "langString" ;
  rdfs:subClassOf rdfs:Literal ;
.
()
  a rdf:List ;
  rdfs:comment "The empty list, with no items in it. If the rest of a list is nil then the list has no more items in it." ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "nil" ;
.
rdf:object
  a rdf:Property ;
  rdfs:comment "The object of the subject RDF statement." ;
  rdfs:domain rdf:Statement ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "object" ;
  rdfs:range rdfs:Resource ;
.
rdf:predicate
  a rdf:Property ;
  rdfs:comment "The predicate of the subject RDF statement." ;
  rdfs:domain rdf:Statement ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "predicate" ;
  rdfs:range rdf:Property ;
.
rdf:rest
  a rdf:Property ;
  rdfs:comment "The rest of the subject RDF list after the first item." ;
  rdfs:domain rdf:List ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "rest" ;
  rdfs:range rdf:List ;
.
rdf:subject
  a rdf:Property ;
  rdfs:comment "The subject of the subject RDF statement." ;
  rdfs:domain rdf:Statement ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "subject" ;
  rdfs:range rdfs:Resource ;
.
rdf:value
  a rdf:Property ;
  rdfs:comment "Idiomatic property used for structured values." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy rdf: ;
  rdfs:label "value" ;
  rdfs:range rdfs:Resource ;
.
rdfs:
  tosh:systemNamespace true ;
  rdfs:seeAlso <http://www.w3.org/2000/01/rdf-schema-more> ;
.
rdfs:Class
  a rdfs:Class ;
  rdfs:comment "The class of classes." ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "Class" ;
  rdfs:subClassOf rdfs:Resource ;
.
rdfs:Container
  a rdfs:Class ;
  rdfs:comment "The class of RDF containers." ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "Container" ;
  rdfs:subClassOf rdfs:Resource ;
.
rdfs:ContainerMembershipProperty
  a rdfs:Class ;
  rdfs:comment """The class of container membership properties, rdf:_1, rdf:_2, ...,
                    all of which are sub-properties of 'member'.""" ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "ContainerMembershipProperty" ;
  rdfs:subClassOf rdf:Property ;
.
rdfs:Datatype
  a rdfs:Class ;
  rdfs:comment "The class of RDF datatypes." ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "Datatype" ;
  rdfs:subClassOf rdfs:Class ;
.
rdfs:Literal
  a rdfs:Class ;
  rdfs:comment "The class of literal values, eg. textual strings and integers." ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "Literal" ;
  rdfs:subClassOf rdfs:Resource ;
.
rdfs:Resource
  a rdfs:Class ;
  rdfs:comment "The class resource, everything." ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "Resource" ;
.
rdfs:comment
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:comment "A description of the subject resource." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "comment" ;
  rdfs:range rdfs:Literal ;
.
rdfs:domain
  a rdf:Property ;
  rdfs:comment "A domain of the subject property." ;
  rdfs:domain rdf:Property ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "domain" ;
  rdfs:range rdfs:Class ;
.
rdfs:isDefinedBy
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:comment "The defininition of the subject resource." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "isDefinedBy" ;
  rdfs:range rdfs:Resource ;
  rdfs:subPropertyOf rdfs:seeAlso ;
.
rdfs:label
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:comment "A human-readable name for the subject." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "label" ;
  rdfs:range rdfs:Literal ;
.
rdfs:member
  a rdf:Property ;
  rdfs:comment "A member of the subject container." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "member" ;
  rdfs:range rdfs:Resource ;
.
rdfs:range
  a rdf:Property ;
  rdfs:comment "A range of the subject property." ;
  rdfs:domain rdf:Property ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "range" ;
  rdfs:range rdfs:Class ;
.
rdfs:seeAlso
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:comment "Further information about the subject resource." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "seeAlso" ;
  rdfs:range rdfs:Resource ;
.
rdfs:subClassOf
  a rdf:Property ;
  rdfs:comment "The subject is a subclass of a class." ;
  rdfs:domain rdfs:Class ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "subClassOf" ;
  rdfs:range rdfs:Class ;
.
rdfs:subPropertyOf
  a rdf:Property ;
  rdfs:comment "The subject is a subproperty of a property." ;
  rdfs:domain rdf:Property ;
  rdfs:isDefinedBy rdfs: ;
  rdfs:label "subPropertyOf" ;
  rdfs:range rdf:Property ;
.
xsd:
  tosh:systemNamespace true ;
.
xsd:ENTITY
  a rdfs:Datatype ;
  rdfs:label "ENTITY" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:ID
  a rdfs:Datatype ;
  rdfs:label "ID" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:IDREF
  a rdfs:Datatype ;
  rdfs:label "IDREF" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:NCName
  a rdfs:Datatype ;
  rdfs:label "NCName" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:NMTOKEN
  a rdfs:Datatype ;
  rdfs:label "NMTOKEN" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:NOTATION
  a rdfs:Datatype ;
  rdfs:label "NOTATION" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:Name
  a rdfs:Datatype ;
  rdfs:label "Name" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:QName
  a rdfs:Datatype ;
  rdfs:label "QName" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:anySimpleType
  a rdfs:Datatype ;
  rdfs:label "anySimpleType" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:anyURI
  a rdfs:Datatype ;
  rdfs:label "anyURI" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:base64Binary
  a rdfs:Datatype ;
  rdfs:label "base64Binary" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:boolean
  a rdfs:Datatype ;
  rdfs:label "boolean" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:byte
  a rdfs:Datatype ;
  rdfs:label "byte" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:date
  a rdfs:Datatype ;
  rdfs:label "date" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:dateTime
  a rdfs:Datatype ;
  rdfs:label "dateTime" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:dateTimeStamp
  a rdfs:Datatype ;
  rdfs:label "dateTimeStamp" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:decimal
  a rdfs:Datatype ;
  rdfs:label "decimal" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:double
  a rdfs:Datatype ;
  rdfs:label "double" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:duration
  a rdfs:Datatype ;
  rdfs:label "duration" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:float
  a rdfs:Datatype ;
  rdfs:label "float" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:fractionDigits
  a rdf:Property ;
  rdfs:comment "fractionDigits controls the size of the minimum difference between values in the value space of datatypes derived from decimal, by restricting the value space to numbers that are expressible as i x 10^-n where i and n are integers and 0 <= n <= fractionDigits." ;
  rdfs:label "fraction digits" ;
  rdfs:range xsd:nonNegativeInteger ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-fractionDigits> ;
.
xsd:gDay
  a rdfs:Datatype ;
  rdfs:label "gDay" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:gMonth
  a rdfs:Datatype ;
  rdfs:label "gMonth" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:gMonthDay
  a rdfs:Datatype ;
  rdfs:label "gMonthDay" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:gYear
  a rdfs:Datatype ;
  rdfs:label "gYear" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:gYearMonth
  a rdfs:Datatype ;
  rdfs:label "gYearMonth" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:hexBinary
  a rdfs:Datatype ;
  rdfs:label "hexBinary" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:int
  a rdfs:Datatype ;
  rdfs:label "int" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:integer
  a rdfs:Datatype ;
  rdfs:label "integer" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:language
  a rdfs:Datatype ;
  rdfs:label "language" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:length
  a rdf:Property ;
  rdfs:comment "length is the number of units of length, where units of length varies depending on the type that is being derived from." ;
  rdfs:label "length" ;
  rdfs:range xsd:nonNegativeInteger ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-length> ;
.
xsd:long
  a rdfs:Datatype ;
  rdfs:label "long" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:maxExclusive
  a rdf:Property ;
  rdfs:comment "maxExclusive is the exclusive upper bound of the value space for a datatype with the ordered property. The value of maxExclusive must be in the value space of the base type or be equal to {value} in {base type definition}." ;
  rdfs:label "max exclusive" ;
  rdfs:range rdfs:Literal ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-maxExclusive> ;
.
xsd:maxInclusive
  a rdf:Property ;
  rdfs:comment "maxInclusive is the inclusive upper bound of the value space for a datatype with the ordered property. The value of maxInclusive must be in the value space of the base type." ;
  rdfs:label "max inclusive" ;
  rdfs:range rdfs:Literal ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-maxInclusive> ;
.
xsd:maxLength
  a rdf:Property ;
  rdfs:comment "minLength is the minimum number of units of length, where units of length varies depending on the type that is being derived from." ;
  rdfs:label "max length" ;
  rdfs:range xsd:nonNegativeInteger ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-minLength> ;
.
xsd:minExclusive
  a rdf:Property ;
  rdfs:comment "minExclusive is the exclusive lower bound of the value space for a datatype with the ordered property. The value of minExclusive must be in the value space of the base type or be equal to {value} in {base type definition}." ;
  rdfs:label "min exclusive" ;
  rdfs:range rdfs:Literal ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-minExclusive> ;
.
xsd:minInclusive
  a rdf:Property ;
  rdfs:comment "minInclusive is the inclusive lower bound of the value space for a datatype with the ordered property. The value of minInclusive must be in the value space of the base type." ;
  rdfs:label "min inclusive" ;
  rdfs:range rdfs:Literal ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-minInclusive> ;
.
xsd:minLength
  a rdf:Property ;
  rdfs:comment "maxLength is the maximum number of units of length, where units of length varies depending on the type that is being derived from." ;
  rdfs:label "min length" ;
  rdfs:range xsd:nonNegativeInteger ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-maxLength> ;
.
xsd:negativeInteger
  a rdfs:Datatype ;
  rdfs:label "negativeInteger" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:nonNegativeInteger
  a rdfs:Datatype ;
  rdfs:label "nonNegativeInteger" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:nonPositiveInteger
  a rdfs:Datatype ;
  rdfs:label "nonPositiveInteger" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:normalizedString
  a rdfs:Datatype ;
  rdfs:label "normalizedString" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:pattern
  a rdf:Property ;
  rdfs:comment "pattern is a constraint on the value space of a datatype which is achieved by constraining the lexical space to literals which match a specific pattern. The value of pattern must be a regular expression." ;
  rdfs:label "pattern" ;
  rdfs:range xsd:string ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-pattern> ;
.
xsd:positiveInteger
  a rdfs:Datatype ;
  rdfs:label "positiveInteger" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:short
  a rdfs:Datatype ;
  rdfs:label "short" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:string
  a rdfs:Datatype ;
  rdfs:label "string" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:time
  a rdfs:Datatype ;
  rdfs:label "time" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:token
  a rdfs:Datatype ;
  rdfs:label "token" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:totalDigits
  a rdf:Property ;
  rdfs:comment "totalDigits controls the maximum number of values in the value space of datatypes derived from decimal, by restricting it to numbers that are expressible as i x 10^-n where i and n are integers such that |i| < 10^totalDigits and 0 <= n <= totalDigits." ;
  rdfs:label "total digits" ;
  rdfs:range xsd:nonNegativeInteger ;
  rdfs:seeAlso <http://www.w3.org/TR/xmlschema-2/#rf-totalDigits> ;
.
xsd:unsignedByte
  a rdfs:Datatype ;
  rdfs:label "unsignedByte" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:unsignedInt
  a rdfs:Datatype ;
  rdfs:label "unsignedInt" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:unsignedLong
  a rdfs:Datatype ;
  rdfs:label "unsignedLong" ;
  rdfs:subClassOf rdfs:Literal ;
.
xsd:unsignedShort
  a rdfs:Datatype ;
  rdfs:label "unsignedShort" ;
  rdfs:subClassOf rdfs:Literal ;
.
<http://www.w3.org/2002/07/owl>
  a owl:Ontology ;
  rdfs:comment """
  This ontology partially describes the built-in classes and
  properties that together form the basis of the RDF/XML syntax of OWL 2.
  The content of this ontology is based on Tables 6.1 and 6.2
  in Section 6.4 of the OWL 2 RDF-Based Semantics specification,
  available at http://www.w3.org/TR/owl2-rdf-based-semantics/.
  Please note that those tables do not include the different annotations
  (labels, comments and rdfs:isDefinedBy links) used in this file.  
  Also note that the descriptions provided in this ontology do not
  provide a complete and correct formal description of either the syntax
  or the semantics of the introduced terms (please see the OWL 2
  recommendations for the complete and normative specifications).
  Furthermore, the information provided by this ontology may be
  misleading if not used with care. This ontology SHOULD NOT be imported
  into OWL ontologies. Importing this file into an OWL 2 DL ontology
  will cause it to become an OWL 2 Full ontology and may have other,
  unexpected, consequences.
   """ ;
  rdfs:isDefinedBy <http://www.w3.org/TR/owl2-mapping-to-rdf/> ;
  rdfs:isDefinedBy <http://www.w3.org/TR/owl2-rdf-based-semantics/> ;
  rdfs:isDefinedBy <http://www.w3.org/TR/owl2-syntax/> ;
  rdfs:seeAlso <http://www.w3.org/TR/owl2-rdf-based-semantics/#table-axiomatic-classes> ;
  rdfs:seeAlso <http://www.w3.org/TR/owl2-rdf-based-semantics/#table-axiomatic-properties> ;
  owl:versionIRI <http://www.w3.org/2002/07/owl> ;
  owl:versionInfo "$Date: 2009/11/04 15:40:28 $" ;
.
owl:
  tosh:systemNamespace true ;
.
owl:AllDifferent
  a rdfs:Class ;
  rdfs:comment "The class of collections of pairwise different individuals." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "AllDifferent" ;
  rdfs:subClassOf rdfs:Resource ;
.
owl:AllDisjointClasses
  a rdfs:Class ;
  rdfs:comment "The class of collections of pairwise disjoint classes." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "AllDisjointClasses" ;
  rdfs:subClassOf rdfs:Resource ;
.
owl:AllDisjointProperties
  a rdfs:Class ;
  rdfs:comment "The class of collections of pairwise disjoint properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "AllDisjointProperties" ;
  rdfs:subClassOf rdfs:Resource ;
.
owl:Annotation
  a rdfs:Class ;
  rdfs:comment "The class of annotated annotations for which the RDF serialization consists of an annotated subject, predicate and object." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "Annotation" ;
  rdfs:subClassOf rdfs:Resource ;
.
owl:AnnotationProperty
  a rdfs:Class ;
  rdfs:comment "The class of annotation properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "AnnotationProperty" ;
  rdfs:subClassOf rdf:Property ;
.
owl:AsymmetricProperty
  a rdfs:Class ;
  rdfs:comment "The class of asymmetric properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "AsymmetricProperty" ;
  rdfs:subClassOf owl:ObjectProperty ;
.
owl:Axiom
  a rdfs:Class ;
  rdfs:comment "The class of annotated axioms for which the RDF serialization consists of an annotated subject, predicate and object." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "Axiom" ;
  rdfs:subClassOf rdfs:Resource ;
.
owl:Class
  a rdfs:Class ;
  rdfs:comment "The class of OWL classes." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "Class" ;
  rdfs:subClassOf rdfs:Class ;
.
owl:DataRange
  a rdfs:Class ;
  rdfs:comment "The class of OWL data ranges, which are special kinds of datatypes. Note: The use of the IRI owl:DataRange has been deprecated as of OWL 2. The IRI rdfs:Datatype SHOULD be used instead." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "DataRange" ;
  rdfs:subClassOf rdfs:Datatype ;
.
owl:DatatypeProperty
  a rdfs:Class ;
  rdfs:comment "The class of data properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "DatatypeProperty" ;
  rdfs:subClassOf rdf:Property ;
.
owl:DeprecatedClass
  a rdfs:Class ;
  rdfs:comment "The class of deprecated classes." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "DeprecatedClass" ;
  rdfs:subClassOf rdfs:Class ;
.
owl:DeprecatedProperty
  a rdfs:Class ;
  rdfs:comment "The class of deprecated properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "DeprecatedProperty" ;
  rdfs:subClassOf rdf:Property ;
.
owl:FunctionalProperty
  a rdfs:Class ;
  rdfs:comment "The class of functional properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "FunctionalProperty" ;
  rdfs:subClassOf rdf:Property ;
.
owl:InverseFunctionalProperty
  a rdfs:Class ;
  rdfs:comment "The class of inverse-functional properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "InverseFunctionalProperty" ;
  rdfs:subClassOf owl:ObjectProperty ;
.
owl:IrreflexiveProperty
  a rdfs:Class ;
  rdfs:comment "The class of irreflexive properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "IrreflexiveProperty" ;
  rdfs:subClassOf owl:ObjectProperty ;
.
owl:NamedIndividual
  a rdfs:Class ;
  rdfs:comment "The class of named individuals." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "NamedIndividual" ;
  rdfs:subClassOf owl:Thing ;
.
owl:NegativePropertyAssertion
  a rdfs:Class ;
  rdfs:comment "The class of negative property assertions." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "NegativePropertyAssertion" ;
  rdfs:subClassOf rdfs:Resource ;
.
owl:Nothing
  a owl:Class ;
  rdfs:comment "This empty class." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "Nothing" ;
  rdfs:subClassOf owl:Thing ;
.
owl:ObjectProperty
  a rdfs:Class ;
  rdfs:comment "The class of object properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "ObjectProperty" ;
  rdfs:subClassOf rdf:Property ;
.
owl:Ontology
  a rdfs:Class ;
  rdfs:comment "The class of ontologies." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "Ontology" ;
  rdfs:subClassOf graphql:Schema ;
  rdfs:subClassOf rdfs:Resource ;
.
owl:OntologyProperty
  a rdfs:Class ;
  rdfs:comment "The class of ontology properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "OntologyProperty" ;
  rdfs:subClassOf rdf:Property ;
.
owl:ReflexiveProperty
  a rdfs:Class ;
  rdfs:comment "The class of reflexive properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "ReflexiveProperty" ;
  rdfs:subClassOf owl:ObjectProperty ;
.
owl:Restriction
  a rdfs:Class ;
  rdfs:comment "The class of property restrictions." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "Restriction" ;
  rdfs:subClassOf owl:Class ;
.
owl:SymmetricProperty
  a rdfs:Class ;
  rdfs:comment "The class of symmetric properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "SymmetricProperty" ;
  rdfs:subClassOf owl:ObjectProperty ;
.
owl:Thing
  a owl:Class ;
  rdfs:comment "The class of OWL individuals." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "Thing" ;
  rdfs:subClassOf rdfs:Resource ;
.
owl:TransitiveProperty
  a rdfs:Class ;
  rdfs:comment "The class of transitive properties." ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "TransitiveProperty" ;
  rdfs:subClassOf owl:ObjectProperty ;
.
owl:allValuesFrom
  a rdf:Property ;
  rdfs:comment "The property that determines the class that a universal property restriction refers to." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "allValuesFrom" ;
  rdfs:range rdfs:Class ;
.
owl:annotatedProperty
  a rdf:Property ;
  rdfs:comment "The property that determines the predicate of an annotated axiom or annotated annotation." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "annotatedProperty" ;
  rdfs:range rdfs:Resource ;
.
owl:annotatedSource
  a rdf:Property ;
  rdfs:comment "The property that determines the subject of an annotated axiom or annotated annotation." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "annotatedSource" ;
  rdfs:range rdfs:Resource ;
.
owl:annotatedTarget
  a rdf:Property ;
  rdfs:comment "The property that determines the object of an annotated axiom or annotated annotation." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "annotatedTarget" ;
  rdfs:range rdfs:Resource ;
.
owl:assertionProperty
  a rdf:Property ;
  rdfs:comment "The property that determines the predicate of a negative property assertion." ;
  rdfs:domain owl:NegativePropertyAssertion ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "assertionProperty" ;
  rdfs:range rdf:Property ;
.
owl:backwardCompatibleWith
  a owl:AnnotationProperty ;
  a owl:OntologyProperty ;
  rdfs:comment "The annotation property that indicates that a given ontology is backward compatible with another ontology." ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "backwardCompatibleWith" ;
  rdfs:range owl:Ontology ;
.
owl:bottomDataProperty
  a owl:DatatypeProperty ;
  rdfs:comment "The data property that does not relate any individual to any data value." ;
  rdfs:domain owl:Thing ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "bottomDataProperty" ;
  rdfs:range rdfs:Literal ;
.
owl:bottomObjectProperty
  a owl:ObjectProperty ;
  rdfs:comment "The object property that does not relate any two individuals." ;
  rdfs:domain owl:Thing ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "bottomObjectProperty" ;
  rdfs:range owl:Thing ;
.
owl:cardinality
  a rdf:Property ;
  rdfs:comment "The property that determines the cardinality of an exact cardinality restriction." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "cardinality" ;
  rdfs:range xsd:nonNegativeInteger ;
.
owl:complementOf
  a rdf:Property ;
  rdfs:comment "The property that determines that a given class is the complement of another class." ;
  rdfs:domain owl:Class ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "complementOf" ;
  rdfs:range owl:Class ;
.
owl:datatypeComplementOf
  a rdf:Property ;
  rdfs:comment "The property that determines that a given data range is the complement of another data range with respect to the data domain." ;
  rdfs:domain rdfs:Datatype ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "datatypeComplementOf" ;
  rdfs:range rdfs:Datatype ;
.
owl:deprecated
  a owl:AnnotationProperty ;
  rdfs:comment "The annotation property that indicates that a given entity has been deprecated." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "deprecated" ;
  rdfs:range xsd:boolean ;
.
owl:differentFrom
  a rdf:Property ;
  a owl:SymmetricProperty ;
  rdfs:comment "The property that determines that two given individuals are different." ;
  rdfs:domain owl:Thing ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "differentFrom" ;
  rdfs:range owl:Thing ;
.
owl:disjointUnionOf
  a rdf:Property ;
  rdfs:comment "The property that determines that a given class is equivalent to the disjoint union of a collection of other classes." ;
  rdfs:domain owl:Class ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "disjointUnionOf" ;
  rdfs:range rdf:List ;
.
owl:disjointWith
  a rdf:Property ;
  a owl:SymmetricProperty ;
  rdfs:comment "The property that determines that two given classes are disjoint." ;
  rdfs:domain owl:Class ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "disjointWith" ;
  rdfs:range owl:Class ;
.
owl:distinctMembers
  a rdf:Property ;
  rdfs:comment "The property that determines the collection of pairwise different individuals in a owl:AllDifferent axiom." ;
  rdfs:domain owl:AllDifferent ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "distinctMembers" ;
  rdfs:range rdf:List ;
.
owl:equivalentClass
  a rdf:Property ;
  a owl:SymmetricProperty ;
  rdfs:comment "The property that determines that two given classes are equivalent, and that is used to specify datatype definitions." ;
  rdfs:domain rdfs:Class ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "equivalentClass" ;
  rdfs:range rdfs:Class ;
.
owl:equivalentProperty
  a rdf:Property ;
  a owl:SymmetricProperty ;
  rdfs:comment "The property that determines that two given properties are equivalent." ;
  rdfs:domain rdf:Property ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "equivalentProperty" ;
  rdfs:range rdf:Property ;
.
owl:hasKey
  a rdf:Property ;
  rdfs:comment "The property that determines the collection of properties that jointly build a key." ;
  rdfs:domain owl:Class ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "hasKey" ;
  rdfs:range rdf:List ;
.
owl:hasSelf
  a rdf:Property ;
  rdfs:comment "The property that determines the property that a self restriction refers to." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "hasSelf" ;
  rdfs:range rdfs:Resource ;
.
owl:hasValue
  a rdf:Property ;
  rdfs:comment "The property that determines the individual that a has-value restriction refers to." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "hasValue" ;
  rdfs:range rdfs:Resource ;
.
owl:imports
  a owl:OntologyProperty ;
  rdfs:comment "The property that is used for importing other ontologies into a given ontology." ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "imports" ;
  rdfs:range owl:Ontology ;
.
owl:incompatibleWith
  a owl:AnnotationProperty ;
  a owl:OntologyProperty ;
  rdfs:comment "The annotation property that indicates that a given ontology is incompatible with another ontology." ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "incompatibleWith" ;
  rdfs:range owl:Ontology ;
.
owl:intersectionOf
  a rdf:Property ;
  rdfs:comment "The property that determines the collection of classes or data ranges that build an intersection." ;
  rdfs:domain rdfs:Class ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "intersectionOf" ;
  rdfs:range rdf:List ;
.
owl:inverseOf
  a rdf:Property ;
  a owl:SymmetricProperty ;
  rdfs:comment "The property that determines that two given properties are inverse." ;
  rdfs:domain owl:ObjectProperty ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "inverseOf" ;
  rdfs:range owl:ObjectProperty ;
.
owl:maxCardinality
  a rdf:Property ;
  rdfs:comment "The property that determines the cardinality of a maximum cardinality restriction." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "maxCardinality" ;
  rdfs:range xsd:nonNegativeInteger ;
.
owl:maxQualifiedCardinality
  a rdf:Property ;
  rdfs:comment "The property that determines the cardinality of a maximum qualified cardinality restriction." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "maxQualifiedCardinality" ;
  rdfs:range xsd:nonNegativeInteger ;
.
owl:members
  a rdf:Property ;
  rdfs:comment "The property that determines the collection of members in either a owl:AllDifferent, owl:AllDisjointClasses or owl:AllDisjointProperties axiom." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "members" ;
  rdfs:range rdf:List ;
.
owl:minCardinality
  a rdf:Property ;
  rdfs:comment "The property that determines the cardinality of a minimum cardinality restriction." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "minCardinality" ;
  rdfs:range xsd:nonNegativeInteger ;
.
owl:minQualifiedCardinality
  a rdf:Property ;
  rdfs:comment "The property that determines the cardinality of a minimum qualified cardinality restriction." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "minQualifiedCardinality" ;
  rdfs:range xsd:nonNegativeInteger ;
.
owl:onClass
  a rdf:Property ;
  rdfs:comment "The property that determines the class that a qualified object cardinality restriction refers to." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "onClass" ;
  rdfs:range owl:Class ;
.
owl:onDataRange
  a rdf:Property ;
  rdfs:comment "The property that determines the data range that a qualified data cardinality restriction refers to." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "onDataRange" ;
  rdfs:range rdfs:Datatype ;
.
owl:onDatatype
  a rdf:Property ;
  rdfs:comment "The property that determines the datatype that a datatype restriction refers to." ;
  rdfs:domain rdfs:Datatype ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "onDatatype" ;
  rdfs:range rdfs:Datatype ;
.
owl:onProperties
  a rdf:Property ;
  rdfs:comment "The property that determines the n-tuple of properties that a property restriction on an n-ary data range refers to." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "onProperties" ;
  rdfs:range rdf:List ;
.
owl:onProperty
  a rdf:Property ;
  rdfs:comment "The property that determines the property that a property restriction refers to." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "onProperty" ;
  rdfs:range rdf:Property ;
.
owl:oneOf
  a rdf:Property ;
  rdfs:comment "The property that determines the collection of individuals or data values that build an enumeration." ;
  rdfs:domain rdfs:Class ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "oneOf" ;
  rdfs:range rdf:List ;
.
owl:priorVersion
  a owl:AnnotationProperty ;
  a owl:OntologyProperty ;
  rdfs:comment "The annotation property that indicates the predecessor ontology of a given ontology." ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "priorVersion" ;
  rdfs:range owl:Ontology ;
.
owl:propertyChainAxiom
  a rdf:Property ;
  rdfs:comment "The property that determines the n-tuple of properties that build a sub property chain of a given property." ;
  rdfs:domain owl:ObjectProperty ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "propertyChainAxiom" ;
  rdfs:range rdf:List ;
.
owl:propertyDisjointWith
  a rdf:Property ;
  rdfs:comment "The property that determines that two given properties are disjoint." ;
  rdfs:domain rdf:Property ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "propertyDisjointWith" ;
  rdfs:range rdf:Property ;
.
owl:qualifiedCardinality
  a rdf:Property ;
  rdfs:comment "The property that determines the cardinality of an exact qualified cardinality restriction." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "qualifiedCardinality" ;
  rdfs:range xsd:nonNegativeInteger ;
.
owl:sameAs
  a rdf:Property ;
  a owl:SymmetricProperty ;
  rdfs:comment "The property that determines that two given individuals are equal." ;
  rdfs:domain owl:Thing ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "sameAs" ;
  rdfs:range owl:Thing ;
.
owl:someValuesFrom
  a rdf:Property ;
  rdfs:comment "The property that determines the class that an existential property restriction refers to." ;
  rdfs:domain owl:Restriction ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "someValuesFrom" ;
  rdfs:range rdfs:Class ;
.
owl:sourceIndividual
  a rdf:Property ;
  rdfs:comment "The property that determines the subject of a negative property assertion." ;
  rdfs:domain owl:NegativePropertyAssertion ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "sourceIndividual" ;
  rdfs:range owl:Thing ;
.
owl:targetIndividual
  a rdf:Property ;
  rdfs:comment "The property that determines the object of a negative object property assertion." ;
  rdfs:domain owl:NegativePropertyAssertion ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "targetIndividual" ;
  rdfs:range owl:Thing ;
.
owl:targetValue
  a rdf:Property ;
  rdfs:comment "The property that determines the value of a negative data property assertion." ;
  rdfs:domain owl:NegativePropertyAssertion ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "targetValue" ;
  rdfs:range rdfs:Literal ;
.
owl:topDataProperty
  a owl:DatatypeProperty ;
  rdfs:comment "The data property that relates every individual to every data value." ;
  rdfs:domain owl:Thing ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "topDataProperty" ;
  rdfs:range rdfs:Literal ;
.
owl:topObjectProperty
  a owl:ObjectProperty ;
  rdfs:comment "The object property that relates every two individuals." ;
  rdfs:domain owl:Thing ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "topObjectProperty" ;
  rdfs:range owl:Thing ;
.
owl:unionOf
  a rdf:Property ;
  rdfs:comment "The property that determines the collection of classes or data ranges that build a union." ;
  rdfs:domain rdfs:Class ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "unionOf" ;
  rdfs:range rdf:List ;
.
owl:versionIRI
  a owl:OntologyProperty ;
  rdfs:comment "The property that identifies the version IRI of an ontology." ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "versionIRI" ;
  rdfs:range owl:Ontology ;
.
owl:versionInfo
  a owl:AnnotationProperty ;
  rdfs:comment "The annotation property that provides version information for an ontology or another OWL construct." ;
  rdfs:domain rdfs:Resource ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "versionInfo" ;
.
owl:withRestrictions
  a rdf:Property ;
  rdfs:comment "The property that determines the collection of facet-value pairs that define a datatype restriction." ;
  rdfs:domain rdfs:Datatype ;
  rdfs:isDefinedBy owl: ;
  rdfs:label "withRestrictions" ;
  rdfs:range rdf:List ;
.
<http://www.w3.org/2004/02/skos/core>
  a owl:Ontology ;
  dcterms:contributor "Dave Beckett" ;
  dcterms:contributor "Nikki Rogers" ;
  dcterms:contributor "Participants in W3C's Semantic Web Deployment Working Group." ;
  dcterms:creator "Alistair Miles" ;
  dcterms:creator "Sean Bechhofer" ;
  dcterms:description "An RDF vocabulary for describing the basic structure and content of concept schemes such as thesauri, classification schemes, subject heading lists, taxonomies, 'folksonomies', other types of controlled vocabulary, and also concept schemes embedded in glossaries and terminologies."@en ;
  dcterms:title "SKOS Vocabulary"@en ;
  rdfs:label "SKOS Core RDF vocabulary" ;
  rdfs:seeAlso <http://www.w3.org/TR/skos-reference/> ;
  owl:versionInfo "Modified by TopQuadrant to assert three rdfs:subClassOf owl:Thing triples." ;
.
skos:Collection
  a owl:Class ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "Collection"@en ;
  rdfs:subClassOf owl:Thing ;
  owl:disjointWith skos:Concept ;
  owl:disjointWith skos:ConceptScheme ;
  skos:definition "A meaningful collection of concepts."@en ;
  skos:scopeNote "Labelled collections can be used where you would like a set of concepts to be displayed under a 'node label' in the hierarchy."@en ;
.
skos:Concept
  a owl:Class ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "Concept"@en ;
  rdfs:subClassOf owl:Thing ;
  skos:definition "An idea or notion; a unit of thought."@en ;
.
skos:ConceptScheme
  a owl:Class ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "Concept Scheme"@en ;
  rdfs:subClassOf owl:Thing ;
  owl:disjointWith skos:Concept ;
  skos:definition "A set of concepts, optionally including statements about semantic relationships between those concepts."@en ;
  skos:example "Thesauri, classification schemes, subject heading lists, taxonomies, 'folksonomies', and other types of controlled vocabulary are all examples of concept schemes. Concept schemes are also embedded in glossaries and terminologies."@en ;
  skos:scopeNote "A concept scheme may be defined to include concepts from different sources."@en ;
.
skos:OrderedCollection
  a owl:Class ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "Ordered Collection"@en ;
  rdfs:subClassOf skos:Collection ;
  skos:definition "An ordered collection of concepts, where both the grouping and the ordering are meaningful."@en ;
  skos:scopeNote "Ordered collections can be used where you would like a set of concepts to be displayed in a specific order, and optionally under a 'node label'."@en ;
.
skos:altLabel
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:comment "The range of skos:altLabel is the class of RDF plain literals."@en ;
  rdfs:comment "skos:prefLabel, skos:altLabel and skos:hiddenLabel are pairwise disjoint properties."@en ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "alternative label"@en ;
  rdfs:subPropertyOf rdfs:label ;
  skos:definition "An alternative lexical label for a resource."@en ;
  skos:example "Acronyms, abbreviations, spelling variants, and irregular plural/singular forms may be included among the alternative labels for a concept. Mis-spelled terms are normally included as hidden labels (see skos:hiddenLabel)."@en ;
.
skos:broadMatch
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has broader match"@en ;
  rdfs:subPropertyOf skos:broader ;
  rdfs:subPropertyOf skos:mappingRelation ;
  owl:inverseOf skos:narrowMatch ;
  skos:definition "skos:broadMatch is used to state a hierarchical mapping link between two conceptual resources in different concept schemes."@en ;
.
skos:broader
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:comment "Broader concepts are typically rendered as parents in a concept hierarchy (tree)."@en ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has broader"@en ;
  rdfs:subPropertyOf skos:broaderTransitive ;
  owl:inverseOf skos:narrower ;
  skos:definition "Relates a concept to a concept that is more general in meaning."@en ;
  skos:scopeNote "By convention, skos:broader is only used to assert an immediate (i.e. direct) hierarchical link between two conceptual resources."@en ;
.
skos:broaderTransitive
  a rdf:Property ;
  a owl:ObjectProperty ;
  a owl:TransitiveProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has broader transitive"@en ;
  rdfs:subPropertyOf skos:semanticRelation ;
  owl:inverseOf skos:narrowerTransitive ;
  skos:definition "skos:broaderTransitive is a transitive superproperty of skos:broader." ;
  skos:scopeNote "By convention, skos:broaderTransitive is not used to make assertions. Rather, the properties can be used to draw inferences about the transitive closure of the hierarchical relation, which is useful e.g. when implementing a simple query expansion algorithm in a search application."@en ;
.
skos:changeNote
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "change note"@en ;
  rdfs:subPropertyOf skos:note ;
  skos:definition "A note about a modification to a concept."@en ;
.
skos:closeMatch
  a rdf:Property ;
  a owl:ObjectProperty ;
  a owl:SymmetricProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has close match"@en ;
  rdfs:subPropertyOf skos:mappingRelation ;
  skos:definition "skos:closeMatch is used to link two concepts that are sufficiently similar that they can be used interchangeably in some information retrieval applications. In order to avoid the possibility of \"compound errors\" when combining mappings across more than two concept schemes, skos:closeMatch is not declared to be a transitive property."@en ;
.
skos:definition
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "definition"@en ;
  rdfs:subPropertyOf skos:note ;
  skos:definition "A statement or formal explanation of the meaning of a concept."@en ;
.
skos:editorialNote
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "editorial note"@en ;
  rdfs:subPropertyOf skos:note ;
  skos:definition "A note for an editor, translator or maintainer of the vocabulary."@en ;
.
skos:exactMatch
  a rdf:Property ;
  a owl:ObjectProperty ;
  a owl:SymmetricProperty ;
  a owl:TransitiveProperty ;
  rdfs:comment "skos:exactMatch is disjoint with each of the properties skos:broadMatch and skos:relatedMatch."@en ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has exact match"@en ;
  rdfs:subPropertyOf skos:closeMatch ;
  skos:definition "skos:exactMatch is used to link two concepts, indicating a high degree of confidence that the concepts can be used interchangeably across a wide range of information retrieval applications. skos:exactMatch is a transitive property, and is a sub-property of skos:closeMatch."@en ;
.
skos:example
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "example"@en ;
  rdfs:subPropertyOf skos:note ;
  skos:definition "An example of the use of a concept."@en ;
.
skos:hasTopConcept
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:domain skos:ConceptScheme ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has top concept"@en ;
  rdfs:range skos:Concept ;
  owl:inverseOf skos:topConceptOf ;
  skos:definition "Relates, by convention, a concept scheme to a concept which is topmost in the broader/narrower concept hierarchies for that scheme, providing an entry point to these hierarchies."@en ;
.
skos:hiddenLabel
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:comment "The range of skos:hiddenLabel is the class of RDF plain literals."@en ;
  rdfs:comment "skos:prefLabel, skos:altLabel and skos:hiddenLabel are pairwise disjoint properties."@en ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "hidden label"@en ;
  rdfs:subPropertyOf rdfs:label ;
  skos:definition "A lexical label for a resource that should be hidden when generating visual displays of the resource, but should still be accessible to free text search operations."@en ;
.
skos:historyNote
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "history note"@en ;
  rdfs:subPropertyOf skos:note ;
  skos:definition "A note about the past state/use/meaning of a concept."@en ;
.
skos:inScheme
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "is in scheme"@en ;
  rdfs:range skos:ConceptScheme ;
  skos:definition "Relates a resource (for example a concept) to a concept scheme in which it is included."@en ;
  skos:scopeNote "A concept may be a member of more than one concept scheme."@en ;
.
skos:mappingRelation
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:comment "These concept mapping relations mirror semantic relations, and the data model defined below is similar (with the exception of skos:exactMatch) to the data model defined for semantic relations. A distinct vocabulary is provided for concept mapping relations, to provide a convenient way to differentiate links within a concept scheme from links between concept schemes. However, this pattern of usage is not a formal requirement of the SKOS data model, and relies on informal definitions of best practice."@en ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "is in mapping relation with"@en ;
  rdfs:subPropertyOf skos:semanticRelation ;
  skos:definition "Relates two concepts coming, by convention, from different schemes, and that have comparable meanings"@en ;
.
skos:member
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:domain skos:Collection ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has member"@en ;
  rdfs:range [
      a owl:Class ;
      owl:unionOf (
          skos:Concept
          skos:Collection
        ) ;
    ] ;
  skos:definition "Relates a collection to one of its members."@en ;
.
skos:memberList
  a rdf:Property ;
  a owl:FunctionalProperty ;
  a owl:ObjectProperty ;
  rdfs:comment """For any resource, every item in the list given as the value of the
      skos:memberList property is also a value of the skos:member property."""@en ;
  rdfs:domain skos:OrderedCollection ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has member list"@en ;
  rdfs:range rdf:List ;
  skos:definition "Relates an ordered collection to the RDF list containing its members."@en ;
.
skos:narrowMatch
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has narrower match"@en ;
  rdfs:subPropertyOf skos:mappingRelation ;
  rdfs:subPropertyOf skos:narrower ;
  owl:inverseOf skos:broadMatch ;
  skos:definition "skos:narrowMatch is used to state a hierarchical mapping link between two conceptual resources in different concept schemes."@en ;
.
skos:narrower
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:comment "Narrower concepts are typically rendered as children in a concept hierarchy (tree)."@en ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has narrower"@en ;
  rdfs:subPropertyOf skos:narrowerTransitive ;
  owl:inverseOf skos:broader ;
  skos:definition "Relates a concept to a concept that is more specific in meaning."@en ;
  skos:scopeNote "By convention, skos:broader is only used to assert an immediate (i.e. direct) hierarchical link between two conceptual resources."@en ;
.
skos:narrowerTransitive
  a rdf:Property ;
  a owl:ObjectProperty ;
  a owl:TransitiveProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has narrower transitive"@en ;
  rdfs:subPropertyOf skos:semanticRelation ;
  owl:inverseOf skos:broaderTransitive ;
  skos:definition "skos:narrowerTransitive is a transitive superproperty of skos:narrower." ;
  skos:scopeNote "By convention, skos:narrowerTransitive is not used to make assertions. Rather, the properties can be used to draw inferences about the transitive closure of the hierarchical relation, which is useful e.g. when implementing a simple query expansion algorithm in a search application."@en ;
.
skos:notation
  a rdf:Property ;
  a owl:DatatypeProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "notation"@en ;
  skos:definition "A notation, also known as classification code, is a string of characters such as \"T58.5\" or \"303.4833\" used to uniquely identify a concept within the scope of a given concept scheme."@en ;
  skos:scopeNote "By convention, skos:notation is used with a typed literal in the object position of the triple."@en ;
.
skos:note
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "note"@en ;
  skos:definition "A general note, for any purpose."@en ;
  skos:scopeNote "This property may be used directly, or as a super-property for more specific note types."@en ;
.
skos:prefLabel
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:comment "A resource has no more than one value of skos:prefLabel per language tag."@en ;
  rdfs:comment "The range of skos:prefLabel is the class of RDF plain literals."@en ;
  rdfs:comment """skos:prefLabel, skos:altLabel and skos:hiddenLabel are pairwise
      disjoint properties."""@en ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "preferred label"@en ;
  rdfs:subPropertyOf rdfs:label ;
  skos:definition "The preferred lexical label for a resource, in a given language."@en ;
.
skos:related
  a rdf:Property ;
  a owl:ObjectProperty ;
  a owl:SymmetricProperty ;
  rdfs:comment "skos:related is disjoint with skos:broaderTransitive"@en ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has related"@en ;
  rdfs:subPropertyOf skos:semanticRelation ;
  skos:definition "Relates a concept to a concept with which there is an associative semantic relationship."@en ;
.
skos:relatedMatch
  a rdf:Property ;
  a owl:ObjectProperty ;
  a owl:SymmetricProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "has related match"@en ;
  rdfs:subPropertyOf skos:mappingRelation ;
  rdfs:subPropertyOf skos:related ;
  skos:definition "skos:relatedMatch is used to state an associative mapping link between two conceptual resources in different concept schemes."@en ;
.
skos:scopeNote
  a rdf:Property ;
  a owl:AnnotationProperty ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "scope note"@en ;
  rdfs:subPropertyOf skos:note ;
  skos:definition "A note that helps to clarify the meaning and/or the use of a concept."@en ;
.
skos:semanticRelation
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:domain skos:Concept ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "is in semantic relation with"@en ;
  rdfs:range skos:Concept ;
  skos:definition "Links a concept to a concept related by meaning."@en ;
  skos:scopeNote "This property should not be used directly, but as a super-property for all properties denoting a relationship of meaning between concepts."@en ;
.
skos:topConceptOf
  a rdf:Property ;
  a owl:ObjectProperty ;
  rdfs:domain skos:Concept ;
  rdfs:isDefinedBy <http://www.w3.org/2004/02/skos/core> ;
  rdfs:label "is top concept in scheme"@en ;
  rdfs:range skos:ConceptScheme ;
  rdfs:subPropertyOf skos:inScheme ;
  owl:inverseOf skos:hasTopConcept ;
  skos:definition "Relates a concept to the concept scheme that it is a top level concept of."@en ;
.
fn:abs
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the number to get the absolute value of" ;
    ] ;
  spin:returnType rdfs:Literal ;
  rdfs:comment "Returns the absolute value of the argument." ;
  rdfs:label "abs" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
fn:boolean
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The input value." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Gets the effective boolean value of an input node, for example 1 becomes true." ;
  rdfs:label "boolean" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
fn:ceiling
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the number to get the ceiling of" ;
    ] ;
  spin:returnType xsd:double ;
  rdfs:comment "Returns the smallest integer value less than the argument (as a double)." ;
  rdfs:label "ceiling" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
fn:concat
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the first string" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the second string" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns the concatenation of two (or more) strings." ;
  rdfs:label "concat" ;
  rdfs:subClassOf spl:StringFunctions ;
.
fn:contains
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the (larger) string to search the substring in" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the sub-string to search for" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Checks if a string (?arg1) contains a given sub-string (?arg2)." ;
  rdfs:label "contains" ;
  rdfs:subClassOf spl:StringFunctions ;
.
fn:ends-with
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the (larger) text string to search in" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the sub-string to search for" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Test whether string ends with substr." ;
  rdfs:label "ends-with" ;
  rdfs:subClassOf spl:StringFunctions ;
.
fn:floor
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the number to get the floor of" ;
    ] ;
  spin:returnType xsd:double ;
  rdfs:comment "Returns the greatest integer value less than the argument (as a double)." ;
  rdfs:label "floor" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
fn:lower-case
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the string to convert to lower case" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns a string which is the lower case equivalent of the argument." ;
  rdfs:label "lower-case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
fn:matches
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:string ;
      rdfs:comment "the (optional) arguments for the regular expression matcher" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the string to search in" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the pattern matching string" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Performs string pattern matching based on regular expressions." ;
  rdfs:label "matches" ;
  rdfs:subClassOf spl:StringFunctions ;
.
fn:not
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "The input node." ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Negates a boolean value." ;
  rdfs:label "not" ;
  rdfs:subClassOf spl:BooleanFunctions ;
.
fn:round
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Literal ;
      rdfs:comment "the number to round" ;
    ] ;
  spin:returnType xsd:int ;
  rdfs:comment "Returns the nearest integer value to the argument." ;
  rdfs:label "round" ;
  rdfs:subClassOf spl:MathematicalFunctions ;
.
fn:starts-with
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the (larger) string to search in" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:string ;
      rdfs:comment "the sub-string to search for" ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Test whether a string (?arg1) starts with a sub-string (?arg2)." ;
  rdfs:label "starts-with" ;
  rdfs:subClassOf spl:StringFunctions ;
.
fn:string-length
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the text string to get the length of" ;
    ] ;
  spin:returnType xsd:int ;
  rdfs:comment "Gets the length of a string (number of characters)." ;
  rdfs:label "string-length" ;
  rdfs:subClassOf spl:StringFunctions ;
.
fn:substring
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:optional true ;
      spl:predicate sp:arg3 ;
      spl:valueType xsd:integer ;
      rdfs:comment "the (optional) number of characters to include in the substring" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the text to get a sub-string of" ;
    ] ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType xsd:integer ;
      rdfs:comment "the index of the first character (1 is the first character)" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns the substring of a string, given by a start index (integer) and, optionally, length. Absence of length means to end of string. Strings start from one, not zero as they do in Java and C#. 3rd argument is the length, like C# but unlike Java, where it is the endIndex." ;
  rdfs:label "substring" ;
  rdfs:subClassOf spl:StringFunctions ;
.
fn:upper-case
  a spin:Function ;
  spin:constraint [
      a spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "the text to convert to upper-case" ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Returns a string which is the upper case equivalent of the argument." ;
  rdfs:label "upper-case" ;
  rdfs:subClassOf spl:StringFunctions ;
.
sh:
  a owl:Ontology ;
  tosh:systemNamespace true ;
  rdfs:comment "This vocabulary defines terms used in SHACL, the W3C Shapes Constraint Language."@en ;
  rdfs:label "W3C Shapes Constraint Language (SHACL) Vocabulary"@en ;
  sh:declare [
      sh:namespace "http://www.w3.org/ns/shacl#" ;
      sh:prefix "sh" ;
    ] ;
  sh:suggestedShapesGraph <http://www.w3.org/ns/shacl-shacl#> ;
.
sh:AbstractResult
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "The base class of validation results, typically not instantiated directly."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Abstract result"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:AndConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to test whether a value node conforms to all members of a provided list of shapes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "And constraint component"@en ;
  sh:nodeValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT $this ?failure ($this AS ?value)
		WHERE {
			BIND (tosh:countShapesWithMatchResult($this, $and, $shapesGraph, false) AS ?count)
			BIND (!bound(?count) AS ?failure) .
			FILTER IF(?failure, true, ?count > 0) .
		}
""" ;
    ] ;
  sh:parameter sh:AndConstraintComponent-and ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT DISTINCT $this ?value ?failure
		WHERE {
			$this $PATH ?value .
			BIND (tosh:countShapesWithMatchResult(?value, $and, $shapesGraph, false) AS ?count)
			BIND (!bound(?count) AS ?failure) .
			FILTER IF(?failure, true, ?count > 0) .
		}
""" ;
    ] ;
  sh:targetClass sh:Shape ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateAnd" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:AndConstraintComponent-and
  a sh:Parameter ;
  sh:path sh:and ;
  tosh:editWidget swa:SourceCodeEditor ;
  tosh:viewWidget swa:SourceCodeViewer ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
  sh:order 11 ;
.
sh:BlankNode
  a sh:NodeKind ;
  rdfs:comment "The node kind of all blank nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Blank node"@en ;
.
sh:BlankNodeOrIRI
  a sh:NodeKind ;
  rdfs:comment "The node kind of all blank nodes or IRIs."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Blank node or IRI"@en ;
.
sh:BlankNodeOrLiteral
  a sh:NodeKind ;
  rdfs:comment "The node kind of all blank nodes or literals."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Blank node or literal"@en ;
.
sh:ClassConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  dash:propertySuggestionGenerator tosh:ReplaceWithDefaultValueSuggestionGenerator ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Set type of {$value} to {$class}" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """SELECT ?class
WHERE {
    GRAPH $shapesGraph {
		$sourceShape sh:class ?class .
	}
	FILTER NOT EXISTS {
		?class dash:abstract true .
	}
}""" ;
      sh:update """DELETE {
    $value rdf:type ?oldType .
}
INSERT {
    $value rdf:type $class .
}
WHERE {
    OPTIONAL {
		$value rdf:type ?oldType .
	}
}""" ;
    ] ;
  rdfs:comment "A constraint component that can be used to verify that each value node is an instance of a given type."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Class constraint component"@en ;
  sh:labelTemplate "Value needs to have class {$class}" ;
  sh:parameter sh:ClassConstraintComponent-class ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasClass ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateClass" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:ClassConstraintComponent-class
  a sh:Parameter ;
  sh:path sh:class ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ValueTypeConstraintPropertyGroup ;
  sh:nodeKind sh:IRI ;
  sh:order 2 ;
.
sh:ClosedConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to indicate that focus nodes must only have values for those properties that have been explicitly enumerated via sh:property/sh:path."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Closed constraint component"@en ;
  sh:labelTemplate "Closed shape: only the enumerated properties can be used" ;
  sh:nodeValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Predicate {?path} is not allowed (closed shape)" ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT $this (?predicate AS ?path) ?value
		WHERE {
			{
				FILTER ($closed) .
			}
			$this ?predicate ?value .
			FILTER (NOT EXISTS {
				GRAPH $shapesGraph {
					$currentShape sh:property/sh:path ?predicate .
				}
			} && (!bound($ignoredProperties) || NOT EXISTS {
				GRAPH $shapesGraph {
					$ignoredProperties rdf:rest*/rdf:first ?predicate .
				}
			}))
		}
""" ;
    ] ;
  sh:parameter sh:ClosedConstraintComponent-closed ;
  sh:parameter sh:ClosedConstraintComponent-ignoredProperties ;
  sh:targetClass sh:NodeShape ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateClosed" ;
      sh:jsLibrary dash:DASHJSLibrary ;
      sh:message "Predicate is not allowed (closed shape)" ;
    ] ;
.
sh:ClosedConstraintComponent-closed
  a sh:Parameter ;
  sh:path sh:closed ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:boolean ;
  sh:group tosh:OtherConstraintPropertyGroup ;
  sh:order "0"^^xsd:decimal ;
.
sh:ClosedConstraintComponent-ignoredProperties
  a sh:Parameter ;
  sh:path sh:ignoredProperties ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:OtherConstraintPropertyGroup ;
  sh:optional true ;
  sh:order "1"^^xsd:decimal ;
.
sh:ConstraintComponent
  a rdfs:Class ;
  rdfs:comment "The class of constraint components."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Constraint component"@en ;
  rdfs:subClassOf sh:Parameterizable ;
.
sh:DatatypeConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  dash:propertySuggestionGenerator tosh:ReplaceWithDefaultValueSuggestionGenerator ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Change the datatype of the invalid value to {$datatype}" ;
      sh:order -2 ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:update """DELETE {
    $focusNode $predicate $value .
}
INSERT {
    $focusNode $predicate ?newValue .
}
WHERE {
    BIND (spif:invoke($datatype, str($value)) AS ?newValue) .
	FILTER bound(?newValue) .
}""" ;
    ] ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Convert the invalid date/time value into a date value" ;
      sh:order -1 ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:update """DELETE {
    $subject $predicate $object
}
INSERT {
    $subject $predicate ?newObject .
}
WHERE {
	{
		FILTER (datatype($object) = xsd:dateTime && $datatype = xsd:date) .
	}
    BIND (xsd:date(substr(str($object), 1, 10)) AS ?newObject) .
	FILTER bound(?newObject) .
}""" ;
    ] ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the datatype of all value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Datatype constraint component"@en ;
  sh:labelTemplate "Values must have datatype {$datatype}" ;
  sh:message "Value does not have datatype {$datatype}" ;
  sh:parameter sh:DatatypeConstraintComponent-datatype ;
  sh:targetClass sh:Shape ;
  sh:validator tosh:hasDatatype ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateDatatype" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:DatatypeConstraintComponent-datatype
  a sh:Parameter ;
  sh:path sh:datatype ;
  tosh:editWidget <http://topbraid.org/tosh.ui#DatatypeEditor> ;
  rdfs:isDefinedBy sh: ;
  sh:class rdfs:Datatype ;
  sh:group tosh:ValueTypeConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:nodeKind sh:IRI ;
  sh:order 1 ;
.
sh:DerivedValuesConstraintComponent
  sh:targetClass sh:PropertyShape ;
.
sh:DisjointConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to verify that the set of value nodes is disjoint with the the set of nodes that have the focus node as subject and the value of a given property as predicate."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Disjoint constraint component"@en ;
  sh:parameter sh:DisjointConstraintComponent-disjoint ;
  sh:targetClass sh:Shape ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateDisjoint" ;
      sh:jsLibrary dash:DASHJSLibrary ;
      sh:message "Value node must not also be one of the values of {$disjoint}" ;
    ] ;
  sh:validator [
      a sh:SPARQLAskValidator ;
      sh:ask """
		ASK {
			FILTER NOT EXISTS {
				$this $disjoint $value .
			}
		}
		""" ;
      sh:message "Property must not share any values with {$disjoint}" ;
      sh:prefixes <http://datashapes.org/dash> ;
    ] ;
.
sh:DisjointConstraintComponent-disjoint
  a sh:Parameter ;
  sh:path sh:disjoint ;
  rdfs:isDefinedBy sh: ;
  sh:deactivated true ;
  sh:nodeKind sh:IRI ;
.
sh:EqualsConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to verify that the set of value nodes is equal to the set of nodes that have the focus node as subject and the value of a given property as predicate."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Equals constraint component"@en ;
  sh:message "Must have same values as {$equals}" ;
  sh:nodeValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateEqualsNode" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:nodeValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT DISTINCT $this ?value
		WHERE {
			{
				FILTER NOT EXISTS { $this $equals $this }
				BIND ($this AS ?value) .
			}
			UNION
			{
				$this $equals ?value .
				FILTER (?value != $this) .
			}
		}
		""" ;
    ] ;
  sh:parameter sh:EqualsConstraintComponent-equals ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateEqualsProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT DISTINCT $this ?value
		WHERE {
			{
				$this $PATH ?value .
				MINUS {
					$this $equals ?value .
				}
			}
			UNION
			{
				$this $equals ?value .
				MINUS {
					$this $PATH ?value .
				}
			}
		}
		""" ;
    ] ;
  sh:targetClass sh:Shape ;
.
sh:EqualsConstraintComponent-equals
  a sh:Parameter ;
  sh:path sh:equals ;
  rdfs:isDefinedBy sh: ;
  sh:deactivated true ;
  sh:nodeKind sh:IRI ;
.
sh:ExpressionConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to verify that a given node expression produces true for all value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Expression constraint component"@en ;
  sh:parameter sh:ExpressionConstraintComponent-expression ;
.
sh:ExpressionConstraintComponent-expression
  a sh:Parameter ;
  sh:path sh:expression ;
  rdfs:isDefinedBy sh: ;
.
sh:Function
  a rdfs:Class ;
  rdfs:comment "The class of SHACL functions."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Function"@en ;
  rdfs:subClassOf sh:Parameterizable ;
  sh:property [
      sh:path dash:cachable ;
      sh:datatype xsd:boolean ;
      sh:description "True to indicate that this function will always return the same values for the same combination of arguments, regardless of the query graphs. Engines can use this information to cache and reuse previous function calls." ;
      sh:maxCount 1 ;
      sh:name "cachable" ;
    ] ;
.
sh:HasValueConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Add {$hasValue} to the existing values" ;
      sh:update """INSERT {
	$focusNode $predicate $hasValue .
}
WHERE {
}""" ;
    ] ;
  rdfs:comment "A constraint component that can be used to verify that one of the value nodes is a given RDF node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Has-value constraint component"@en ;
  sh:labelTemplate "Must have value {$hasValue}" ;
  sh:nodeValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateHasValueNode" ;
      sh:jsLibrary dash:DASHJSLibrary ;
      sh:message "Value must be {$hasValue}" ;
    ] ;
  sh:nodeValidator [
      a sh:SPARQLAskValidator ;
      sh:ask """ASK {
    FILTER ($value = $hasValue)
}""" ;
      sh:message "Value must be {$hasValue}" ;
      sh:prefixes <http://datashapes.org/dash> ;
    ] ;
  sh:parameter sh:HasValueConstraintComponent-hasValue ;
  sh:property [
      sh:path sh:hasValue ;
      tosh:editWidget <http://topbraid.org/tosh.ui#UseDeclaredDatatypeEditor> ;
      tosh:useDeclaredDatatype true ;
    ] ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateHasValueProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
      sh:message "Missing expected value {$hasValue}" ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Missing expected value {$hasValue}" ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT $this
		WHERE {
			FILTER NOT EXISTS { $this $PATH $hasValue }
		}
		""" ;
    ] ;
  sh:targetClass sh:Shape ;
.
sh:HasValueConstraintComponent-hasValue
  a sh:Parameter ;
  sh:path sh:hasValue ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:OtherConstraintPropertyGroup ;
.
sh:IRI
  a sh:NodeKind ;
  rdfs:comment "The node kind of all IRIs."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "IRI"@en ;
.
sh:IRIOrLiteral
  a sh:NodeKind ;
  rdfs:comment "The node kind of all IRIs or literals."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "IRI or literal"@en ;
.
sh:InConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  dash:propertySuggestionGenerator tosh:ReplaceWithDefaultValueSuggestionGenerator ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Replace invalid value with {$newObject}" ;
      sh:order 2 ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """SELECT ?newObject
WHERE {
	$in <http://jena.hpl.hp.com/ARQ/list#index> (?index ?newObject ) .
}
ORDER BY ?index""" ;
      sh:update """DELETE {
	$focusNode $predicate $value .
}
INSERT {
	$focusNode $predicate $newObject .
}
WHERE {
}""" ;
    ] ;
  rdfs:comment "A constraint component that can be used to exclusively enumerate the permitted value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "In constraint component"@en ;
  sh:labelTemplate "Value must be in {$in}" ;
  sh:message "Value is not in {$in}" ;
  sh:parameter sh:InConstraintComponent-in ;
  sh:targetClass sh:Shape ;
  sh:validator dash:isIn ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateIn" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:InConstraintComponent-in
  a sh:Parameter ;
  sh:path sh:in ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:OtherConstraintPropertyGroup ;
  sh:maxCount 1 ;
.
sh:Info
  a sh:Severity ;
  rdfs:comment "The severity for an informational validation result."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Info"@en ;
.
sh:JSConstraint
  a rdfs:Class ;
  rdfs:comment "The class of constraints backed by a JavaScript function."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript-based constraint"@en ;
  rdfs:subClassOf sh:JSExecutable ;
.
sh:JSConstraint-js
  a sh:Parameter ;
  sh:path sh:js ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
.
sh:JSConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component with the parameter sh:js linking to a sh:JSConstraint containing a sh:script."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript constraint component"@en ;
  sh:parameter sh:JSConstraint-js ;
.
sh:JSExecutable
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "Abstract base class of resources that declare an executable JavaScript."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript executable"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:JSFunction
  a rdfs:Class ;
  rdfs:comment "The class of SHACL functions that execute a JavaScript function when called."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript function"@en ;
  rdfs:subClassOf sh:Function ;
  rdfs:subClassOf sh:JSExecutable ;
.
sh:JSLibrary
  a rdfs:Class ;
  rdfs:comment "Represents a JavaScript library, typically identified by one or more URLs of files to include."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript library"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:JSRule
  a rdfs:Class ;
  rdfs:comment "The class of SHACL rules expressed using JavaScript."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript rule"@en ;
  rdfs:subClassOf sh:JSExecutable ;
  rdfs:subClassOf sh:Rule ;
.
sh:JSTarget
  a rdfs:Class ;
  rdfs:comment "The class of targets that are based on JavaScript functions."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript target"@en ;
  rdfs:subClassOf sh:JSExecutable ;
  rdfs:subClassOf sh:Target ;
.
sh:JSTargetType
  a rdfs:Class ;
  rdfs:comment "The (meta) class for parameterizable targets that are based on JavaScript functions."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript target type"@en ;
  rdfs:subClassOf sh:JSExecutable ;
  rdfs:subClassOf sh:TargetType ;
.
sh:JSValidator
  a rdfs:Class ;
  rdfs:comment "A SHACL validator based on JavaScript. This can be used to declare SHACL constraint components that perform JavaScript-based validation when used."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript validator"@en ;
  rdfs:subClassOf sh:JSExecutable ;
  rdfs:subClassOf sh:Validator ;
.
sh:LanguageInConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  rdfs:comment "A constraint component that can be used to enumerate language tags that all value nodes must have."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Language-in constraint component"@en ;
  sh:labelTemplate "Language must match any of {$languageIn}" ;
  sh:message "Language does not match any of {$languageIn}" ;
  sh:parameter sh:LanguageInConstraintComponent-languageIn ;
  sh:targetClass sh:Shape ;
  sh:validator dash:isLanguageIn ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateLanguageIn" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:LanguageInConstraintComponent-languageIn
  a sh:Parameter ;
  sh:path sh:languageIn ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:StringBasedConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order "9"^^xsd:decimal ;
  sh:property [
      sh:path (
          [
            sh:zeroOrMorePath rdf:rest ;
          ]
          rdf:first
        ) ;
      sh:datatype xsd:string ;
      sh:minLength 1 ;
    ] ;
.
sh:LessThanConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to verify that each value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Less-than constraint component"@en ;
  sh:message "Value is not < value of {$lessThan}" ;
  sh:parameter sh:LessThanConstraintComponent-lessThan ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateLessThanProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT $this ?value
		WHERE {
			$this $PATH ?value .
			$this $lessThan ?otherValue .
			BIND (?value < ?otherValue AS ?result) .
			FILTER (!bound(?result) || !(?result)) .
		}
		""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
sh:LessThanConstraintComponent-lessThan
  a sh:Parameter ;
  sh:path sh:lessThan ;
  rdfs:isDefinedBy sh: ;
  sh:deactivated true ;
  sh:nodeKind sh:IRI ;
.
sh:LessThanOrEqualsConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to verify that every value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "less-than-or-equals constraint component"@en ;
  sh:message "Value is not <= value of {$lessThanOrEquals}" ;
  sh:parameter sh:LessThanOrEqualsConstraintComponent-lessThanOrEquals ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateLessThanOrEqualsProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT DISTINCT $this ?value
		WHERE {
			$this $PATH ?value .
			$this $lessThanOrEquals ?otherValue .
			BIND (?value <= ?otherValue AS ?result) .
			FILTER (!bound(?result) || !(?result)) .
		}
""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
sh:LessThanOrEqualsConstraintComponent-lessThanOrEquals
  a sh:Parameter ;
  sh:path sh:lessThanOrEquals ;
  rdfs:isDefinedBy sh: ;
  sh:deactivated true ;
  sh:nodeKind sh:IRI ;
.
sh:Literal
  a sh:NodeKind ;
  rdfs:comment "The node kind of all literals."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Literal"@en ;
.
sh:MaxCountConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the maximum number of value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Max-count constraint component"@en ;
  sh:labelTemplate "Must not have more than {$maxCount} values" ;
  sh:message "More than {$maxCount} values" ;
  sh:parameter sh:MaxCountConstraintComponent-maxCount ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateMaxCountProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT $this
		WHERE {
			$this $PATH ?value .
		}
		GROUP BY $this
		HAVING (COUNT(DISTINCT ?value) > $maxCount)
		""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
sh:MaxCountConstraintComponent-maxCount
  a sh:Parameter ;
  sh:path sh:maxCount ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:integer ;
  sh:group tosh:CardinalityConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order 1 ;
.
sh:MaxExclusiveConstraintComponent
  a sh:ConstraintComponent ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the range of value nodes with a maximum exclusive value."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Max-exclusive constraint component"@en ;
  sh:labelTemplate "Value must be < {$maxExclusive}" ;
  sh:message "Value is not < {$maxExclusive}" ;
  sh:parameter sh:MaxExclusiveConstraintComponent-maxExclusive ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasMaxExclusive ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateMaxExclusive" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:MaxExclusiveConstraintComponent-maxExclusive
  a sh:Parameter ;
  sh:path sh:maxExclusive ;
  tosh:editWidget <http://topbraid.org/tosh.ui#UseDeclaredDatatypeEditor> ;
  tosh:useDeclaredDatatype true ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ValueRangeConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:nodeKind sh:Literal ;
  sh:order 3 ;
.
sh:MaxInclusiveConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Replace the invalid value with {$maxInclusive}" ;
      sh:update """DELETE {
	$subject $predicate $object .
}
INSERT {
	$subject $predicate $maxInclusive .
}
WHERE {
}""" ;
    ] ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the range of value nodes with a maximum inclusive value."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Max-inclusive constraint component"@en ;
  sh:labelTemplate "Value must be <= {$maxInclusive}" ;
  sh:message "Value is not <= {$maxInclusive}" ;
  sh:parameter sh:MaxInclusiveConstraintComponent-maxInclusive ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasMaxInclusive ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateMaxInclusive" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:MaxInclusiveConstraintComponent-maxInclusive
  a sh:Parameter ;
  sh:path sh:maxInclusive ;
  tosh:editWidget <http://topbraid.org/tosh.ui#UseDeclaredDatatypeEditor> ;
  tosh:useDeclaredDatatype true ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ValueRangeConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:nodeKind sh:Literal ;
  sh:order 2 ;
.
sh:MaxLengthConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  dash:propertySuggestionGenerator tosh:ReplaceWithDefaultValueSuggestionGenerator ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Prune string to only {$maxLength} characters" ;
      sh:order 1 ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:update """DELETE {
    $focusNode $predicate $value .
}
INSERT {
    $focusNode $predicate $newValue .
}
WHERE {
    FILTER (isLiteral($value) && datatype($value) = xsd:string) .
	BIND (SUBSTR($value, 1, $maxLength) AS ?newValue) .
}""" ;
    ] ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the maximum string length of value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Max-length constraint component"@en ;
  sh:labelTemplate "Value must not have more than {$maxLength} characters" ;
  sh:message "Value has more than {$maxLength} characters" ;
  sh:parameter sh:MaxLengthConstraintComponent-maxLength ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasMaxLength ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateMaxLength" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:MaxLengthConstraintComponent-maxLength
  a sh:Parameter ;
  sh:path sh:maxLength ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:integer ;
  sh:group tosh:StringBasedConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order 4 ;
.
sh:MinCountConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the minimum number of value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Min-count constraint component"@en ;
  sh:labelTemplate "Must have at least {$minCount} values" ;
  sh:message "Fewer than {$minCount} values" ;
  sh:parameter sh:MinCountConstraintComponent-minCount ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateMinCountProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT $this
		WHERE {
			OPTIONAL {
				$this $PATH ?value .
			}
		}
		GROUP BY $this
		HAVING (COUNT(DISTINCT ?value) < $minCount)
		""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
sh:MinCountConstraintComponent-minCount
  a sh:Parameter ;
  sh:path sh:minCount ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:integer ;
  sh:group tosh:CardinalityConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order 0 ;
.
sh:MinExclusiveConstraintComponent
  a sh:ConstraintComponent ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the range of value nodes with a minimum exclusive value."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Min-exclusive constraint component"@en ;
  sh:labelTemplate "Value must be > {$minExclusive}" ;
  sh:message "Value is not > {$minExclusive}" ;
  sh:parameter sh:MinExclusiveConstraintComponent-minExclusive ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasMinExclusive ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateMinExclusive" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:MinExclusiveConstraintComponent-minExclusive
  a sh:Parameter ;
  sh:path sh:minExclusive ;
  tosh:editWidget <http://topbraid.org/tosh.ui#UseDeclaredDatatypeEditor> ;
  tosh:useDeclaredDatatype true ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ValueRangeConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:nodeKind sh:Literal ;
  sh:order 0 ;
.
sh:MinInclusiveConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator [
      a dash:SPARQLUpdateSuggestionGenerator ;
      sh:message "Replace the invalid value with {$minInclusive}" ;
      sh:update """DELETE {
	$subject $predicate $object .
}
INSERT {
	$subject $predicate $minInclusive .
}
WHERE {
}""" ;
    ] ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the range of value nodes with a minimum inclusive value."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Min-inclusive constraint component"@en ;
  sh:labelTemplate "Value must be >= {$minInclusive}" ;
  sh:message "Value is not >= {$minInclusive}" ;
  sh:parameter sh:MinInclusiveConstraintComponent-minInclusive ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasMinInclusive ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateMinInclusive" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:MinInclusiveConstraintComponent-minInclusive
  a sh:Parameter ;
  sh:path sh:minInclusive ;
  tosh:editWidget <http://topbraid.org/tosh.ui#UseDeclaredDatatypeEditor> ;
  tosh:useDeclaredDatatype true ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ValueRangeConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:nodeKind sh:Literal ;
  sh:order 1 ;
.
sh:MinLengthConstraintComponent
  a sh:ConstraintComponent ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the minimum string length of value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Min-length constraint component"@en ;
  sh:labelTemplate "Value must have less than {$minLength} characters" ;
  sh:message "Value has less than {$minLength} characters" ;
  sh:parameter sh:MinLengthConstraintComponent-minLength ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasMinLength ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateMinLength" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:MinLengthConstraintComponent-minLength
  a sh:Parameter ;
  sh:path sh:minLength ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:integer ;
  sh:group tosh:StringBasedConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order 3 ;
.
sh:NodeConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to verify that all value nodes conform to the given node shape."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Node constraint component"@en ;
  sh:message "Value does not have shape {$node}" ;
  sh:nodeValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT $this ($this AS $value) ?failure
		WHERE {
			BIND (tosh:hasShape($this, $node) AS ?hasShape) .
			BIND (!bound(?hasShape) AS ?failure) .
			FILTER (?failure || !?hasShape) .
		}
		""" ;
    ] ;
  sh:parameter sh:NodeConstraintComponent-node ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT DISTINCT $this ?value ?failure
		WHERE {
			$this $PATH ?value .
			BIND (tosh:hasShape(?value, $node) AS ?hasShape) .
			BIND (!bound(?hasShape) AS ?failure) .
			FILTER (?failure || !?hasShape) .
		}
		""" ;
    ] ;
  sh:targetClass sh:Shape ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateNode" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:NodeConstraintComponent-node
  a sh:Parameter ;
  sh:path sh:node ;
  tosh:editWidget swa:SourceCodeEditor ;
  tosh:viewWidget swa:SourceCodeViewer ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
  sh:order 0 ;
.
sh:NodeKind
  a rdfs:Class ;
  rdfs:comment "The class of all node kinds, including sh:BlankNode, sh:IRI, sh:Literal or the combinations of these: sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral, sh:IRIOrLiteral."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Node kind"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:NodeKindConstraintComponent
  a sh:ConstraintComponent ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to restrict the RDF node kind of each value node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Node-kind constraint component"@en ;
  sh:labelTemplate "Value must have node kind {$nodeKind}" ;
  sh:message "Value does not have node kind {$nodeKind}" ;
  sh:parameter sh:NodeKindConstraintComponent-nodeKind ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasNodeKind ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateNodeKind" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:NodeKindConstraintComponent-nodeKind
  a sh:Parameter ;
  sh:path sh:nodeKind ;
  tosh:editWidget <http://topbraid.org/tosh.ui#NodeKindEditor> ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ValueTypeConstraintPropertyGroup ;
  sh:in (
      sh:BlankNode
      sh:IRI
      sh:Literal
      sh:BlankNodeOrIRI
      sh:BlankNodeOrLiteral
      sh:IRIOrLiteral
    ) ;
  sh:maxCount 1 ;
  sh:name "value kinds" ;
  sh:order 0 ;
.
sh:NodeShape
  a rdfs:Class ;
  rdfs:comment "A node shape is a shape that specifies constraint that need to be met with respect to focus nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Node shape"@en ;
  rdfs:subClassOf sh:Shape ;
.
sh:NotConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to verify that value nodes do not conform to a given shape."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Not constraint component"@en ;
  sh:labelTemplate "Value must not have shape {$not}" ;
  sh:message "Value does have shape {$not}" ;
  sh:nodeValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT $this ($this AS ?value) ?failure
		WHERE {
			BIND (tosh:hasShape($this, $not) AS ?hasShape) .
			BIND (!bound(?hasShape) AS ?failure) .
			FILTER (?failure || ?hasShape) .
		}
		""" ;
    ] ;
  sh:parameter sh:NotConstraintComponent-not ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT DISTINCT $this ?value ?failure
		WHERE {
			$this $PATH ?value .
			BIND (tosh:hasShape(?value, $not) AS ?hasShape) .
			BIND (!bound(?hasShape) AS ?failure) .
			FILTER (?failure || ?hasShape) .
		}
		""" ;
    ] ;
  sh:targetClass sh:Shape ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateNot" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:NotConstraintComponent-not
  a sh:Parameter ;
  sh:path sh:not ;
  tosh:editWidget swa:SourceCodeEditor ;
  tosh:viewWidget swa:SourceCodeViewer ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
  sh:order 10 ;
.
sh:OrConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to restrict the value nodes so that they conform to at least one out of several provided shapes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Or constraint component"@en ;
  sh:nodeValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Focus node has none of the shapes from the 'or' list" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT $this ?failure ($this AS ?value)
		WHERE {
			BIND (tosh:countShapesWithMatchResult($this, $or, $shapesGraph, true) AS ?count)
			BIND (!bound(?count) AS ?failure) .
			FILTER IF(?failure, true, ?count = 0) .
		}
""" ;
    ] ;
  sh:parameter sh:OrConstraintComponent-or ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Value has none of the shapes from the 'or' list" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT DISTINCT $this ?value ?failure
		WHERE { 
			$this $PATH ?value .
			BIND (tosh:countShapesWithMatchResult(?value, $or, $shapesGraph, true) AS ?count)
			BIND (!bound(?count) AS ?failure) .
			FILTER IF(?failure, true, ?count = 0) .
		}
""" ;
    ] ;
  sh:targetClass sh:Shape ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateOr" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:OrConstraintComponent-or
  a sh:Parameter ;
  sh:path sh:or ;
  tosh:editWidget swa:SourceCodeEditor ;
  tosh:viewWidget swa:SourceCodeViewer ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
  sh:order 12 ;
.
sh:Parameter
  a rdfs:Class ;
  rdfs:comment "The class of parameter declarations, consisting of a path predicate and (possibly) information about allowed value type, cardinality and other characteristics."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Parameter"@en ;
  rdfs:subClassOf sh:PropertyShape ;
.
sh:Parameterizable
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "Superclass of components that can take parameters, especially functions and constraint components."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Parameterizable"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:PatternConstraintComponent
  a sh:ConstraintComponent ;
  dash:propertySuggestionGenerator tosh:DeleteTripleSuggestionGenerator ;
  dash:propertySuggestionGenerator tosh:ReplaceWithDefaultValueSuggestionGenerator ;
  dash:staticConstraint true ;
  rdfs:comment "A constraint component that can be used to verify that every value node matches a given regular expression."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Pattern constraint component"@en ;
  sh:labelTemplate "Value must match pattern \"{$pattern}\"" ;
  sh:message "Value does not match pattern \"{$pattern}\"" ;
  sh:parameter sh:PatternConstraintComponent-flags ;
  sh:parameter sh:PatternConstraintComponent-pattern ;
  sh:targetClass sh:Shape ;
  sh:validator dash:hasPattern ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validatePattern" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:PatternConstraintComponent-flags
  a sh:Parameter ;
  sh:path sh:flags ;
  tosh:editWidget <http://topbraid.org/tosh.ui#FlagsEditor> ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:string ;
  sh:group tosh:StringBasedConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:name "regex flags" ;
  sh:optional true ;
.
sh:PatternConstraintComponent-pattern
  a sh:Parameter ;
  sh:path sh:pattern ;
  tosh:editWidget swa:PlainTextFieldEditor ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:string ;
  sh:group tosh:StringBasedConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:name "regex pattern" ;
  sh:sparql [
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """SELECT $this ?value ?message
WHERE {
    $this $PATH ?value .
	BIND (spif:checkRegexSyntax(?value) AS ?error) .
	FILTER bound(?error) .
	BIND (CONCAT(\"Malformed pattern: \", ?error) AS ?message) .
}""" ;
    ] ;
.
sh:PrefixDeclaration
  a rdfs:Class ;
  rdfs:comment "The class of prefix declarations, consisting of pairs of a prefix with a namespace."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Prefix declaration"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:PropertyConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to verify that all value nodes conform to the given property shape."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Property constraint component"@en ;
  sh:parameter sh:PropertyConstraintComponent-property ;
.
sh:PropertyConstraintComponent-property
  a sh:Parameter ;
  sh:path sh:property ;
  rdfs:isDefinedBy sh: ;
.
sh:PropertyGroup
  a rdfs:Class ;
  rdfs:comment "Instances of this class represent groups of property shapes that belong together."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Property group"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:PropertyShape
  a rdfs:Class ;
  rdfs:comment "A property shape is a shape that specifies constraints on the values of a focus node for a given property or path."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Property shape"@en ;
  rdfs:subClassOf sh:Shape ;
.
sh:QualifiedMaxCountConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to verify that a specified maximum number of value nodes conforms to a given shape."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Qualified-max-count constraint component"@en ;
  sh:labelTemplate "No more than {$qualifiedMaxCount} values can have shape {$qualifiedValueShape}" ;
  sh:message "More than {$qualifiedMaxCount} values have shape {$qualifiedValueShape}" ;
  sh:parameter sh:QualifiedMaxCountConstraintComponent-qualifiedMaxCount ;
  sh:parameter sh:QualifiedMaxCountConstraintComponent-qualifiedValueShape ;
  sh:parameter sh:QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateQualifiedMaxCountProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
sh:QualifiedMaxCountConstraintComponent-qualifiedMaxCount
  a sh:Parameter ;
  sh:path sh:qualifiedMaxCount ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:integer ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order 3 ;
.
sh:QualifiedMaxCountConstraintComponent-qualifiedValueShape
  a sh:Parameter ;
  sh:path sh:qualifiedValueShape ;
  rdfs:isDefinedBy sh: ;
.
sh:QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint
  a sh:Parameter ;
  sh:path sh:qualifiedValueShapesDisjoint ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:boolean ;
  sh:optional true ;
.
sh:QualifiedMinCountConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to verify that a specified minimum number of value nodes conforms to a given shape."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Qualified-min-count constraint component"@en ;
  sh:labelTemplate "No fewer than {$qualifiedMinCount} values can have shape {$qualifiedValueShape}" ;
  sh:message "Fewer than {$qualifiedMinCount} values have shape {$qualifiedValueShape}" ;
  sh:parameter sh:QualifiedMinCountConstraintComponent-qualifiedMinCount ;
  sh:parameter sh:QualifiedMinCountConstraintComponent-qualifiedValueShape ;
  sh:parameter sh:QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateQualifiedMinCountProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
sh:QualifiedMinCountConstraintComponent-qualifiedMinCount
  a sh:Parameter ;
  sh:path sh:qualifiedMinCount ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:integer ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order 2 ;
.
sh:QualifiedMinCountConstraintComponent-qualifiedValueShape
  a sh:Parameter ;
  sh:path sh:qualifiedValueShape ;
  tosh:editWidget swa:SourceCodeEditor ;
  tosh:viewWidget swa:SourceCodeViewer ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order 1 ;
.
sh:QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint
  a sh:Parameter ;
  sh:path sh:qualifiedValueShapesDisjoint ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:boolean ;
  sh:optional true ;
.
sh:ResultAnnotation
  a rdfs:Class ;
  rdfs:comment "A class of result annotations, which define the rules to derive the values of a given annotation property as extra values for a validation result."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Result annotation"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:Rule
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "The class of SHACL rules. Never instantiated directly."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Rule"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:Rules
  a rdfs:Resource ;
  rdfs:comment "The SHACL rules entailment regime." ;
  rdfs:label "SHACL Rules" ;
  rdfs:seeAlso <https://www.w3.org/TR/shacl-af/#Rules> ;
.
sh:SPARQLAskExecutable
  a rdfs:Class ;
  rdfs:comment "The class of SPARQL executables that are based on an ASK query."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL ASK executable"@en ;
  rdfs:subClassOf sh:SPARQLExecutable ;
.
sh:SPARQLAskValidator
  a rdfs:Class ;
  rdfs:comment "The class of validators based on SPARQL ASK queries. The queries are evaluated for each value node and are supposed to return true if the given node conforms."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL ASK validator"@en ;
  rdfs:subClassOf sh:SPARQLAskExecutable ;
  rdfs:subClassOf sh:Validator ;
.
sh:SPARQLConstraint
  a rdfs:Class ;
  rdfs:comment "The class of constraints based on SPARQL SELECT queries."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL constraint"@en ;
  rdfs:subClassOf sh:SPARQLSelectExecutable ;
.
sh:SPARQLConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to define constraints based on SPARQL queries."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL constraint component"@en ;
  sh:parameter sh:SPARQLConstraintComponent-sparql ;
.
sh:SPARQLConstraintComponent-sparql
  a sh:Parameter ;
  sh:path sh:sparql ;
  rdfs:isDefinedBy sh: ;
.
sh:SPARQLConstructExecutable
  a rdfs:Class ;
  rdfs:comment "The class of SPARQL executables that are based on a CONSTRUCT query."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL CONSTRUCT executable"@en ;
  rdfs:subClassOf sh:SPARQLExecutable ;
.
sh:SPARQLExecutable
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "The class of resources that encapsulate a SPARQL query."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL executable"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:SPARQLFunction
  a rdfs:Class ;
  rdfs:comment "A function backed by a SPARQL query - either ASK or SELECT."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL function"@en ;
  rdfs:subClassOf sh:Function ;
  rdfs:subClassOf sh:SPARQLAskExecutable ;
  rdfs:subClassOf sh:SPARQLSelectExecutable ;
.
sh:SPARQLRule
  a rdfs:Class ;
  rdfs:comment "The class of SHACL rules based on SPARQL CONSTRUCT queries."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL CONSTRUCT rule"@en ;
  rdfs:subClassOf sh:Rule ;
  rdfs:subClassOf sh:SPARQLConstructExecutable ;
.
sh:SPARQLSelectExecutable
  a rdfs:Class ;
  rdfs:comment "The class of SPARQL executables based on a SELECT query."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL SELECT executable"@en ;
  rdfs:subClassOf sh:SPARQLExecutable ;
.
sh:SPARQLSelectValidator
  a rdfs:Class ;
  rdfs:comment "The class of validators based on SPARQL SELECT queries. The queries are evaluated for each focus node and are supposed to produce bindings for all focus nodes that do not conform."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL SELECT validator"@en ;
  rdfs:subClassOf sh:SPARQLSelectExecutable ;
  rdfs:subClassOf sh:Validator ;
.
sh:SPARQLTarget
  a rdfs:Class ;
  rdfs:comment "The class of targets that are based on SPARQL queries."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL target"@en ;
  rdfs:subClassOf sh:SPARQLAskExecutable ;
  rdfs:subClassOf sh:SPARQLSelectExecutable ;
  rdfs:subClassOf sh:Target ;
.
sh:SPARQLTargetType
  a rdfs:Class ;
  rdfs:comment "The (meta) class for parameterizable targets that are based on SPARQL queries."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL target type"@en ;
  rdfs:subClassOf sh:SPARQLAskExecutable ;
  rdfs:subClassOf sh:SPARQLSelectExecutable ;
  rdfs:subClassOf sh:TargetType ;
.
sh:SPARQLUpdateExecutable
  a rdfs:Class ;
  rdfs:comment "The class of SPARQL executables based on a SPARQL UPDATE."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "SPARQL UPDATE executable"@en ;
  rdfs:subClassOf sh:SPARQLExecutable ;
.
sh:Severity
  a rdfs:Class ;
  rdfs:comment "The class of validation result severity levels, including violation and warning levels."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Severity"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:Shape
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "A shape is a collection of constraints that may be targeted for certain nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Shape"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:Target
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "The base class of targets such as those based on SPARQL queries."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Target"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:TargetType
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "The (meta) class for parameterizable targets.	Instances of this are instantiated as values of the sh:target property."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Target type"@en ;
  rdfs:subClassOf rdfs:Class ;
  rdfs:subClassOf sh:Parameterizable ;
.
sh:TripleRule
  a rdfs:Class ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "A rule based on triple (subject, predicate, object) pattern."@en ;
  rdfs:subClassOf sh:Rule ;
.
sh:UniqueLangConstraintComponent
  a sh:ConstraintComponent ;
  dash:localConstraint true ;
  rdfs:comment "A constraint component that can be used to specify that no pair of value nodes may use the same language tag."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Unique-languages constraint component"@en ;
  sh:labelTemplate "No language can be used more than once" ;
  sh:message "Language \"{?lang}\" used more than once" ;
  sh:parameter sh:UniqueLangConstraintComponent-uniqueLang ;
  sh:propertyValidator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateUniqueLangProperty" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:prefixes <http://datashapes.org/dash> ;
      sh:select """
		SELECT DISTINCT $this ?lang
		WHERE {
			{
				FILTER sameTerm($uniqueLang, true) .
			}
			$this $PATH ?value .
			BIND (lang(?value) AS ?lang) .
			FILTER (bound(?lang) && ?lang != \"\") .
			FILTER EXISTS {
				$this $PATH ?otherValue .
				FILTER (?otherValue != ?value && ?lang = lang(?otherValue)) .
			}
		}
		""" ;
    ] ;
  sh:targetClass sh:PropertyShape ;
.
sh:UniqueLangConstraintComponent-uniqueLang
  a sh:Parameter ;
  sh:path sh:uniqueLang ;
  rdfs:isDefinedBy sh: ;
  sh:datatype xsd:boolean ;
  sh:group tosh:StringBasedConstraintPropertyGroup ;
  sh:maxCount 1 ;
  sh:order 8 ;
.
sh:ValidationReport
  a rdfs:Class ;
  rdfs:comment "The class of SHACL validation reports."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Validation report"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:ValidationResult
  a rdfs:Class ;
  rdfs:comment "The class of validation results."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Validation result"@en ;
  rdfs:subClassOf sh:AbstractResult ;
.
sh:Validator
  a rdfs:Class ;
  dash:abstract true ;
  rdfs:comment "The class of validators, which provide instructions on how to process a constraint definition. This class serves as base class for the SPARQL-based validators and other possible implementations."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Validator"@en ;
  rdfs:subClassOf rdfs:Resource ;
.
sh:Violation
  a sh:Severity ;
  rdfs:comment "The severity for a violation validation result."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Violation"@en ;
.
sh:Warning
  a sh:Severity ;
  rdfs:comment "The severity for a warning validation result."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Warning"@en ;
.
sh:XoneConstraintComponent
  a sh:ConstraintComponent ;
  rdfs:comment "A constraint component that can be used to restrict the value nodes so that they conform to exactly one out of several provided shapes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "Exactly one constraint component"@en ;
  sh:nodeValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Focus node has {?count} of the shapes from the 'exactly one' list" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT $this ?failure ?count ($this AS ?value)
		WHERE {
			BIND (tosh:countShapesWithMatchResult($this, $xone, $shapesGraph, true) AS ?count)
			BIND (!bound(?count) AS ?failure) .
			FILTER IF(?failure, true, ?count != 1) .
		}
""" ;
    ] ;
  sh:parameter sh:XoneConstraintComponent-xone ;
  sh:propertyValidator [
      a sh:SPARQLSelectValidator ;
      sh:message "Value node has {?count} of the shapes from the 'exactly one' list" ;
      sh:prefixes <http://topbraid.org/tosh> ;
      sh:select """
		SELECT DISTINCT $this ?value ?failure ?count
		WHERE { 
			$this $PATH ?value .
			BIND (tosh:countShapesWithMatchResult(?value, $xone, $shapesGraph, true) AS ?count)
			BIND (!bound(?count) AS ?failure) .
			FILTER IF(?failure, true, ?count != 1) .
		}
""" ;
    ] ;
  sh:targetClass sh:Shape ;
  sh:validator [
      a sh:JSValidator ;
      sh:jsFunctionName "validateXone" ;
      sh:jsLibrary dash:DASHJSLibrary ;
    ] ;
.
sh:XoneConstraintComponent-xone
  a sh:Parameter ;
  sh:path sh:xone ;
  tosh:editWidget swa:SourceCodeEditor ;
  tosh:viewWidget swa:SourceCodeViewer ;
  rdfs:isDefinedBy sh: ;
  sh:group tosh:ComplexConstraintPropertyGroup ;
  sh:order 13 ;
.
sh:alternativePath
  a rdf:Property ;
  rdfs:comment "The (single) value of this property must be a list of path elements, representing the elements of alternative paths."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "alternative path"@en ;
  rdfs:range rdf:List ;
.
sh:and
  a rdf:Property ;
  rdfs:comment "RDF list of shapes to validate the value nodes against."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "and"@en ;
  rdfs:range rdf:List ;
.
sh:annotationProperty
  a rdf:Property ;
  rdfs:comment "The annotation property that shall be set."@en ;
  rdfs:domain sh:ResultAnnotation ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "annotation property"@en ;
  rdfs:range rdf:Property ;
.
sh:annotationValue
  a rdf:Property ;
  rdfs:comment "The (default) values of the annotation property."@en ;
  rdfs:domain sh:ResultAnnotation ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "annotation value"@en ;
.
sh:annotationVarName
  a rdf:Property ;
  rdfs:comment "The name of the SPARQL variable from the SELECT clause that shall be used for the values."@en ;
  rdfs:domain sh:ResultAnnotation ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "annotation variable name"@en ;
  rdfs:range xsd:string ;
.
sh:ask
  a rdf:Property ;
  rdfs:comment "The SPARQL ASK query to execute."@en ;
  rdfs:domain sh:SPARQLAskExecutable ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "ask"@en ;
  rdfs:range xsd:string ;
.
sh:class
  a rdf:Property ;
  rdfs:comment "The type that all value nodes must have."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "class"@en ;
  rdfs:range rdfs:Class ;
.
sh:closed
  a rdf:Property ;
  rdfs:comment "If set to true then the shape is closed."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "closed"@en ;
  rdfs:range xsd:boolean ;
.
sh:condition
  a rdf:Property ;
  rdfs:comment "The shapes that the focus nodes need to conform to before a rule is executed on them."@en ;
  rdfs:domain sh:Rule ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "condition"@en ;
  rdfs:range sh:Shape ;
.
sh:conforms
  a rdf:Property ;
  rdfs:comment "True if the validation did not produce any validation results, and false otherwise."@en ;
  rdfs:domain sh:ValidationReport ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "conforms"@en ;
  rdfs:range xsd:boolean ;
.
sh:construct
  a rdf:Property ;
  rdfs:comment "The SPARQL CONSTRUCT query to execute."@en ;
  rdfs:domain sh:SPARQLConstructExecutable ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "construct"@en ;
  rdfs:range xsd:string ;
.
sh:count
  a rdf:Property ;
  rdfs:comment "Resources with values for sh:count are node expressions that produce an xsd:integer counting all values of the associated node expression."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "count"@en ;
.
sh:datatype
  a rdf:Property ;
  rdfs:comment "Specifies an RDF datatype that all value nodes must have."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "datatype"@en ;
  rdfs:range rdfs:Datatype ;
.
sh:deactivated
  a rdf:Property ;
  rdfs:comment "If set to true then all nodes conform to this."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "deactivated"@en ;
  rdfs:range xsd:boolean ;
.
sh:declare
  a rdf:Property ;
  rdfs:comment "Links a resource with its namespace prefix declarations."@en ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "declare"@en ;
  rdfs:range sh:PrefixDeclaration ;
.
sh:defaultValue
  a rdf:Property ;
  rdfs:comment "A default value for a property, for example for user interface tools to pre-populate input fields."@en ;
  rdfs:domain sh:PropertyShape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "default value"@en ;
.
sh:desc
  a rdf:Property ;
  rdfs:comment "For sh:orderBy node expressions, sh:desc can be set to true to indicate descending order (defaulting to ascending)."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "desc"@en ;
.
sh:description
  a rdf:Property ;
  rdfs:comment "Human-readable descriptions for the property in the context of the surrounding shape."@en ;
  rdfs:domain sh:PropertyShape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "description"@en ;
.
sh:detail
  a rdf:Property ;
  rdfs:comment "Links a result with other results that provide more details, for example to describe violations against nested shapes."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "detail"@en ;
  rdfs:range sh:AbstractResult ;
.
sh:disjoint
  a rdf:Property ;
  rdfs:comment "Specifies a property where the set of values must be disjoint with the value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "disjoint"@en ;
  rdfs:range rdf:Property ;
.
sh:distinct
  a rdf:Property ;
  rdfs:comment "Resources with values for sh:distinct are node expressions that drop any duplicate values from the associated node expression."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "distinct"@en ;
.
sh:entailment
  a rdf:Property ;
  rdfs:comment "An entailment regime that indicates what kind of inferencing is required by a shapes graph."@en ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "entailment"@en ;
  rdfs:range rdfs:Resource ;
.
sh:equals
  a rdf:Property ;
  rdfs:comment "Specifies a property that must have the same values as the value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "equals"@en ;
  rdfs:range rdf:Property ;
.
sh:expectedValue
  a rdf:Property ;
.
sh:expression
  a rdf:Property ;
  rdfs:comment "The node expression that must return true for the value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "expression"@en ;
.
sh:filterShape
  a rdf:Property ;
  rdfs:comment "The shape that all input nodes of the expression need to conform to."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "filter shape"@en ;
  rdfs:range sh:Shape ;
.
sh:flags
  a rdf:Property ;
  rdfs:comment "An optional flag to be used with regular expression pattern matching."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "flags"@en ;
  rdfs:range xsd:string ;
.
sh:focusNode
  a rdf:Property ;
  rdfs:comment "The focus node that was validated when the result was produced."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "focus node"@en ;
.
sh:group
  a rdf:Property ;
  rdfs:comment "Can be used to link to a property group to indicate that a property shape belongs to a group of related property shapes."@en ;
  rdfs:domain sh:PropertyShape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "group"@en ;
  rdfs:range sh:PropertyGroup ;
.
sh:groupConcat
  a rdf:Property ;
  rdfs:comment "Resources with values for sh:groupConcat are node expressions that produce an xsd:string consisting of the concatenation of all values of the associated node expression, possibly separated by the value of sh:separator."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "group concat"@en ;
.
sh:hasValue
  a rdf:Property ;
  rdfs:comment "Specifies a value that must be among the value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "has value"@en ;
.
sh:ignoredProperties
  a rdf:Property ;
  rdfs:comment "An optional RDF list of properties that are also permitted in addition to those explicitly enumerated via sh:property/sh:path."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "ignored properties"@en ;
  rdfs:range rdf:List ;
.
sh:in
  a rdf:Property ;
  rdfs:comment "Specifies a list of allowed values so that each value node must be among the members of the given list."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "in"@en ;
  rdfs:range rdf:List ;
.
sh:intersection
  a rdf:Property ;
  rdfs:comment "A list of node expressions that shall be intersected."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "intersection"@en ;
.
sh:inversePath
  a rdf:Property ;
  rdfs:comment "The (single) value of this property represents an inverse path (object to subject)."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "inverse path"@en ;
  rdfs:range rdfs:Resource ;
.
sh:js
  a rdf:Property ;
  rdfs:comment "Constraints expressed in JavaScript." ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript constraint"@en ;
  rdfs:range sh:JSConstraint ;
.
sh:jsFunctionName
  a rdf:Property ;
  rdfs:comment "The name of the JavaScript function to execute."@en ;
  rdfs:domain sh:JSExecutable ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript function name"@en ;
  rdfs:range xsd:string ;
.
sh:jsLibrary
  a rdf:Property ;
  rdfs:comment "Declares which JavaScript libraries are needed to execute this."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript library"@en ;
  rdfs:range sh:JSLibrary ;
.
sh:jsLibraryURL
  a rdf:Property ;
  rdfs:comment "Declares the URLs of a JavaScript library. This should be the absolute URL of a JavaScript file. Implementations may redirect those to local files."@en ;
  rdfs:domain sh:JSLibrary ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "JavaScript library URL"@en ;
  rdfs:range xsd:anyURI ;
.
sh:labelTemplate
  a rdf:Property ;
  rdfs:comment "Outlines how human-readable labels of instances of the associated Parameterizable shall be produced. The values can contain {?paramName} as placeholders for the actual values of the given parameter."@en ;
  rdfs:domain sh:Parameterizable ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "label template"@en ;
.
sh:languageIn
  a rdf:Property ;
  rdfs:comment "Specifies a list of language tags that all value nodes must have."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "language in"@en ;
  rdfs:range rdf:List ;
.
sh:lessThan
  a rdf:Property ;
  rdfs:comment "Specifies a property that must have smaller values than the value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "less than"@en ;
  rdfs:range rdf:Property ;
.
sh:lessThanOrEquals
  a rdf:Property ;
  rdfs:comment "Specifies a property that must have smaller or equal values than the value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "less than or equals"@en ;
  rdfs:range rdf:Property ;
.
sh:limit
  a rdf:Property ;
  rdfs:comment "Resources with values N for sh:limit are node expressions that produce only the first N values of the associated node expression sh:nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "limit"@en ;
  rdfs:range xsd:integer ;
.
sh:max
  a rdf:Property ;
  rdfs:comment "Resources with values for sh:max are node expressions that produce the maximum value of the associated node expression."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "max"@en ;
.
sh:maxCount
  a rdf:Property ;
  rdfs:comment "Specifies the maximum number of values in the set of value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "max count"@en ;
  rdfs:range xsd:integer ;
.
sh:maxExclusive
  a rdf:Property ;
  rdfs:comment "Specifies the maximum exclusive value of each value node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "max exclusive"@en ;
.
sh:maxInclusive
  a rdf:Property ;
  rdfs:comment "Specifies the maximum inclusive value of each value node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "max inclusive"@en ;
.
sh:maxLength
  a rdf:Property ;
  rdfs:comment "Specifies the maximum string length of each value node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "max length"@en ;
  rdfs:range xsd:integer ;
.
sh:message
  a rdf:Property ;
  rdfs:comment "A human-readable message (possibly with placeholders for variables) explaining the cause of the result."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "message"@en ;
.
sh:min
  a rdf:Property ;
  rdfs:comment "Resources with values for sh:min are node expressions that produce the minimum value of the associated node expression."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "min"@en ;
.
sh:minCount
  a rdf:Property ;
  rdfs:comment "Specifies the minimum number of values in the set of value nodes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "min count"@en ;
  rdfs:range xsd:integer ;
.
sh:minExclusive
  a rdf:Property ;
  rdfs:comment "Specifies the minimum exclusive value of each value node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "min exclusive"@en ;
.
sh:minInclusive
  a rdf:Property ;
  rdfs:comment "Specifies the minimum inclusive value of each value node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "min inclusive"@en ;
.
sh:minLength
  a rdf:Property ;
  rdfs:comment "Specifies the minimum string length of each value node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "min length"@en ;
  rdfs:range xsd:integer ;
.
sh:minus
  a rdf:Property ;
  rdfs:comment "Resources with values for sh:minus are node expressions that produce all values of the associated node expression sh:nodes except those that are returned by the sh:minus expression."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "minus"@en ;
.
sh:name
  a rdf:Property ;
  rdfs:comment "Human-readable labels for the property in the context of the surrounding shape."@en ;
  rdfs:domain sh:PropertyShape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "name"@en ;
.
sh:namespace
  a rdf:Property ;
  rdfs:comment "The namespace associated with a prefix in a prefix declaration."@en ;
  rdfs:domain sh:PrefixDeclaration ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "namespace"@en ;
  rdfs:range xsd:anyURI ;
.
sh:node
  a rdf:Property ;
  dash:defaultValueType sh:NodeShape ;
  rdfs:comment "Specifies the node shape that all value nodes must conform to."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "node"@en ;
  rdfs:range sh:NodeShape ;
.
sh:nodeKind
  a rdf:Property ;
  rdfs:comment "Specifies the node kind (e.g. IRI or literal) each value node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "node kind"@en ;
  rdfs:range sh:NodeKind ;
.
sh:nodeValidator
  a rdf:Property ;
  rdfs:comment "The validator(s) used to evaluate a constraint in the context of a node shape."@en ;
  rdfs:domain sh:ConstraintComponent ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "shape validator"@en ;
  rdfs:range sh:Validator ;
.
sh:nodes
  a rdf:Property ;
  rdfs:comment "The node expression producing the input nodes of a filter shape expression."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "nodes"@en ;
.
sh:not
  a rdf:Property ;
  dash:defaultValueType sh:Shape ;
  rdfs:comment "Specifies a shape that the value nodes must not conform to."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "not"@en ;
  rdfs:range sh:Shape ;
.
sh:object
  a rdf:Property ;
  rdfs:comment "An expression producing the nodes that shall be inferred as objects."@en ;
  rdfs:domain sh:TripleRule ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "object"@en ;
.
sh:offset
  a rdf:Property ;
  rdfs:comment "Resources with values N for sh:offset are node expressions that produce only all values of the associated node expression sh:nodes after the first N values have been skipped."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "offset"@en ;
  rdfs:range xsd:integer ;
.
sh:oneOrMorePath
  a rdf:Property ;
  rdfs:comment "The (single) value of this property represents a path that is matched one or more times."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "one or more path"@en ;
  rdfs:range rdfs:Resource ;
.
sh:optional
  a rdf:Property ;
  rdfs:comment "Indicates whether a parameter is optional."@en ;
  rdfs:domain sh:Parameter ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "optional"@en ;
  rdfs:range xsd:boolean ;
.
sh:or
  a rdf:Property ;
  rdfs:comment "Specifies a list of shapes so that the value nodes must conform to at least one of the shapes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "or"@en ;
  rdfs:range rdf:List ;
.
sh:order
  a rdf:Property ;
  rdfs:comment "Specifies the relative order of this compared to its siblings. For example use 0 for the first, 1 for the second."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "order"@en ;
  rdfs:range xsd:decimal ;
.
sh:orderBy
  a rdf:Property ;
  rdfs:comment "Resources with a value for sh:orderBy are node expressions that produce all values of the associated node expression sh:nodes ordered by the given node expression (applied to each result value). Use sh:desc=true for descending order."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "orderBy"@en ;
.
sh:parameter
  a rdf:Property ;
  dash:defaultValueType sh:Parameter ;
  rdfs:comment "The parameters of a function or constraint component."@en ;
  rdfs:domain sh:Parameterizable ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "parameter"@en ;
  rdfs:range sh:Parameter ;
.
sh:path
  a rdf:Property ;
  rdfs:comment "Specifies the property path of a property shape."@en ;
  rdfs:domain sh:PropertyShape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "path"@en ;
  rdfs:range rdfs:Resource ;
.
sh:pattern
  a rdf:Property ;
  rdfs:comment "Specifies a regular expression pattern that the string representations of the value nodes must match."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "pattern"@en ;
  rdfs:range xsd:string ;
.
sh:predicate
  a rdf:Property ;
  rdfs:comment "An expression producing the properties that shall be inferred as predicates."@en ;
  rdfs:domain sh:TripleRule ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "predicate"@en ;
.
sh:prefix
  a rdf:Property ;
  rdfs:comment "The prefix of a prefix declaration."@en ;
  rdfs:domain sh:PrefixDeclaration ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "prefix"@en ;
  rdfs:range xsd:string ;
.
sh:prefixes
  a rdf:Property ;
  rdfs:comment "The prefixes that shall be applied before parsing the associated SPARQL query."@en ;
  rdfs:domain sh:SPARQLExecutable ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "prefixes"@en ;
  rdfs:range owl:Ontology ;
.
sh:property
  a rdf:Property ;
  dash:defaultValueType sh:PropertyShape ;
  rdfs:comment "Links a shape to its property shapes."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "property"@en ;
  rdfs:range sh:PropertyShape ;
.
sh:propertyValidator
  a rdf:Property ;
  rdfs:comment "The validator(s) used to evaluate a constraint in the context of a property shape."@en ;
  rdfs:domain sh:ConstraintComponent ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "property validator"@en ;
  rdfs:range sh:Validator ;
.
sh:qualifiedMaxCount
  a rdf:Property ;
  rdfs:comment "The maximum number of value nodes that can conform to the shape."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "qualified max count"@en ;
  rdfs:range xsd:integer ;
.
sh:qualifiedMinCount
  a rdf:Property ;
  rdfs:comment "The minimum number of value nodes that must conform to the shape."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "qualified min count"@en ;
  rdfs:range xsd:integer ;
.
sh:qualifiedValueShape
  a rdf:Property ;
  dash:defaultValueType sh:Shape ;
  rdfs:comment "The shape that a specified number of values must conform to."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "qualified value shape"@en ;
  rdfs:range sh:Shape ;
.
sh:qualifiedValueShapesDisjoint
  a rdf:Property ;
  rdfs:comment "Can be used to mark the qualified value shape to be disjoint with its sibling shapes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "qualified value shapes disjoint"@en ;
  rdfs:range xsd:boolean ;
.
sh:result
  a rdf:Property ;
  rdfs:comment "The validation results contained in a validation report."@en ;
  rdfs:domain sh:ValidationReport ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "result"@en ;
  rdfs:range sh:ValidationResult ;
.
sh:resultAnnotation
  a rdf:Property ;
  rdfs:comment "Links a SPARQL validator with zero or more sh:ResultAnnotation instances, defining how to derive additional result properties based on the variables of the SELECT query."@en ;
  rdfs:domain sh:SPARQLSelectValidator ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "result annotation"@en ;
  rdfs:range sh:ResultAnnotation ;
.
sh:resultMessage
  a rdf:Property ;
  rdfs:comment "Human-readable messages explaining the cause of the result."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "result message"@en ;
.
sh:resultPath
  a rdf:Property ;
  rdfs:comment "The path of a validation result, based on the path of the validated property shape."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "result path"@en ;
  rdfs:range rdfs:Resource ;
.
sh:resultSeverity
  a rdf:Property ;
  rdfs:comment "The severity of the result, e.g. warning."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "result severity"@en ;
  rdfs:range sh:Severity ;
.
sh:returnType
  a rdf:Property ;
  rdfs:comment "The expected type of values returned by the associated function."@en ;
  rdfs:domain sh:Function ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "return type"@en ;
  rdfs:range rdfs:Class ;
.
sh:rule
  a rdf:Property ;
  rdfs:comment "The rules linked to a shape."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "rule"@en ;
  rdfs:range sh:Rule ;
.
sh:select
  a rdf:Property ;
  rdfs:comment "The SPARQL SELECT query to execute."@en ;
  rdfs:domain sh:SPARQLSelectExecutable ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "select"@en ;
  rdfs:range xsd:string ;
.
sh:separator
  a rdf:Property ;
  rdfs:comment "For sh:concat node expressions, sh:separator can represent a separator string such as \", \" to be placed in between results."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "separator"@en ;
.
sh:severity
  a rdf:Property ;
  rdfs:comment "Defines the severity that validation results produced by a shape must have. Defaults to sh:Violation."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "severity"@en ;
  rdfs:range sh:Severity ;
.
sh:shapes
  a rdf:Property ;
.
sh:shapesGraph
  a rdf:Property ;
  rdfs:comment "Shapes graphs that should be used when validating this data graph."@en ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "shapes graph"@en ;
  rdfs:range owl:Ontology ;
.
sh:shapesGraphWellFormed
  a rdf:Property ;
  rdfs:comment "If true then the validation engine was certain that the shapes graph has passed all SHACL syntax requirements during the validation process."@en ;
  rdfs:domain sh:ValidationReport ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "shapes graph well-formed"@en ;
  rdfs:range xsd:boolean ;
.
sh:sourceConstraint
  a rdf:Property ;
  rdfs:comment "The constraint that was validated when the result was produced."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "source constraint"@en ;
.
sh:sourceConstraintComponent
  a rdf:Property ;
  rdfs:comment "The constraint component that is the source of the result."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "source constraint component"@en ;
  rdfs:range sh:ConstraintComponent ;
.
sh:sourceShape
  a rdf:Property ;
  rdfs:comment "The shape that is was validated when the result was produced."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "source shape"@en ;
  rdfs:range sh:Shape ;
.
sh:sparql
  a rdf:Property ;
  dash:defaultValueType sh:SPARQLConstraint ;
  rdfs:comment "Links a shape with SPARQL constraints."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "constraint (in SPARQL)"@en ;
  rdfs:range sh:SPARQLConstraint ;
.
sh:subject
  a rdf:Property ;
  rdfs:comment "An expression producing the resources that shall be inferred as subjects."@en ;
  rdfs:domain sh:TripleRule ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "subject"@en ;
.
sh:suggestedShapesGraph
  a rdf:Property ;
  rdfs:comment "Suggested shapes graphs for this ontology. The values of this property may be used in the absence of specific sh:shapesGraph statements."@en ;
  rdfs:domain owl:Ontology ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "suggested shapes graph"@en ;
  rdfs:range owl:Ontology ;
.
sh:sum
  a rdf:Property ;
  rdfs:comment "Resources with values for sh:sum are node expressions that produce the sum of all values of the associated node expression."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "sum"@en ;
.
sh:target
  a rdf:Property ;
  rdfs:comment "Links a shape to a target specified by an extension language, for example instances of sh:SPARQLTarget."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "target"@en ;
  rdfs:range sh:Target ;
.
sh:targetClass
  a rdf:Property ;
  rdfs:comment "Links a shape to a class, indicating that all instances of the class must conform to the shape."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "target class"@en ;
  rdfs:range rdfs:Class ;
.
sh:targetNode
  a rdf:Property ;
  rdfs:comment "Links a shape to individual nodes, indicating that these nodes must conform to the shape."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "target node"@en ;
.
sh:targetObjectsOf
  a rdf:Property ;
  rdfs:comment "Links a shape to a property, indicating that all all objects of triples that have the given property as their predicate must conform to the shape."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "target objects of"@en ;
  rdfs:range rdf:Property ;
.
sh:targetSubjectsOf
  a rdf:Property ;
  rdfs:comment "Links a shape to a property, indicating that all subjects of triples that have the given property as their predicate must conform to the shape."@en ;
  rdfs:domain sh:Shape ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "target subjects of"@en ;
  rdfs:range rdf:Property ;
.
sh:this
  a rdfs:Resource ;
  rdfs:comment "A node expression that represents the current focus node."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "this"@en ;
.
sh:union
  a rdf:Property ;
  rdfs:comment "A list of node expressions that shall be used together."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "union"@en ;
.
sh:uniqueLang
  a rdf:Property ;
  rdfs:comment "Specifies whether all node values must have a unique (or no) language tag."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "unique languages"@en ;
  rdfs:range xsd:boolean ;
.
sh:update
  a rdf:Property ;
  rdfs:comment "The SPARQL UPDATE to execute."@en ;
  rdfs:domain sh:SPARQLUpdateExecutable ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "update"@en ;
  rdfs:range xsd:string ;
.
sh:validator
  a rdf:Property ;
  rdfs:comment "The validator(s) used to evaluate constraints of either node or property shapes."@en ;
  rdfs:domain sh:ConstraintComponent ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "validator"@en ;
  rdfs:range sh:Validator ;
.
sh:value
  a rdf:Property ;
  rdfs:comment "An RDF node that has caused the result."@en ;
  rdfs:domain sh:AbstractResult ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "value"@en ;
.
sh:values
  a rdf:Property ;
  rdfs:comment "Links a property shape with one or more SHACL node expressions that are used to determine the values of the associated predicate based on the current focus node. Only valid for property shapes where the sh:path is an IRI."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "values"@en ;
.
sh:xone
  a rdf:Property ;
  rdfs:comment "Specifies a list of shapes so that the value nodes must conform to exactly one of the shapes."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "exactly one"@en ;
  rdfs:range rdf:List ;
.
sh:zeroOrMorePath
  a rdf:Property ;
  rdfs:comment "The (single) value of this property represents a path that is matched zero or more times."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "zero or more path"@en ;
  rdfs:range rdfs:Resource ;
.
sh:zeroOrOnePath
  a rdf:Property ;
  rdfs:comment "The (single) value of this property represents a path that is matched zero or one times."@en ;
  rdfs:isDefinedBy sh: ;
  rdfs:label "zero or one path"@en ;
  rdfs:range rdfs:Resource ;
.
_:b9425
  sp:varName "uri" ;
.
_:b22060
  sp:varName "prefix" ;
.
_:b81418
  sp:varName "sep" ;
.
_:b88089
  sp:varName "qname" ;
.
